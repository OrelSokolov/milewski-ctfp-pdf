% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{В}{ы можете} получить реальное понимание категорий, изучая разнообразие
примеров. Категории бывают всех форм и размеров и часто появляются в
неожиданных местах. Начнём с чего-то действительно простого.

\section{Без объектов}

Самая тривиальная категория --- это категория с нулевым количеством объектов и, следовательно,
нулевым количеством морфизмов. Это очень грустная категория сама по себе, но она может быть
важна в контексте других категорий, например, в
категории всех категорий (да, такая существует). Если вы думаете, что пустое
множество имеет смысл, то почему бы не пустой категории?

\section{Простые графы}

Вы можете строить категории, просто соединяя объекты стрелками. Вы можете
представить, как начинаете с любого ориентированного графа и превращаете его в категорию,
просто добавляя больше стрелок. Сначала добавьте тождественную стрелку в каждой вершине.
Затем для любых двух стрелок, таких что конец одной совпадает с
началом другой (другими словами, любые две \newterm{композиционные}
стрелки), добавьте новую стрелку, которая служит их композицией. Каждый раз, когда вы
добавляете новую стрелку, вы также должны рассмотреть её композицию с любой
другой стрелкой (кроме тождественных стрелок) и с самой собой. Вы обычно получаете
бесконечно много стрелок, но это нормально.

Другой способ взглянуть на этот процесс заключается в том, что вы создаёте
категорию, которая имеет объект для каждой вершины в графе и все
возможные \newterm{цепочки} композиционных рёбер графа как морфизмы. (Вы можете
даже рассматривать тождественные морфизмы как специальные случаи цепочек длины
ноль.)

Такая категория называется \newterm{свободная категория}, порождённая данным
графом. Это пример свободной конструкции, процесса завершения данной
структуры путём расширения её минимальным количеством элементов для
удовлетворения её законов (здесь законов категории). Мы увидим больше примеров
этого в будущем.

\section{Порядки}

А теперь к чему-то совершенно другому! Категория, где морфизм
--- это отношение между объектами: отношение быть меньше или равным.
Давайте проверим, действительно ли это категория. Есть ли у нас тождественные морфизмы?
Каждый объект меньше или равен себе: проверка! Есть ли у нас
композиция? Если $a \leqslant b$ и $b \leqslant c$, то $a \leqslant c$: проверка! Ассоциативна ли композиция? Проверка! Множество с
отношением, подобным этому, называется \newterm{предпорядок}, так что предпорядок действительно
является категорией.

Вы также можете иметь более сильное отношение, которое удовлетворяет дополнительному
условию: если $a \leqslant b$ и $b \leqslant a$, то $a$ должно быть
таким же, как $b$. Это называется \newterm{частичный порядок}.

Наконец, вы можете наложить условие, что любые два объекта находятся в
отношении друг с другом, так или иначе; и это даёт вам
\newterm{линейный порядок} или \newterm{полный порядок}.

Давайте охарактеризуем эти упорядоченные множества как категории. Предпорядок --- это
категория, где существует не более одного морфизма, идущего из любого объекта $a$ в
любой объект $b$. Другое имя для такой категории --- ``тонкая''. Предпорядок
--- это тонкая категория.

Множество морфизмов из объекта $a$ в объект $b$ в категории $\cat{C}$ называется
\newterm{hom-множество} и записывается как $\cat{C}(a, b)$ (или иногда
$\mathbf{Hom}_{\cat{C}}(a, b)$). Итак, каждое hom-множество в предпорядке либо
пусто, либо является синглетоном. Это включает hom-множество $\cat{C}(a, a)$, множество
морфизмов из $a$ в $a$, которое должно быть синглетоном, содержащим только
тождество, в любом предпорядке. Однако у вас могут быть циклы в предпорядке.
Циклы запрещены в частичном порядке.

Очень важно уметь распознавать предпорядки, частичные порядки
и полные порядки из-за сортировки. Алгоритмы сортировки, такие как
quicksort, bubble sort, merge sort и т.д., могут правильно работать только на
полных порядках. Частичные порядки могут быть отсортированы с использованием топологической сортировки.

\section{Моноид как множество}

Моноид --- это смехотворно простая, но удивительно мощная концепция. Это
концепция, лежащая в основе базовой арифметики: и сложение, и умножение
образуют моноид. Моноиды повсеместны в программировании. Они появляются как
строки, списки, свёртываемые структуры данных, futures в конкурентном
программировании, события в функциональном реактивном программировании и так далее.

Традиционно моноид определяется как множество с бинарной операцией. Всё,
что требуется от этой операции, --- это чтобы она была ассоциативной, и чтобы
существовал один специальный элемент, который ведёт себя как единица относительно
неё.

Например, натуральные числа с нулём образуют моноид при сложении.
Ассоциативность означает, что:
\[(a + b) + c = a + (b + c)\]
(Другими словами, мы можем пропустить скобки при сложении чисел.)

Нейтральный элемент --- это ноль, потому что:
\[0 + a = a\]
и
\[a + 0 = a\]
Второе уравнение избыточно, потому что сложение коммутативно $(a + b
  = b + a)$, но коммутативность не является частью определения моноида.
Например, конкатенация строк не коммутативна, и всё же она образует
моноид. Нейтральный элемент для конкатенации строк, кстати, --- это
пустая строка, которая может быть присоединена к любой стороне строки без
её изменения.

В Haskell мы можем определить класс типов для моноидов --- тип, для которого
существует нейтральный элемент, называемый \code{mempty}, и бинарная операция,
называемая \code{mappend}:

\src{snippet01}
Сигнатура типа для функции двух аргументов,
\code{m -> m -> m}, может сначала выглядеть странно,
но она будет иметь полный смысл после того, как мы поговорим о каррировании. Вы можете
интерпретировать сигнатуру с несколькими стрелками двумя основными способами: как
функцию нескольких аргументов, с самым правым типом, являющимся типом возврата;
или как функцию одного аргумента (самого левого), возвращающую
функцию. Последняя интерпретация может быть подчёркнута добавлением
скобок (которые избыточны, потому что стрелка
право-ассоциативна), как в: \code{m -> (m -> m)}.
Мы вернёмся к этой интерпретации через мгновение.

Обратите внимание, что в Haskell нет способа выразить моноидальные
свойства \code{mempty} и \code{mappend} (т.е. тот факт, что
\code{mempty} нейтрален и что \code{mappend} ассоциативен).
Это ответственность программиста убедиться, что они
удовлетворены.

Классы Haskell не так навязчивы, как классы C++. Когда вы
определяете новый тип, вам не нужно указывать его класс заранее. Вы
свободны откладывать и объявлять данный тип экземпляром
какого-либо класса гораздо позже. В качестве примера давайте объявим \code{String}
моноидом, предоставив реализацию \code{mempty} и
\code{mappend} (это, на самом деле, сделано для вас в стандартном
Prelude):

\src{snippet02}
Здесь мы переиспользовали оператор конкатенации списков \code{(++)},
потому что \code{String} --- это просто список символов.

Слово о синтаксисе Haskell: любой инфиксный оператор может быть превращён в
функцию двух аргументов, окружив его скобками. Имея две
строки, вы можете конкатенировать их, вставив \code{++} между ними:

\begin{snip}{haskell}
"Hello " ++ "world!"
\end{snip}
или передав их как два аргумента в скобочный \code{(++)}:

\begin{snip}{haskell}
(++) "Hello " "world!"
\end{snip}
Обратите внимание, что аргументы функции не разделяются запятыми и не
окружаются скобками. (Это, вероятно, самое трудное, к чему нужно привыкнуть,
изучая Haskell.)

Стоит подчеркнуть, что Haskell позволяет вам выражать равенство
функций, как в:

\begin{snip}{haskell}
mappend = (++)
\end{snip}
Концептуально это отличается от выражения равенства значений,
произведённых функциями, как в:

\begin{snip}{haskell}
mappend s1 s2 = (++) s1 s2
\end{snip}
Первое переводится в равенство морфизмов в категории
$\Hask$ (или $\Set$, если мы игнорируем дно, которое является именем
для бесконечных вычислений). Такие уравнения не только более
лаконичны, но часто могут быть обобщены на другие категории. Последнее
называется \newterm{экстенсиональное} равенство и утверждает факт, что для любых
двух входных строк выходы \code{mappend} и \code{(++)}
одинаковы. Поскольку значения аргументов иногда называются
\newterm{точками} (как в: значение $f$ в точке $x$), это называется
точечное равенство. Равенство функций без указания аргументов
описывается как \newterm{бесточечное}. (Кстати, бесточечные уравнения
часто включают композицию функций, которая символизируется точкой,
так что это может быть немного запутанным для новичка.)

Ближайшее, к чему можно приблизиться в объявлении моноида в C++, было бы использование
возможности концепций стандарта C++20.

\begin{snip}{cpp}
template<class T>
struct mempty;

template<class T>
T mappend(T, T) = delete;

template<class M>
concept Monoid = requires (M m) {
    { mempty<M>::value() } -> std::same_as<M>;
    { mappend(m, m) } -> std::same_as<M>;
};
\end{snip}
Первое определение --- это структура, предназначенная для хранения нейтрального элемента для каждой
специализации.

Ключевое слово \code{delete} означает, что нет значения по умолчанию,
определённого: оно должно быть указано в каждом конкретном случае.
Аналогично, нет значения по умолчанию для \code{mappend}.

Концепция \code{Monoid} проверяет, существуют ли соответствующие определения
\code{mempty} и \code{mappend} для данного типа \code{M}.

Создание экземпляра концепции Monoid может быть выполнено путём предоставления
соответствующих специализаций и перегрузок:

\begin{snip}{cpp}
template<>
struct mempty<std::string> {
    static std::string value() { return ""; }
};

template<>
std::string mappend(std::string s1, std::string s2) {
    return s1 + s2;
}
\end{snip}

\section{Моноид как категория}

Это было ``привычное'' определение моноида в терминах элементов
множества. Но, как вы знаете, в теории категорий мы пытаемся уйти от
множеств и их элементов, и вместо этого говорить об объектах и морфизмах.
Так что давайте немного изменим нашу перспективу и подумаем о применении
бинарного оператора как о ``движении'' или ``сдвиге'' вещей вокруг множества.

Например, есть операция добавления 5 к каждому натуральному
числу. Она отображает 0 в 5, 1 в 6, 2 в 7 и так далее. Это функция,
определённая на множестве натуральных чисел. Это хорошо: у нас есть функция
и множество. В общем, для любого числа n существует функция добавления $n$
--- ``прибавитель'' $n$.

Как композируются прибавители? Композиция функции, которая добавляет 5, с
функцией, которая добавляет 7, --- это функция, которая добавляет 12. Таким образом, композиция
прибавителей может быть сделана эквивалентной правилам сложения. Это тоже хорошо:
мы можем заменить сложение композицией функций.

Но подождите, есть ещё: есть также прибавитель для нейтрального элемента,
нуля. Добавление нуля не перемещает вещи, поэтому это тождественная
функция в множестве натуральных чисел.

Вместо того чтобы давать вам традиционные правила сложения, я мог бы также
дать вам правила композиции прибавителей, без какой-либо потери информации.
Обратите внимание, что композиция прибавителей ассоциативна, потому что
композиция функций ассоциативна; и у нас есть нулевой прибавитель,
соответствующий тождественной функции.

Проницательный читатель мог заметить, что отображение из целых чисел в
прибавители следует из второй интерпретации сигнатуры типа
\code{mappend} как \code{m -> (m -> m)}. Оно
говорит нам, что \code{mappend} отображает элемент моноидального множества в
функцию, действующую на этом множестве.

Теперь я хочу, чтобы вы забыли, что имеете дело с множеством натуральных
чисел, и просто думали о нём как о единственном объекте, капле с кучей
морфизмов --- прибавителями. Моноид --- это одно-объектная категория. На самом деле
имя моноид происходит от греческого \emph{mono}, что означает единственный. Каждый
моноид может быть описан как одно-объектная категория с множеством
морфизмов, которые следуют соответствующим правилам композиции.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/monoid.jpg}
\end{figure}

\noindent
Конкатенация строк --- интересный случай, потому что у нас есть выбор
определения правых присоединителей и левых присоединителей (или \emph{предшествователей}, если
хотите). Таблицы композиции двух моделей зеркально обратны
друг другу. Вы можете легко убедить себя, что присоединение ``bar''
после ``foo'' соответствует предшествованию ``foo'' после предшествования
``bar''.

Вы можете задать вопрос, определяет ли каждый категорный моноид ---
одно-объектная категория --- уникальное множество-с-бинарной-операцией
моноида. Оказывается, что мы всегда можем извлечь множество из
одно-объектной категории. Это множество --- это множество морфизмов --- прибавителей
в нашем примере. Другими словами, у нас есть hom-множество $\cat{M}(m, m)$
единственного объекта $m$ в категории $\cat{M}$. Мы можем легко определить бинарный
оператор в этом множестве: моноидальное произведение двух элементов множества --- это
элемент, соответствующий композиции соответствующих морфизмов.
Если вы дадите мне два элемента $\cat{M}(m, m)$, соответствующие $f$ и
$g$, их произведением будет соответствовать композиция
$f \circ g$. Композиция всегда существует, потому что источник и
цель для этих морфизмов --- это один и тот же объект. И она ассоциативна по
правилам категории. Тождественный морфизм --- это нейтральный элемент
этого произведения. Так что мы всегда можем восстановить множественный моноид из категорного
моноида. Для всех практических целей они одно и то же.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoidhomset.jpg}
  \caption{Моноид hom-множества, видимый как морфизмы и как точки в множестве.}
\end{figure}

\noindent
Есть только одна маленькая придирка для математиков: морфизмы не
обязаны образовывать множество. В мире категорий есть вещи больше,
чем множества. Категория, в которой морфизмы между любыми двумя объектами образуют
множество, называется локально малой. Как и обещал, я буду в основном игнорировать такие
тонкости, но я подумал, что должен упомянуть их для записи.

Многие интересные явления в теории категорий имеют свой корень в
том факте, что элементы hom-множества могут рассматриваться и как морфизмы, которые
следуют правилам композиции, и как точки в множестве. Здесь
композиция морфизмов в $\cat{M}$ переводится в моноидальное произведение в
множестве $\cat{M}(m, m)$.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Создайте свободную категорию из:

        \begin{enumerate}
          \tightlist
          \item
                Графа с одной вершиной и без рёбер
          \item
                Графа с одной вершиной и одним (направленным) ребром (подсказка: это ребро может
                быть скомпозировано с самим собой)
          \item
                Графа с двумя вершинами и одной стрелкой между ними
          \item
                Графа с одной вершиной и 26 стрелками, помеченными буквами
                алфавита: a, b, c \ldots{} z.
        \end{enumerate}
  \item
        Какой это порядок?

        \begin{enumerate}
          \tightlist
          \item
                Множество множеств с отношением включения: $A$ включено в $B$, если
                каждый элемент $A$ также является элементом $B$.
          \item
                Типы C++ со следующим отношением подтипов: \code{T1} --- это подтип
                \code{T2}, если указатель на \code{T1} может быть передан в функцию, которая ожидает
                указатель на \code{T2}, без вызова ошибки компиляции.
        \end{enumerate}
  \item
        Учитывая, что \code{Bool} --- это множество двух значений \code{True} и \code{False}, покажите, что
        оно образует два (теоретико-множественных) моноида относительно, соответственно,
        оператора \code{\&\&} (AND) и \code{||} (OR).
  \item
        Представьте моноид \code{Bool} с оператором AND как категорию: перечислите
        морфизмы и их правила композиции.
  \item
        Представьте сложение по модулю 3 как моноидальную категорию.
\end{enumerate}
