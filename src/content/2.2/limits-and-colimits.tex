% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{К}{ажется, что в теории категорий} всё связано со всем, и
всё может быть рассмотрено под многими углами. Возьмите, например,
универсальную конструкцию \hyperref[products-and-coproducts]{произведения}.
Теперь, когда мы знаем больше о \hyperref[functors]{функторах} и
\hyperref[natural-transformations]{естественных преобразованиях}, можем ли мы упростить и, возможно, обобщить её? Давайте
попробуем.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/productpattern.jpg}
\end{figure}

\noindent
Конструкция произведения начинается с выбора двух объектов
$a$ и $b$, чьё произведение мы хотим сконструировать. Но что
означает \emph{выбрать объекты}? Можем ли мы переформулировать это действие в
более категорных терминах? Два объекта образуют паттерн --- очень простой
паттерн. Мы можем абстрагировать этот паттерн в категорию --- очень простую
категорию, но категорию тем не менее. Это категория, которую мы назовём
$\cat{2}$. Она содержит только два объекта, $1$ и $2$, и никаких морфизмов,
кроме двух обязательных тождеств. Теперь мы можем переформулировать
выбор двух объектов в $\cat{C}$ как акт определения функтора $D$
из категории $\cat{2}$ в $\cat{C}$. Функтор отображает объекты в
объекты, поэтому его образ --- просто два объекта (или может быть один, если
функтор схлопывает объекты, что тоже нормально). Он также отображает морфизмы
--- в этом случае он просто отображает тождественные морфизмы в тождественные
морфизмы.

Что отлично в этом подходе, так это то, что он строится на категорных
понятиях, избегая неточных описаний типа ``выбор
объектов'', взятых прямо из лексикона охотников-собирателей наших
предков. И, кстати, это также легко обобщается, потому что
ничто не может остановить нас от использования категорий более сложных, чем $\cat{2}$,
для определения наших паттернов.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/two.jpg}
\end{figure}

\noindent
Но давайте продолжим. Следующий шаг в определении произведения --- это
выбор объекта-кандидата $c$. Здесь снова мы могли бы
переформулировать выбор в терминах функтора из одноэлементной категории.
И действительно, если бы мы использовали расширения Кана, это было бы правильным
делом. Но поскольку мы не готовы к расширениям Кана ещё, есть
другой трюк, который мы можем использовать: постоянный функтор $\Delta$ из той же категории
$\cat{2}$ в $\cat{C}$. Выбор $c$ в $\cat{C}$ может быть
сделан с $\Delta_c$. Помните, $\Delta_c$ отображает все
объекты в $c$ и все морфизмы в $\idarrow[c]$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/twodelta.jpg}
\end{figure}

\noindent
Теперь у нас есть два функтора, $\Delta_c$ и $D$, идущие между
$\cat{2}$ и $\cat{C}$, поэтому естественно спросить о естественных
преобразованиях между ними. Поскольку есть только два объекта в
$\cat{2}$, естественное преобразование будет иметь две компоненты. Объект $1$
в $\cat{2}$ отображается в $c$ функтором $\Delta_c$ и в
$a$ функтором $D$. Так что компонента естественного преобразования между
$\Delta_c$ и $D$ в $1$ --- это морфизм из $c$ в
$a$. Мы можем назвать его $p$. Аналогично, вторая компонента
--- это морфизм $q$ из $c$ в $b$ --- образ
объекта $2$ в $\cat{2}$ под $D$. Но это в точности как две
проекции, которые мы использовали в нашем исходном определении произведения. Поэтому
вместо того, чтобы говорить о выборе объектов и проекций, мы можем просто
говорить о выборе функторов и естественных преобразований. Так случается,
что в этом простом случае условие естественности для нашего преобразования
тривиально удовлетворено, потому что нет морфизмов (кроме
тождеств) в $\cat{2}$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/productcone.jpg}
\end{figure}

\noindent
Обобщение этой конструкции на категории, отличные от
$\cat{2}$ --- те, которые, например, содержат нетривиальные морфизмы
--- наложит условия естественности на преобразование между
$\Delta_c$ и $D$. Мы называем такое преобразование \emph{конусом},
потому что образ $\Delta$ --- это вершина конуса/пирамиды, чьи стороны
образованы компонентами естественного преобразования. Образ $D$
формирует основание конуса.

В общем случае, чтобы построить конус, мы начинаем с категории $\cat{I}$, которая
определяет паттерн. Это малая, часто конечная категория. Мы выбираем
функтор $D$ из $\cat{I}$ в $\cat{C}$ и называем его (или его образ)
\emph{диаграммой}. Мы выбираем некоторый $c$ в $\cat{C}$ как вершину нашего
конуса. Мы используем его для определения постоянного функтора $\Delta_c$ из
$\cat{I}$ в $\cat{C}$. Естественное преобразование из $\Delta_c$
в $D$ --- это тогда наш конус. Для конечного $\cat{I}$ это просто куча
морфизмов, соединяющих $c$ с диаграммой: образом $\cat{I}$
под $D$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/cone.jpg}
\end{figure}

\noindent
Естественность требует, чтобы все треугольники (стены пирамиды) в
этой диаграмме коммутировали. Действительно, возьмите любой морфизм $f$ в $\cat{I}$.
Функтор $D$ отображает его в морфизм $D f$ в $\cat{C}$,
морфизм, который образует основание некоторого треугольника. Постоянный функтор
$\Delta_c$ отображает $f$ в тождественный морфизм на
$c$. $\Delta$ сдавливает два конца морфизма в один объект, и
квадрат естественности становится коммутирующим треугольником. Два плеча этого
треугольника --- компоненты естественного преобразования.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/conenaturality.jpg}
\end{figure}

\noindent
Итак, это один конус. То, что нас интересует, --- это \newterm{универсальный
  конус} --- так же, как мы выбрали универсальный объект для нашего определения
произведения.

Есть много способов подойти к этому. Например, мы можем определить
\emph{категорию конусов} на основе данного функтора $D$. Объекты в этой
категории --- конусы. Не каждый объект $c$ в $\cat{C}$ может быть
вершиной конуса, однако, потому что может не быть естественного преобразования
между $\Delta_c$ и $D$.

Чтобы сделать это категорией, мы также должны определить морфизмы между конусами.
Они были бы полностью определены морфизмами между их вершинами. Но
не любой морфизм подойдёт. Помните, что в нашей конструкции
произведения мы наложили условие, что морфизмы между кандидатами
объектов (вершинами) должны быть общими факторами для проекций. Например:

\src{snippet01}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/productranking.jpg}
\end{figure}

Это условие переводится, в общем случае, в условие, что
треугольники, чья одна сторона --- факторизующий морфизм, все коммутируют.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/conecommutativity.jpg}
  \caption{Коммутирующий треугольник, соединяющий два конуса, с факторизующим
    морфизмом $h$ (здесь нижний конус универсальный, с
    $\Lim[D]$ как его вершиной)}
\end{figure}

\noindent
Мы возьмём эти факторизующие морфизмы как морфизмы в нашей категории
конусов. Легко проверить, что эти морфизмы действительно композируются, и
что тождественный морфизм тоже является факторизующим морфизмом. Конусы
следовательно образуют категорию.

Теперь мы можем определить универсальный конус как \emph{терминальный объект} в
категории конусов. Определение терминального объекта утверждает, что
существует уникальный морфизм из любого другого объекта в этот объект. В нашем
случае это означает, что существует уникальный факторизующий морфизм из вершины
любого другого конуса в вершину универсального конуса. Мы называем этот
универсальный конус \emph{пределом} диаграммы $D$, $\Lim[D]$ (в
литературе вы часто увидите левую стрелку, указывающую на $I$
под знаком $\Lim$). Часто, как сокращение, мы называем вершину
этого конуса пределом (или объектом-пределом).

Интуиция в том, что предел воплощает свойства всей
диаграммы в одном объекте. Например, предел нашей двух-объектной
диаграммы --- это произведение двух объектов. Произведение (вместе с
двумя проекциями) содержит информацию об обоих объектах. А быть
универсальным означает, что в нём нет лишнего мусора.

\section{Предел как естественный изоморфизм}

Всё ещё есть что-то неудовлетворительное в этом определении предела.
Я имею в виду, оно работоспособно, но у нас всё ещё есть это условие коммутативности
для треугольников, которые связывают любые два конуса. Было бы намного
более элегантно, если бы мы могли заменить его каким-то условием естественности. Но
как?

Мы больше не имеем дело с одним конусом, а с целой коллекцией (на
самом деле, категорией) конусов. Если предел существует (и --- давайте сделаем это
ясным --- нет гарантии этого), один из этих конусов --- универсальный
конус. Для каждого другого конуса у нас есть уникальный факторизующий
морфизм, который отображает его вершину, назовём её $c$, в вершину
универсального конуса, которую мы назвали $\Lim[D]$. (На самом деле, я могу пропустить
слово ``другой'', потому что тождественный морфизм отображает универсальный
конус в себя, и он тривиально факторизуется через себя.) Позвольте мне
повторить важную часть: для данного любого конуса существует уникальный морфизм
специального вида. У нас есть отображение конусов в специальные морфизмы, и
это взаимно однозначное отображение.

Этот специальный морфизм --- член hom-множества $\cat{C}(c, \Lim[D])$.
Другие члены этого hom-множества менее удачливы в том смысле, что
они не факторизуют отображение двух конусов. То, что мы хотим, --- это иметь возможность
выбрать, для каждого $c$, один морфизм из множества
$\cat{C}(c, \Lim[D])$ --- морфизм, который удовлетворяет конкретному
условию коммутативности. Звучит ли это как определение естественного
преобразования? Определённо да!

Но каковы функторы, которые связаны этим преобразованием?

Один функтор --- это отображение $c$ в множество
$\cat{C}(c, \Lim[D])$. Это функтор из $\cat{C}$ в $\Set$ ---
он отображает объекты в множества. На самом деле это контравариантный функтор. Вот
как мы определяем его действие на морфизмы: возьмём морфизм $f$
из $c'$ в $c$:
\[f \Colon c' \to c\]
Наш функтор отображает $c'$ в множество
$\cat{C}(c', \Lim[D])$. Чтобы определить действие этого функтора на
$f$ (другими словами, поднять $f$), мы должны определить
соответствующее отображение между $\cat{C}(c, \Lim[D])$ и
$\cat{C}(c', \Lim[D])$. Так что давайте выберем один элемент $u$ из
$\cat{C}(c, \Lim[D])$ и посмотрим, можем ли мы отобразить его в некоторый элемент
$\cat{C}(c', \Lim[D])$. Элемент hom-множества --- это морфизм, так что
у нас есть:
\[u \Colon c \to \Lim[D]\]
Мы можем предкомпозировать $u$ с $f$, чтобы получить:
\[u \circ f \Colon c' \to \Lim[D]\]
И это элемент $\cat{C}(c', \Lim[D])$--- так что действительно, мы
нашли отображение морфизмов:

\src{snippet02}
Обратите внимание на инверсию в порядке $c$ и $c'$,
характерную для \emph{контравариантного} функтора.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/homsetmapping.jpg}
\end{figure}

\noindent
Чтобы определить естественное преобразование, нам нужен другой функтор, который также
отображает из $\cat{C}$ в $\Set$. Но на этот раз мы рассмотрим
множество конусов. Конусы --- это просто естественные преобразования, поэтому мы смотрим
на множество естественных преобразований $\mathit{Nat}(\Delta_c, D)$. Отображение
из $c$ в это конкретное множество естественных преобразований ---
(контравариантный) функтор. Как мы можем показать это? Опять, давайте определим его
действие на морфизм:
\[f \Colon c' \to c\]
Подъём $f$ должен быть отображением естественных преобразований
между двумя функторами, которые идут из $\cat{I}$ в $\cat{C}$:
\[\mathit{Nat}(\Delta_c, D) \to \mathit{Nat}(\Delta_{c'}, D)\]
Как мы отображаем естественные преобразования? Каждое естественное преобразование --- это
выбор морфизмов --- его компонент --- один морфизм на элемент
$\cat{I}$. Компонента некоторого $\alpha$ (члена $\mathit{Nat}(\Delta_c, D)$) в
$a$ (объекте в $\cat{I}$) --- это морфизм:
\[\alpha_a \Colon \Delta_c a \to D a\]
или, используя определение постоянного функтора $\Delta$,
\[\alpha_a \Colon c \to D a\]
Для данных $f$ и $\alpha$ мы должны сконструировать $\beta$, член
$\mathit{Nat}(\Delta_{c'}, D)$. Его компонента в $a$ должна быть
морфизмом:
\[\beta_a \Colon c' \to D a\]
Мы можем легко получить последнее ($\beta_a$) из первого ($\alpha_a$), предкомпозировав его с
$f$:
\[\beta_a = \alpha_a \circ f\]
Относительно легко показать, что эти компоненты действительно складываются в
естественное преобразование.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/natmapping.jpg}
\end{figure}

\noindent
Для данного нашего морфизма $f$ мы таким образом построили отображение между двумя
естественными преобразованиями, покомпонентно. Это отображение определяет
\code{contramap} для функтора:
\[c \to \mathit{Nat}(\Delta_c, D)\]
То, что я только что сделал, --- это показал вам, что у нас есть два (контравариантных)
функтора из $\cat{C}$ в $\Set$. Я не делал никаких предположений
--- эти функторы всегда существуют.

Кстати, первый из этих функторов играет важную роль в
теории категорий, и мы увидим его снова, когда будем говорить о
лемме Ёнеды. Есть название для контравариантных функторов из любой категории
$\cat{C}$ в $\Set$: они называются ``предпучками''. Этот
называется \newterm{представимым предпучком}. Второй функтор также
предпучок.

Теперь, когда у нас есть два функтора, мы можем говорить о естественных преобразованиях
между ними. Так что без дальнейших церемоний, вот вывод: функтор
$D$ из $\cat{I}$ в $\cat{C}$ имеет предел $\Lim[D]$ тогда и
только тогда, когда существует естественный изоморфизм между двумя функторами, которые я только что
определил:
\[\cat{C}(c, \Lim[D]) \simeq \mathit{Nat}(\Delta_c, D)\]
Позвольте мне напомнить вам, что такое естественный изоморфизм. Это естественное
преобразование, каждая компонента которого --- изоморфизм, то есть
обратимый морфизм.

Я не буду проходить через доказательство этого утверждения. Процедура
довольно прямолинейна, если не утомительна. При работе с естественными
преобразованиями вы обычно фокусируетесь на компонентах, которые являются морфизмами.
В этом случае, поскольку цель обоих функторов --- $\Set$,
компоненты естественного изоморфизма будут функциями. Это
функции высшего порядка, потому что они идут из hom-множества в множество
естественных преобразований. Опять, вы можете анализировать функцию,
рассматривая, что она делает со своим аргументом: здесь аргумент будет
морфизмом --- членом $\cat{C}(c, \Lim[D])$ --- а результат будет
естественным преобразованием --- членом $\mathit{Nat}(\Delta_c, D)$, или
тем, что мы назвали конусом. Это естественное преобразование, в свою очередь, имеет
свои собственные компоненты, которые являются морфизмами. Так что это морфизмы до самого
низа, и если вы можете отслеживать их, вы можете доказать утверждение.

Самый важный результат --- что условие естественности для этого
изоморфизма в точности является условием коммутативности для отображения
конусов.

Как предварительный просмотр грядущих аттракционов, позвольте мне упомянуть, что множество
$\mathit{Nat}(\Delta_c, D)$ может рассматриваться как hom-множество в категории
функторов; так что наш естественный изоморфизм связывает два hom-множества, что указывает
на ещё более общее отношение, называемое сопряжением.

\section{Примеры пределов}

Мы видели, что категорное произведение --- это предел диаграммы,
порождённой простой категорией, которую мы назвали $\cat{2}$.

Есть ещё более простой пример предела: терминальный объект.
Первый импульс был бы думать об одноэлементной категории как ведущей к
терминальному объекту, но правда ещё более явная: терминальный
объект --- это предел, порождённый пустой категорией. Функтор из
пустой категории не выбирает объектов, поэтому конус сжимается до просто вершины.
Универсальный конус --- это одинокая вершина, которая имеет уникальный морфизм, приходящий к
ней из любой другой вершины. Вы узнаете это как определение
терминального объекта.

Следующий интересный предел называется \emph{эквалайзер}. Это предел,
порождённый двухэлементной категорией с двумя параллельными морфизмами, идущими
между ними (и, как всегда, тождественными морфизмами). Эта категория
выбирает диаграмму в $\cat{C}$, состоящую из двух объектов, $a$ и
$b$, и двух морфизмов:

\src{snippet03}

Чтобы построить конус над этой диаграммой, мы должны добавить вершину, $c$,
и две проекции:

\src{snippet04}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/equalizercone.jpg}
\end{figure}

\noindent
У нас есть два треугольника, которые должны коммутировать:

\src{snippet05}

Это говорит нам, что $q$ уникально определяется одним из этих
уравнений, скажем, \code{q = f . p}, и мы можем опустить его из
картинки. Так что мы остались только с одним условием:

\src{snippet06}

Способ думать об этом в том, что если мы ограничим наше внимание на
$\Set$, образ функции $p$ выбирает подмножество
$a$. Когда ограничено этим подмножеством, функции $f$ и
$g$ равны.

Например, возьмите $a$ как двумерную плоскость,
параметризованную координатами $x$ и $y$. Возьмите $b$
как вещественную линию, и возьмите:

\src{snippet07}

Эквалайзер для этих двух функций --- это множество вещественных чисел (вершина,
$c$) и функция:

\src{snippet08}

Обратите внимание, что $(p~t)$ определяет прямую линию в
двумерной плоскости. Вдоль этой линии две функции равны.

Конечно, есть другие множества $c'$ и функции
$p'$, которые могут привести к равенству:

\src{snippet09}

но все они уникально факторизуются через $p$. Например, мы
можем взять одноэлементное множество $\cat{()}$ как $c'$ и
функцию:

\src{snippet10}

Это хороший конус, потому что $f (0, 0) = g (0, 0)$. Но он
не универсален из-за уникальной факторизации через $h$:

\src{snippet11}

с

\src{snippet12}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/equilizerlimit.jpg}
\end{figure}

\noindent
Таким образом, эквалайзер может быть использован для решения уравнений типа
$f~x = g~x$. Но он намного более общий, потому что он определён
в терминах объектов и морфизмов, а не алгебраически.

Ещё более общая идея решения уравнения воплощена в другом
пределе --- pullback (обратная протяжка). Здесь у нас всё ещё есть два морфизма, которые мы хотим
приравнять, но на этот раз их области определения различны. Мы начинаем с
трёхобъектной категории формы:
$1\rightarrow2\leftarrow3$. Диаграмма, соответствующая
этой категории, состоит из трёх объектов, $a$, $b$ и
$c$, и двух морфизмов:

\src{snippet13}

Эта диаграмма часто называется \emph{cospan} (копромежуток).

Конус, построенный поверх этой диаграммы, состоит из вершины, $d$,
и трёх морфизмов:

\src{snippet14}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/pullbackcone.jpg}
\end{figure}

\noindent
Условия коммутативности говорят нам, что $r$ полностью
определён другими морфизмами и может быть опущен из картинки.
Так что мы остались только со следующим условием:

\src{snippet15}
Pullback --- это универсальный конус этой формы.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/pullbacklimit.jpg}
\end{figure}

\noindent
Опять же, если вы сузите свой фокус до множеств, вы можете думать об
объекте $d$ как состоящем из пар элементов из $a$ и
$c$, для которых $f$, действующий на первый компонент, равен
$g$, действующему на второй компонент. Если это всё ещё слишком
общее, рассмотрите специальный случай, в котором $g$ --- постоянная
функция, скажем, $g~\_ = 1.23$ (предполагая, что $b$ --- множество
вещественных чисел). Тогда вы действительно решаете уравнение:

\src{snippet16}

В этом случае выбор $c$ не релевантен (если он
не пустое множество), поэтому мы можем взять его как одноэлементное множество.
Множество $a$ могло бы, например, быть множеством трёхмерных векторов,
а $f$ --- длиной вектора. Тогда pullback --- это множество пар
$(v, ())$, где $v$ --- вектор длины 1.23 (решение
уравнения $\sqrt{(x^{2}+y^{2}+z^{2})} = 1.23$), а
$()$ --- фиктивный элемент одноэлементного множества.

Но pullback'и имеют более общие применения, также в программировании. Например,
рассмотрите классы C++ как категорию, в которой морфизмы ---
стрелки, которые соединяют подклассы с суперклассами. Мы будем рассматривать
наследование как транзитивное свойство, так что если \code{C} наследуется от \code{B}, а \code{B}
наследуется от \code{A}, то мы скажем, что \code{C} наследуется от \code{A} (в конце концов, вы
можете передать указатель на \code{C} там, где ожидается указатель на \code{A}). Также мы
предположим, что \code{C} наследуется от \code{C}, так что у нас есть тождественная стрелка для каждого
класса. Таким образом, подклассирование выравнивается с подтипизацией. C++ также поддерживает
множественное наследование, так что вы можете сконструировать ромбовидную диаграмму наследования
с двумя классами \code{B} и \code{C}, наследующимися от \code{A}, и четвёртым классом \code{D},
множественно наследующимся от \code{B} и \code{C}. Обычно \code{D} получил бы две копии \code{A},
что редко желательно; но вы можете использовать виртуальное наследование, чтобы иметь
только одну копию \code{A} в \code{D}.

Что означало бы иметь \code{D} как pullback в этой диаграмме? Это означало бы,
что любой класс \code{E}, который множественно наследуется от \code{B} и \code{C}, также является
подклассом \code{D}. Это не выразимо напрямую в C++, где подтипизация
номинальная (компилятор C++ не выведет этот вид отношения классов
--- это потребовало бы ``утиной типизации''). Но мы могли бы выйти
за пределы отношения подтипизации и вместо этого спросить, было ли бы приведение
из \code{E} в \code{D} безопасным или нет. Это приведение было бы безопасным, если бы \code{D} была
голой комбинацией \code{B} и \code{C}, без дополнительных данных и без
переопределения методов. И, конечно, не было бы pullback'а, если
есть конфликт имён между некоторыми методами \code{B} и \code{C}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.25\textwidth]{images/classes.jpg}
\end{figure}

\noindent
Есть также более продвинутое использование pullback в выводе типов. Часто
есть нужда \emph{унифицировать} типы двух выражений. Например,
предположим, что компилятор хочет вывести тип функции:

\begin{snip}{haskell}
twice f x = f (f x)
\end{snip}
Он назначит предварительные типы всем переменным и подвыражениям.
В частности, он назначит:

\begin{snip}{haskell}
f       :: t0
x       :: t1
f x     :: t2
f (f x) :: t3
\end{snip}
из чего он выведет, что:

\begin{snip}{haskell}
twice :: t0 -> t1 -> t3
\end{snip}
Он также придёт с набором ограничений, вытекающих из правил
применения функций:

\begin{snip}{haskell}
t0 = t1 -> t2 -- потому что f применяется к x
t0 = t2 -> t3 -- потому что f применяется к (f x)
\end{snip}
Эти ограничения должны быть унифицированы нахождением набора типов (или типовых
переменных), которые, когда подставлены вместо неизвестных типов в обоих
выражениях, производят один и тот же тип. Одна такая подстановка:

\begin{snip}{haskell}
t1 = t2 = t3 = Int
twice :: (Int -> Int) -> Int -> Int
\end{snip}
но, очевидно, это не самая общая. Самая общая
подстановка получается с использованием pullback. Я не буду вдаваться в детали,
потому что они за пределами области этой книги, но вы можете убедить
себя, что результат должен быть:

\begin{snip}{haskell}
twice :: (t -> t) -> t -> t
\end{snip}
с \code{t} как свободной типовой переменной.

\section{Копределы}

Так же, как все конструкции в теории категорий, пределы имеют свой двойственный
образ в противоположных категориях. Когда вы инвертируете направление всех
стрелок в конусе, вы получаете коконус, и универсальный из них
называется копределом. Обратите внимание, что инверсия также влияет на факторизующий
морфизм, который теперь течёт из универсального коконуса в любой другой
коконус.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/colimit.jpg}
  \caption{Коконус с факторизующим морфизмом $h$, соединяющим две вершины.}
\end{figure}

\noindent
Типичный пример копредела --- копроизведение, которое соответствует
диаграмме, порождённой $\cat{2}$, категории, которую мы использовали в
определении произведения.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/coproductranking.jpg}
\end{figure}

\noindent
И произведение, и копроизведение воплощают суть пары
объектов, каждое своим способом.

Так же, как терминальный объект был пределом, так начальный объект ---
копредел, соответствующий диаграмме, основанной на пустой категории.

Двойственное pullback называется \emph{pushout} (прямая протяжка). Оно основано на
диаграмме, называемой промежуток (span), порождённой категорией
$1\leftarrow2\rightarrow3$.

\section{Непрерывность}

Я сказал ранее, что функторы близки к идее непрерывных
отображений категорий в том смысле, что они никогда не разрывают существующие
связи (морфизмы). Фактическое определение \emph{непрерывного
  функтора} $F$ из категории $\cat{C}$ в $\cat{C'}$ включает
требование, что функтор сохраняет пределы. Каждая диаграмма $D$
в $\cat{C}$ может быть отображена в диаграмму $F \circ D$ в $\cat{C'}$
просто композицией двух функторов. Условие непрерывности для $F$
утверждает, что если диаграмма $D$ имеет предел $\Lim[D]$, то
диаграмма $F \circ D$ также имеет предел, и он равен
$F (\Lim[D])$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{images/continuity.jpg}
\end{figure}

\noindent
Обратите внимание, что, поскольку функторы отображают морфизмы в морфизмы, а
композиции в композиции, образ конуса всегда является конусом.
Коммутирующий треугольник всегда отображается в коммутирующий треугольник (функторы
сохраняют композицию). То же верно для факторизующих морфизмов:
образ факторизующего морфизма также является факторизующим морфизмом. Так что
каждый функтор \emph{почти} непрерывен. Что может пойти не так --- это
условие уникальности. Факторизующий морфизм в $\cat{C'}$ может быть не
уникален. Также могут быть другие ``лучшие конусы'' в $\cat{C'}$, которые не были
доступны в $\cat{C}$.

Hom-функтор --- это пример непрерывного функтора. Вспомните, что
hom-функтор, $\cat{C}(a, b)$, контравариантен в первой переменной
и ковариантен во второй. Другими словами, это функтор:
\[\cat{C}^\mathit{op} \times \cat{C} \to \Set\]
Когда его второй аргумент фиксирован, функтор hom-множества (который становится
представимым предпучком) отображает копределы в $\cat{C}$ в пределы в
$\Set$; а когда его первый аргумент фиксирован, он отображает пределы в
пределы.

В Haskell hom-функтор --- это отображение любых двух типов в тип функции,
поэтому это просто параметризованный тип функции. Когда мы фиксируем второй
параметр, скажем, в \code{String}, мы получаем контравариантный
функтор:

\src{snippet17}
Непрерывность означает, что когда \code{ToString} применяется к копределу,
например, копроизведению \code{Either b c}, он произведёт предел;
в этом случае произведение двух типов функций:

\src{snippet18}
Действительно, любая функция из \code{Either b c} реализуется как клауза
case с двумя случаями, обслуживаемыми парой функций.

Аналогично, когда мы фиксируем первый аргумент hom-множества, мы получаем
знакомый функтор reader. Его непрерывность означает, что, например, любая
функция, возвращающая произведение, эквивалентна произведению функций; в
частности:

\src{snippet19}
Я знаю, о чём вы думаете: вам не нужна теория категорий, чтобы выяснить
эти вещи. И вы правы! Тем не менее, я нахожу удивительным, что такие
результаты могут быть выведены из первых принципов без обращения к битам
и байтам, архитектурам процессоров, компиляторным технологиям или даже
лямбда-исчислению.

Если вам любопытно, откуда берутся названия ``предел'' и ``непрерывность'',
они являются обобщением соответствующих понятий из
математического анализа. В математическом анализе пределы и непрерывность определяются в терминах открытых
окрестностей. Открытые множества, которые определяют топологию, образуют категорию (предпорядок).

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Как бы вы описали pushout в категории классов C++?
  \item
        Покажите, что предел тождественного функтора
        $\mathbf{Id} \Colon \cat{C} \to \cat{C}$ --- это начальный объект.
  \item
        Подмножества данного множества образуют категорию. Морфизм в этой категории
        определяется как стрелка, соединяющая два множества, если первое --- подмножество
        второго. Что является pullback'ом двух множеств в такой категории?
        Что является pushout'ом? Каковы начальный и терминальный объекты?
  \item
        Можете ли вы догадаться, что такое coequalizer (коэквалайзер)?
  \item
        Покажите, что в категории с терминальным объектом pullback к
        терминальному объекту --- это произведение.
  \item
        Аналогично, покажите, что pushout из начального объекта (если он существует)
        --- это копроизведение.
\end{enumerate}
