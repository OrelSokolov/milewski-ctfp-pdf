% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{П}{рограммисты разработали} целую мифологию вокруг монад. Считается,
что это одна из самых абстрактных и трудных концепций в
программировании. Есть люди, которые ``понимают это'', и те, кто нет. Для
многих момент, когда они понимают концепцию монады, подобен
мистическому опыту. Монада абстрагирует суть столь многих разнообразных
конструкций, что у нас просто нет хорошей аналогии для неё в
повседневной жизни. Мы сведены к ощупыванию в темноте, как те слепые
люди, трогающие разные части слона и восклицающие
триумфально: ``Это верёвка,'' ``Это ствол дерева,'' или ``Это
буррито!''

Позвольте мне внести ясность: вся мистика вокруг монады ---
результат недопонимания. Монада --- очень простая концепция.
Это разнообразие применений монады вызывает
путаницу.

Как часть исследования для этого поста я посмотрел на клейкую ленту (она же
утиная лента) и её применения. Вот небольшой образец вещей, которые вы
можете с ней делать:

\begin{itemize}
  \tightlist
  \item
        герметизация воздуховодов
  \item
        починка скрубберов CO\textsubscript{2} на борту Аполлона-13
  \item
        лечение бородавок
  \item
        починка проблемы упавших звонков iPhone 4 от Apple
  \item
        изготовление платья для выпускного
  \item
        постройка подвесного моста
\end{itemize}

\noindent
Теперь представьте, что вы не знали, что такое клейкая лента, и пытались
выяснить это на основе этого списка. Удачи!

Так что я хотел бы добавить ещё один пункт к коллекции клише ``монада
похожа на\ldots{}'': монада похожа на клейкую ленту. Её применения
широко разнообразны, но её принцип очень прост: она склеивает вещи
вместе. Более точно, она композирует вещи.

Это частично объясняет трудности, которые имеют многие программисты,
особенно те, кто пришёл из императивного фона, с
пониманием монады. Проблема в том, что мы не привыкли думать
о программировании в терминах композиции функций. Это понятно.
Мы часто даём имена промежуточным значениям, а не передаём их
напрямую от функции к функции. Мы также встраиваем короткие сегменты
клеевого кода, а не абстрагируем их в вспомогательные функции. Вот
реализация функции длины вектора в императивном стиле на C:

\begin{snip}{cpp}
double vlen(double * v) {
    double d = 0.0;
    int n;
    for (n = 0; n < 3; ++n)
        d += v[n] * v[n];
    return sqrt(d);
}
\end{snip}
Сравните это со (стилизованной) версией Haskell, которая делает композицию функций
явной:

\src{snippet01}
(Здесь, чтобы сделать вещи ещё более загадочными, я частично применил
оператор возведения в степень \code{(\^{})} , установив его второй аргумент
в \code{2}.)

Я не утверждаю, что бесточечный стиль Haskell всегда лучше, просто
что композиция функций лежит в основе всего, что мы делаем в
программировании. И даже хотя мы эффективно композируем функции,
Haskell делает всё возможное, чтобы предоставить синтаксис в императивном стиле,
называемый нотацией \code{do}, для монадической композиции. Мы увидим его
использование позже. Но сначала позвольте мне объяснить, почему нам вообще нужна монадическая композиция.

\section{Категория Клейсли}

Мы ранее пришли к
\hyperref[kleisli-categories]{монаде writer},
приукрашивая обычные функции. Конкретное приукрашивание
было сделано спариванием их возвращаемых значений со строками или, более обобщённо,
с элементами моноида. Теперь мы можем распознать, что такое приукрашивание ---
это функтор:

\src{snippet02}
Мы впоследствии нашли способ композиции приукрашенных функций, или
стрелок Клейсли, которые являются функциями формы:

\src{snippet03}
Именно внутри композиции мы реализовали накопление
лога.

Теперь мы готовы к более общему определению категории Клейсли.
Мы начинаем с категории $\cat{C}$ и эндофунктора $m$.
Соответствующая категория Клейсли $\cat{K}$ имеет те же объекты, что и
$\cat{C}$, но её морфизмы различны. Морфизм между двумя
объектами $a$ и $b$ в $\cat{K}$ реализуется как морфизм:
\[a \to m\ b\]
в исходной категории $\cat{C}$. Важно помнить, что
мы рассматриваем стрелку Клейсли в $\cat{K}$ как морфизм между $a$
и $b$, а не между $a$ и $m\ b$.

В нашем примере $m$ был специализирован к \code{Writer w} для
некоторого фиксированного моноида \code{w}.

Стрелки Клейсли образуют категорию, только если мы можем определить правильную композицию
для них. Если есть композиция, которая ассоциативна и имеет
тождественную стрелку для каждого объекта, то функтор $m$ называется
\newterm{монадой}, а результирующая категория называется категорией Клейсли.

В Haskell композиция Клейсли определяется с использованием оператора рыбы
\code{>=>}, а тождественная стрелка --- это
полиморфная функция, называемая \code{return}. Вот определение
монады, используя композицию Клейсли:

\src{snippet04}
Имейте в виду, что есть много эквивалентных способов определения монады,
и что это не основной в экосистеме Haskell. Мне он нравится
за его концептуальную простоту и интуицию, которую он предоставляет, но есть
другие определения, которые более удобны при программировании. Мы
поговорим о них скоро.

В этой формулировке законы монады очень легко выразить. Они не могут быть
принудительно применены в Haskell, но они могут быть использованы для уравнительного рассуждения. Они
просто стандартные законы композиции для категории Клейсли:

\begin{snip}{haskell}
(f >=> g) >=> h = f >=> (g >=> h) -- ассоциативность
return >=> f = f                  -- левая единица
f >=> return = f                  -- правая единица
\end{snip}
Этот вид определения также выражает, чем монада на самом деле является: это способ
композиции приукрашенных функций. Дело не в побочных эффектах или
состоянии. Дело в композиции. Как мы увидим позже, приукрашенные функции
могут быть использованы для выражения разнообразия эффектов или состояния, но не
для этого монада. Монада --- это липкая клейкая лента, которая связывает один
конец приукрашенной функции с другим концом приукрашенной
функции.

Возвращаясь к нашему примеру с \code{Writer}: логирующие функции (стрелки
Клейсли для функтора \code{Writer}) образуют категорию, потому что
\code{Writer} --- монада:

\src{snippet05}
Законы монады для \code{Writer w} удовлетворены, пока удовлетворены законы моноида
для \code{w} (они также не могут быть принудительно применены в Haskell).

Есть полезная стрелка Клейсли, определённая для монады \code{Writer},
называемая \code{tell}. Её единственная цель --- добавить свой аргумент в
лог:

\src{snippet06}
Мы будем использовать её позже как строительный блок для других монадических функций.

\section{Анатомия рыбы}

При реализации оператора рыбы для разных монад вы быстро
осознаёте, что много кода повторяется и может быть легко вынесено за скобки.
Начнём с того, что композиция Клейсли двух функций должна вернуть
функцию, так что её реализация может также начаться с лямбды, принимающей
аргумент типа \code{a}:

\src{snippet07}
Единственное, что мы можем сделать с этим аргументом, --- передать его в \code{f}:

\src{snippet08}
На этом этапе мы должны произвести результат типа \code{m c},
имея в нашем распоряжении объект типа \code{m b} и функцию
\code{g :: b -> m c}. Давайте определим функцию, которая
делает это для нас. Эта функция называется \emph{bind} и обычно записывается в
форме инфиксного оператора:

\src{snippet09}
Для каждой монады вместо определения оператора рыбы мы можем вместо этого
определить bind. На самом деле стандартное определение Haskell для монады использует
bind:

\src{snippet10}
Вот определение bind для монады \code{Writer}:

\src{snippet11}
Оно действительно короче, чем определение оператора рыбы.

Возможно далее препарировать bind, используя факт, что
\code{m} --- функтор. Мы можем использовать \code{fmap}, чтобы применить функцию
\code{a -> m b} к содержимому \code{m a}. Это
превратит \code{a} в \code{m b}. Результат применения
следовательно типа \code{m (m b)}. Это не в точности то, что нам
нужно --- нам нужен результат типа \code{m b} --- но мы близко.
Всё, что нам нужно, --- это функция, которая схлопывает или выравнивает двойное
применение \code{m}. Такая функция называется \code{join}:

\src{snippet12}
Используя \code{join}, мы можем переписать bind как:

\src{snippet13}
Это приводит нас к третьему варианту определения монады:

\src{snippet14}
Здесь мы явно запросили, чтобы \code{m} был \code{Functor}.
Нам не нужно было делать это в предыдущих двух определениях монады.
Это потому, что любой конструктор типа \code{m}, который либо поддерживает
оператор рыбы, либо bind, автоматически является функтором. Например, возможно
определить \code{fmap} в терминах bind и \code{return}:

\src{snippet15}
Для полноты, вот \code{join} для монады \code{Writer}:

\src{snippet16}

\section{Нотация \texttt{do}}

Один способ написания кода с использованием монад --- работать со стрелками Клейсли ---
композируя их с использованием оператора рыбы. Этот режим программирования ---
обобщение бесточечного стиля. Бесточечный код компактен и
часто довольно элегантен. В общем случае, однако, он может быть труден для понимания,
граничащим с загадочностью. Вот почему большинство программистов предпочитают давать имена
аргументам функций и промежуточным значениям.

При работе с монадами это означает предпочтение оператора bind оператору
рыбы. Bind принимает монадическое значение и возвращает монадическое значение.
Программист может выбрать давать имена этим значениям. Но это
вряд ли улучшение. То, что мы действительно хотим, --- притворяться, что мы
имеем дело с обычными значениями, а не с монадическими контейнерами, которые их инкапсулируют.
Так работает императивный код --- побочные эффекты, такие как
обновление глобального лога, в основном скрыты из вида. И это то, что
нотация \code{do} эмулирует в Haskell.

Вы можете задаться вопросом тогда, зачем вообще использовать монады? Если мы хотим сделать
побочные эффекты невидимыми, почему бы не придерживаться императивного языка?
Ответ в том, что монада даёт нам намного лучший контроль над побочными эффектами.
Например, лог в монаде \code{Writer} передаётся из
функции в функцию и никогда не выставляется глобально. Нет
возможности искажения лога или создания гонки данных. Также монадический
код чётко размечен и отгорожен от остальной части
программы.

Нотация \code{do} --- это просто синтаксический сахар для монадической
композиции. На поверхности она выглядит очень похоже на императивный код, но она
переводится напрямую в последовательность bind'ов и лямбда-выражений.

Например, возьмите пример, который мы использовали ранее для иллюстрации
композиции стрелок Клейсли в монаде \code{Writer}. Используя наши
текущие определения, он мог бы быть переписан как:

\src{snippet17}
Эта функция превращает все символы во входной строке в верхний регистр и
разбивает её на слова, всё время производя лог своих действий.

В нотации \code{do} это выглядело бы так:

\src{snippet18}
Здесь \code{upStr} --- это просто \code{String}, хотя
\code{upCase} производит \code{Writer}:

\src{snippet19}
Это потому, что блок \code{do} десахаризуется компилятором в:

\src{snippet20}
Монадический результат \code{upCase} связывается с лямбдой, которая принимает
\code{String}. Именно имя этой строки показывается в
блоке \code{do}. Когда читаем строку:

\src{snippet21}
мы говорим, что \code{upStr} \emph{получает} результат \code{upCase s}.

Псевдо-императивный стиль ещё более выражен, когда мы встраиваем
\code{toWords}. Мы заменяем её вызовом \code{tell}, который
логирует строку \code{"toWords "}, за которым следует вызов
\code{return} с результатом разбиения строки \code{upStr}
с использованием \code{words}. Обратите внимание, что \code{words} --- обычная функция,
работающая на строках.

\src{snippet22}
Здесь каждая строка в блоке do вводит новый вложенный bind в
десахаризованном коде:

\src{snippet23}
Обратите внимание, что \code{tell} производит значение unit, так что его не нужно
передавать в следующую лямбду. Игнорирование содержимого монадического
результата (но не его эффекта --- здесь вклада в лог) ---
довольно обычное дело, так что есть специальный оператор для замены bind в этом
случае:

\src{snippet24}
Фактическая десахаризация нашего кода выглядит так:

\src{snippet25}
В общем случае блоки \code{do} состоят из строк (или подблоков), которые
либо используют левую стрелку для введения новых имён, которые затем доступны
в остальной части кода, либо выполняются чисто для побочных эффектов. Операторы
bind неявны между строками кода. Кстати, возможно
в Haskell заменить форматирование в блоках \code{do}
фигурными скобками и точками с запятой. Это предоставляет обоснование для
описания монады как способа перегрузки точки с запятой.

Обратите внимание, что вложенность лямбд и операторов bind при десахаризации
нотации \code{do} имеет эффект влияния на выполнение
остальной части блока \code{do} на основе результата каждой строки. Это
свойство может быть использовано для введения сложных структур управления, например,
для симуляции исключений.

Интересно, что эквивалент нотации \code{do} нашёл своё
применение в императивных языках, в частности, в C++. Я говорю
о возобновляемых функциях или корутинах. Не секрет, что
\urlref{https://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/}{futures
  в C++ образуют монаду}. Это пример монады продолжения, которую мы
обсудим вскоре. Проблема с продолжениями в том, что их очень
трудно композировать. В Haskell мы используем нотацию \code{do}, чтобы превратить
спагетти из ``мой обработчик вызовет твой обработчик'' во что-то, что
выглядит очень похоже на последовательный код. Возобновляемые функции делают то же
преобразование возможным в C++. И тот же механизм может быть применён, чтобы
превратить
\urlref{https://bartoszmilewski.com/2014/04/21/getting-lazy-with-c/}{спагетти
  из вложенных циклов} в списочные включения или ``генераторы'', которые по существу
являются нотацией \code{do} для монады списка. Без
объединяющей абстракции монады каждая из этих проблем обычно
адресуется предоставлением специальных расширений языку. В Haskell
всё это обрабатывается через библиотеки.
