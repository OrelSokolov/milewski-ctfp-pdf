% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{Д}{о сих пор} я обходил стороной значение типов функций. Тип функции
отличается от других типов.

Возьмите \code{Integer}, например: это просто множество целых чисел.
\code{Bool} --- это двухэлементное множество. Но тип функции
$a\to b$ больше, чем это: это множество морфизмов
между объектами $a$ и $b$. Множество морфизмов между
двумя объектами в любой категории называется hom-множеством. Так случилось, что
в категории $\Set$ каждое hom-множество само является объектом в той же
категории --- потому что это, в конце концов, \emph{множество}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/set-hom-set.jpg}
  \caption{Hom-множество в Set --- это просто множество}
\end{figure}

\noindent
То же самое неверно для других категорий, где hom-множества внешние по отношению к
категории. Они даже называются \emph{внешними} hom-множествами.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/hom-set.jpg}
  \caption{Hom-множество в категории C --- это внешнее множество}
\end{figure}

\noindent
Именно самореферентная природа категории $\Set$ делает
типы функций особенными. Но есть способ, по крайней мере в некоторых категориях,
сконструировать объекты, которые представляют hom-множества. Такие объекты называются
\newterm{внутренними} hom-множествами.

\section{Универсальная конструкция}

Давайте на мгновение забудем, что типы функций --- это множества, и попытаемся
сконструировать тип функции, или, более обобщённо, внутреннее hom-множество, с
нуля. Как обычно, мы возьмём наши подсказки из категории $\Set$,
но тщательно избежим использования любых свойств множеств, так что
конструкция автоматически будет работать для других категорий.

Тип функции может считаться составным типом из-за его
отношения к типу аргумента и типу результата. Мы уже
видели конструкции составных типов --- те, которые включали
отношения между объектами. Мы использовали универсальные конструкции для определения
\hyperref[products-and-coproducts]{произведения
  и копроизведения типов}. Мы можем использовать тот же трюк для определения
типа функции. Нам понадобится паттерн, который включает три объекта:
тип функции, который мы конструируем, тип аргумента и
тип результата.

Очевидный паттерн, который соединяет эти три типа, называется
\newterm{применение функции} или \newterm{вычисление}. Для кандидата на
тип функции, назовём его $z$ (заметьте, что если мы не в
категории $\Set$, это просто объект, как любой другой
объект), и тип аргумента $a$ (объект), применение
отображает эту пару в тип результата $b$ (объект). У нас три
объекта, два из них фиксированы (те, что представляют тип аргумента и
тип результата).

У нас также есть применение, которое является отображением. Как мы встраиваем
это отображение в наш паттерн? Если бы нам разрешили заглянуть внутрь
объектов, мы могли бы спарить функцию $f$ (элемент $z$)
с аргументом $x$ (элементом $a$) и отобразить это в
$f x$ (применение $f$ к $x$, которое является
элементом $b$).

\begin{figure}[H]
  \centering\includegraphics[width=0.35\textwidth]{images/functionset.jpg}
  \caption{В Set мы можем выбрать функцию $f$ из множества функций $z$, и мы можем
    выбрать аргумент $x$ из множества (типа) $a$. Мы получаем элемент $f x$ в
    множестве (типе) $b$.}
\end{figure}

\noindent
Но вместо того, чтобы иметь дело с индивидуальными парами $(f, x)$, мы можем также
говорить о целом \emph{произведении} типа функции $z$
и типа аргумента $a$. Произведение $z\times{}a$ --- это объект,
и мы можем выбрать в качестве нашего морфизма применения стрелку $g$ из
этого объекта в $b$. В $\Set$, $g$ была бы
функцией, которая отображает каждую пару $(f, x)$ в $f x$.

Итак, вот паттерн: произведение двух объектов $z$ и
$a$, соединённое с другим объектом $b$ морфизмом $g$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/functionpattern.jpg}
  \caption{Паттерн объектов и морфизмов, который является отправной точкой
    универсальной конструкции}
\end{figure}

\noindent
Достаточно ли специфичен этот паттерн, чтобы выделить тип функции, используя
универсальную конструкцию? Не в каждой категории. Но в категориях,
представляющих для нас интерес, да. И ещё вопрос: было бы возможно
определить объект-функцию без предварительного определения произведения? Есть
категории, в которых нет произведения, или нет произведения для
всех пар объектов. Ответ --- нет: нет типа функции, если
нет типа произведения. Мы вернёмся к этому позже, когда будем говорить
об экспоненциалах.

Давайте рассмотрим универсальную конструкцию. Мы начинаем с паттерна
объектов и морфизмов. Это наш неточный запрос, и он обычно даёт
много и много совпадений. В частности, в $\Set$ практически
всё соединено со всем. Мы можем взять любой объект
$z$, сформировать его произведение с $a$, и будет существовать
функция из него в $b$ (за исключением случая, когда $b$ --- пустое множество).

Вот когда мы применяем наше секретное оружие: ранжирование. Обычно это делается
требованием, чтобы существовало уникальное отображение между кандидатами объектов ---
отображение, которое как-то факторизует нашу конструкцию. В нашем случае мы
постановим, что $z$ вместе с морфизмом $g$ из
$z \times a$ в $b$ \emph{лучше}, чем какой-то другой
$z'$ с его собственным применением $g'$, если и
только если существует уникальное отображение $h$ из $z'$ в
$z$ такое, что применение $g'$ факторизуется
через применение $g$. (Подсказка: читайте это предложение, глядя
на картинку.)

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/functionranking.jpg}
  \caption{Установление ранжирования между кандидатами для объекта-функции}
\end{figure}

\noindent
Теперь вот сложная часть, и основная причина, по которой я отложил эту
конкретную универсальную конструкцию до сих пор. Для данного морфизма
$h \Colon z'\to z$ мы хотим замкнуть диаграмму,
которая имеет и $z'$, и $z$, скрещённые с $a$.
То, что нам действительно нужно, для данного отображения $h$ из $z'$
в $z$, это отображение из $z' \times a$ в $z \times a$.
И теперь, после обсуждения \hyperref[functoriality]{функториальности
  произведения}, мы знаем, как это сделать. Поскольку произведение само является
функтором (более точно, эндо-би-функтором), возможно поднять пары
морфизмов. Другими словами, мы можем определить не только произведения объектов,
но и произведения морфизмов.

Поскольку мы не трогаем второй компонент произведения
$z' \times a$, мы поднимем пару морфизмов
$(h, \id)$, где $\id$ --- тождество на $a$.

Итак, вот как мы можем факторизовать одно применение, $g$, из другого
применения $g'$:
\[g' = g \circ (h \times \id)\]
Ключ здесь --- действие произведения на морфизмы.

Третья часть универсальной конструкции --- выбор объекта,
который универсально лучший. Давайте назовём этот объект $a \Rightarrow b$ (думайте
об этом как о символическом имени для одного объекта, не путать с
ограничением класса типов Haskell --- я обсужу разные способы его именования
позже). Этот объект идёт со своим собственным применением --- морфизмом
из $(a \Rightarrow b) \times a$ в $b$ --- которое мы назовём
$\mathit{eval}$. Объект \code{$a \Rightarrow b$} лучший, если любой другой
кандидат для объекта-функции может быть уникально отображён в него таким
образом, что его морфизм применения $g$ факторизуется через
$\mathit{eval}$. Этот объект лучше, чем любой другой объект, согласно
нашему ранжированию.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/universalfunctionobject.jpg}
  \caption{Определение универсального объекта-функции. Это та же
    диаграмма, что и выше, но теперь объект $a \Rightarrow b$ \emph{универсален}.}
\end{figure}

\noindent
Формально:

\begin{longtable}[]{@{}l@{}}
  \toprule
  \begin{minipage}[t]{0.97\columnwidth}\raggedright\strut
    \emph{Объект-функция} из $a$ в $b$ --- это объект
    $a \Rightarrow b$ вместе с морфизмом
    \[\mathit{eval} \Colon ((a \Rightarrow b) \times a) \to b\]
    такой, что для любого другого объекта $z$ с морфизмом
    \[g \Colon z \times a \to b\]
    существует уникальный морфизм
    \[h \Colon z \to (a \Rightarrow b)\]
    который факторизует $g$ через $\mathit{eval}$:
    \[g = \mathit{eval} \circ (h \times \id)\]
  \end{minipage}\tabularnewline
  \bottomrule
\end{longtable}

\noindent
Конечно, нет гарантии, что такой объект $a \Rightarrow b$ существует
для любой пары объектов $a$ и $b$ в данной категории.
Но он всегда существует в $\Set$. Более того, в $\Set$ этот
объект изоморфен hom-множеству $\Set(a, b)$.

Вот почему в Haskell мы интерпретируем тип функции
\code{a -> b} как категорный объект-функцию $a \Rightarrow b$.

\section{Каррирование}

Давайте ещё раз взглянем на всех кандидатов для объекта-функции.
На этот раз, однако, давайте думать о морфизме $g$ как о функции
двух переменных, $z$ и $a$.
\[g \Colon z \times a \to b\]
Быть морфизмом из произведения --- это настолько близко, насколько можно подойти к тому, чтобы быть
функцией двух переменных. В частности, в $\Set$, $g$ ---
это функция из пар значений, одно из множества $z$, а другое
из множества $a$.

С другой стороны, универсальное свойство говорит нам, что для каждого такого
$g$ существует уникальный морфизм $h$, который отображает $z$ в
объект-функцию $a \Rightarrow b$.
\[h \Colon z \to (a \Rightarrow b)\]
В $\Set$ это просто означает, что $h$ --- это функция, которая
принимает одну переменную типа $z$ и возвращает функцию из
$a$ в $b$. Это делает $h$ функцией высшего порядка.
Следовательно, универсальная конструкция устанавливает взаимно однозначное
соответствие между функциями двух переменных и функциями одной
переменной, возвращающими функции. Это соответствие называется
\newterm{каррирование}, а $h$ называется каррированной версией $g$.

Это соответствие взаимно однозначное, потому что для любого $g$ существует
уникальный $h$, и для любого $h$ вы всегда можете воссоздать
функцию двух аргументов $g$, используя формулу:
\[g = \mathit{eval} \circ (h \times \id)\]
Функция $g$ может быть названа \emph{раскаррированной} версией $h$.

Каррирование по существу встроено в синтаксис Haskell. Функция,
возвращающая функцию:

\src{snippet01}
часто рассматривается как функция двух переменных. Так мы читаем
нескобочную сигнатуру:

\src{snippet02}
Эта интерпретация очевидна в способе, которым мы определяем функции с несколькими аргументами.
Например:

\src{snippet03}
Та же функция может быть написана как функция одного аргумента, возвращающая
функцию --- лямбду:

\src{snippet04}
Эти два определения эквивалентны, и любое может быть частично
применено к одному аргументу, производя функцию одного аргумента, как в:

\src{snippet05}
Строго говоря, функция двух переменных --- это та, которая принимает пару
(тип произведения):

\src{snippet06}
Тривиально конвертировать между двумя представлениями, и две
(функции высшего порядка), которые делают это, называются, неудивительно,
\code{curry} и \code{uncurry}:

\src{snippet07}
и

\src{snippet08}
Обратите внимание, что \code{curry} --- это \emph{факторизатор} для универсальной
конструкции объекта-функции. Это особенно очевидно, если его
переписать в этой форме:

\src{snippet09}
(Напоминание: факторизатор производит факторизующую функцию из
кандидата.)

В нефункциональных языках, таких как C++, каррирование возможно, но
нетривиально. Вы можете думать о функциях с несколькими аргументами в C++ как о
соответствующих функциям Haskell, принимающим кортежи (хотя, чтобы запутать
вещи ещё больше, в C++ вы можете определить функции, которые принимают явный
\code{std::tuple}, а также вариадические функции и функции, принимающие
списки инициализации).

Вы можете частично применить функцию C++, используя шаблон
\code{std::bind}. Например, для данной функции двух строк:

\begin{snip}{cpp}
std::string catstr(std::string s1, std::string s2) {
    return s1 + s2;
}
\end{snip}
вы можете определить функцию одной строки:

\begin{snip}{cpp}
using namespace std::placeholders;

auto greet = std::bind(catstr, "Hello ", _1);
std::cout << greet("Haskell Curry");
\end{snip}
Scala, которая более функциональна, чем C++ или Java, находится где-то
посередине. Если вы предвидите, что определяемая вами функция будет
частично применена, вы определяете её с несколькими списками аргументов:

\begin{snip}{cpp}
def catstr(s1: String)(s2: String) = s1 + s2
\end{snip}
Конечно, это требует некоторого предвидения или прозорливости со стороны
автора библиотеки.

\section{Экспоненциалы}

В математической литературе объект-функция, или внутренний
hom-объект между двумя объектами $a$ и $b$, часто
называется \newterm{экспоненциалом} и обозначается как $b^{a}$. Обратите внимание, что
тип аргумента в экспоненте. Эта нотация может показаться странной
сначала, но она имеет полный смысл, если вы думаете об отношении
между функциями и произведениями. Мы уже видели, что мы должны использовать
произведение в универсальной конструкции внутреннего hom-объекта,
но связь глубже, чем это.

Это лучше всего видно, когда вы рассматриваете функции между конечными типами ---
типами, которые имеют конечное количество значений, такими как \code{Bool},
\code{Char}, или даже \code{Int} или \code{Double}. Такие функции,
по крайней мере в принципе, могут быть полностью мемоизированы или превращены в структуры данных
для поиска. И это суть эквивалентности
между функциями, которые являются морфизмами, и типами функций, которые являются
объектами.

Например, (чистая) функция из \code{Bool} полностью
определяется парой значений: одно, соответствующее \code{False}, и
одно, соответствующее \code{True}. Множество всех возможных функций
из \code{Bool} в, скажем, \code{Int}, --- это множество всех пар
\code{Int}ов. Это то же самое, что произведение \code{Int} \times{} \code{Int} или,
будучи немного креативным с нотацией, \code{Int}\textsuperscript{2}.

Для другого примера давайте посмотрим на тип C++ \code{char}, который
содержит 256 значений (Haskell \code{Char} больше, потому что Haskell
использует Unicode). Есть несколько функций в части
стандартной библиотеки C++, которые обычно реализуются с использованием поиска.
Функции, такие как \code{isupper} или \code{isspace}, реализуются
с использованием таблиц, которые эквивалентны кортежам из 256 булевых значений.
Кортеж --- это тип произведения, поэтому мы имеем дело с произведениями 256
булевых: \code{bool \times{} bool \times{} bool \times{} ... \times{} bool}. Мы знаем из
арифметики, что итерированное произведение определяет степень. Если вы
``умножите'' \code{bool} на себя 256 (или \code{char}) раз, вы
получите \code{bool} в степени \code{char}, или \code{bool}\textsuperscript{\code{char}}.

Сколько значений в типе, определённом как 256-кортежи
\code{bool}? Точно $2^{256}$. Это также количество
разных функций из \code{char} в \code{bool}, каждая
функция соответствует уникальному 256-кортежу. Вы можете аналогично
вычислить, что количество функций из \code{bool} в
\code{char} --- это $256^{2}$, и так далее. Экспоненциальная
нотация для типов функций имеет полный смысл в этих случаях.

Мы, вероятно, не хотели бы полностью мемоизировать функцию из \code{int}
или \code{double}. Но эквивалентность между функциями и типами
данных, если не всегда практична, существует. Есть также бесконечные типы,
например, списки, строки или деревья. Жадная мемоизация функций
из этих типов потребовала бы бесконечного хранилища. Но Haskell --- это ленивый
язык, поэтому граница между лениво вычисляемыми (бесконечными) структурами
данных и функциями размыта. Эта двойственность функция vs. данные
объясняет идентификацию типа функции Haskell с
категорным объектом-экспоненциалом --- который больше соответствует нашей идее
\emph{данных}.

\section{Декартово замкнутые категории}

Хотя я буду продолжать использовать категорию множеств как модель для типов
и функций, стоит упомянуть, что есть большее семейство
категорий, которые могут быть использованы для этой цели. Эти категории
называются \newterm{декартово замкнутыми}, и $\Set$ --- это только один пример
такой категории.

Декартово замкнутая категория должна содержать:

\begin{enumerate}
  \tightlist
  \item
        Терминальный объект,
  \item
        Произведение любой пары объектов, и
  \item
        Экспоненциал для любой пары объектов.
\end{enumerate}
Если вы рассматриваете экспоненциал как итерированное произведение (возможно,
бесконечно много раз), то вы можете думать о декартово замкнутой
категории как о поддерживающей произведения произвольной арности. В
частности, терминальный объект может рассматриваться как произведение нуля
объектов --- или нулевая степень объекта.

Что интересно в декартово замкнутых категориях с
перспективы компьютерных наук, так это то, что они предоставляют модели для
просто типизированного лямбда-исчисления, которое формирует основу всех типизированных
языков программирования.

Терминальный объект и произведение имеют свои двойственные: начальный объект
и копроизведение. Декартово замкнутая категория, которая также поддерживает эти
два, и в которой произведение может быть распределено над копроизведением
\begin{gather*}
  a \times (b + c) = a \times b + a \times c \\
  (b + c) \times a = b \times a + c \times a
\end{gather*}
называется \newterm{бидекартово замкнутой} категорией. Мы увидим в следующей
секции, что бидекартово замкнутые категории, из которых $\Set$ ---
главный пример, имеют некоторые интересные свойства.

\section{Экспоненциалы и алгебраические типы данных}

Интерпретация типов функций как экспоненциалов очень хорошо вписывается в
схему алгебраических типов данных. Оказывается, что все базовые
тождества из школьной алгебры, связывающие числа ноль и один, суммы,
произведения и экспоненциалы, выполняются практически без изменений в любой бидекартово
замкнутой категории для, соответственно, начального и финального объектов,
копроизведений, произведений и экспоненциалов. У нас ещё нет инструментов, чтобы
доказать их (таких как сопряжения или лемма Ёнеды), но я перечислю их
здесь как источник ценных интуиций.

\subsection{Нулевая степень}

\[a^{0} = 1\]
В категорной интерпретации мы заменяем 0 начальным объектом,
1 финальным объектом, а равенство изоморфизмом. Экспоненциал ---
это внутренний hom-объект. Этот конкретный экспоненциал представляет
множество морфизмов, идущих из начального объекта в произвольный объект
$a$. По определению начального объекта существует точно
один такой морфизм, поэтому hom-множество $\cat{C}(0, a)$ --- это множество-синглетон.
Множество-синглетон --- это терминальный объект в $\Set$, поэтому это тождество
тривиально работает в $\Set$. То, что мы говорим, --- это что оно работает в
любой бидекартово замкнутой категории.

В Haskell мы заменяем 0 на \code{Void}; 1 на тип unit
\code{()}; а экспоненциал на тип функции. Утверждение состоит в том, что
множество функций из \code{Void} в любой тип \code{a}
эквивалентно типу unit --- который является синглетоном. Другими словами,
существует только одна функция \code{Void -> a}. Мы видели
эту функцию раньше: она называется \code{absurd}.

Это немного хитро по двум причинам. Одна в том, что в Haskell у нас
на самом деле нет необитаемых типов --- каждый тип содержит ``результат
бесконечно выполняющегося вычисления'', или дно. Вторая причина в том,
что все реализации \code{absurd} эквивалентны, потому что, не
важно, что они делают, никто никогда не сможет их выполнить. Нет значения,
которое может быть передано в \code{absurd}. (И если вам удастся передать
бесконечно выполняющееся вычисление, оно никогда не вернётся!)

\subsection{Степени единицы}

\[1^{a} = 1\]
Это тождество, когда интерпретируется в $\Set$, пересказывает определение
терминального объекта: существует уникальный морфизм из любого объекта в
терминальный объект. В общем случае, внутренний hom-объект из $a$
в терминальный объект изоморфен самому терминальному объекту.

В Haskell существует только одна функция из любого типа \code{a} в unit.
Мы видели эту функцию раньше --- она называется \code{unit}. Вы можете
также думать о ней как о функции \code{const}, частично применённой к
\code{()}.

\subsection{Первая степень}

\[a^{1} = a\]
Это пересказ наблюдения, что морфизмы из
терминального объекта могут быть использованы для выбора ``элементов'' объекта
\code{a}. Множество таких морфизмов изоморфно самому объекту.
В $\Set$, и в Haskell, изоморфизм между
элементами множества \code{a} и функциями, которые выбирают эти элементы,
\code{() -> a}.

\subsection{Экспоненциалы сумм}

\[a^{b+c} = a^{b} \times a^{c}\]
Категорно это говорит, что экспоненциал из копроизведения двух
объектов изоморфен произведению двух экспоненциалов. В Haskell это
алгебраическое тождество имеет очень практическую интерпретацию. Оно говорит нам,
что функция из суммы двух типов эквивалентна паре
функций из отдельных типов. Это просто анализ случаев, который мы
используем при определении функций на суммах. Вместо написания одного определения функции
с клаузой \code{case}, мы обычно разделяем его на две
(или более) функции, работающие с каждым конструктором типа отдельно. Например,
возьмите функцию из типа-суммы
\code{(Either Int Double)}:

\src{snippet10}
Она может быть определена как пара функций из, соответственно,
\code{Int} и \code{Double}:

\src{snippet11}
Здесь \code{n} --- это \code{Int}, а \code{x} --- это \code{Double}.

\subsection{Экспоненциалы экспоненциалов}

\[(a^{b})^{c} = a^{b \times c}\]
Это просто способ выражения каррирования чисто в терминах экспоненциальных
объектов. Функция, возвращающая функцию, эквивалентна функции
из произведения (функции двух аргументов).

\subsection{Экспоненциалы над произведениями}

\[(a \times b)^{c} = a^{c} \times b^{c}\]
В Haskell: функция, возвращающая пару, эквивалентна паре
функций, каждая из которых производит один элемент пары.

Довольно невероятно, как эти простые школьные алгебраические тождества
могут быть подняты в теорию категорий и иметь практическое применение в
функциональном программировании.

\section{Изоморфизм Карри-Говарда}

Я уже упоминал соответствие между логикой и алгебраическими
типами данных. Тип \code{Void} и тип unit \code{()}
соответствуют ложь и истина. Типы произведения и суммы соответствуют
логической конъюнкции $\wedge$ (И) и дизъюнкции $\vee$ (ИЛИ). В этой схеме
тип функции, который мы только что определили, соответствует логической импликации $\Rightarrow$.
Другими словами, тип \code{a -> b} может быть прочитан как ``если
a, то b.''

Согласно изоморфизму Карри-Говарда, каждый тип может быть интерпретирован
как предложение --- утверждение или суждение, которое может быть истинным или
ложным. Такое предложение считается истинным, если тип обитаем,
и ложным, если нет. В частности, логическая импликация истинна, если
тип функции, соответствующий ей, обитаем, что означает, что
существует функция этого типа. Реализация функции
следовательно является доказательством теоремы. Написание программ эквивалентно
доказательству теорем. Давайте рассмотрим несколько примеров.

Давайте возьмём функцию \code{eval}, которую мы ввели в
определении объекта-функции. Её сигнатура:

\src{snippet12}
Она принимает пару, состоящую из функции и её аргумента, и производит
результат соответствующего типа. Это реализация Haskell
морфизма:

\[\mathit{eval} \Colon (a \Rightarrow b) \times a \to b\]
который определяет тип функции $a \Rightarrow b$ (или экспоненциальный объект
$b^{a}$). Давайте переведём эту сигнатуру в логический предикат,
используя изоморфизм Карри-Говарда:

\[((a \Rightarrow b) \wedge a) \Rightarrow b\]
Вот как вы можете прочитать это утверждение: если истинно, что $b$
следует из $a$, и $a$ истинно, то $b$ должно быть
истинно. Это имеет полный интуитивный смысл и было известно с
древности как \newterm{modus ponens}. Мы можем доказать эту теорему,
реализовав функцию:

\src{snippet13}
Если вы дадите мне пару, состоящую из функции \code{f}, принимающей
\code{a} и возвращающей \code{b}, и конкретное значение \code{x}
типа \code{a}, я могу произвести конкретное значение типа \code{b},
просто применив функцию \code{f} к \code{x}. Реализовав
эту функцию, я только что показал, что тип
\code{((a -> b), a) -> b} обитаем.
Следовательно, \newterm{modus ponens} истинен в нашей логике.

Как насчёт предиката, который явно ложен? Например: если
$a$ или $b$ истинно, то $a$ должно быть истинно.

\[a \vee b \Rightarrow a\]
Это, очевидно, неправильно, потому что вы можете выбрать $a$, которое
ложно, и $b$, которое истинно, и это контрпример.

Отображая этот предикат в сигнатуру функции, используя изоморфизм Карри-Говарда,
мы получаем:

\src{snippet14}
Как бы вы ни старались, вы не можете реализовать эту функцию --- вы не можете произвести
значение типа \code{a}, если вас вызвали со значением \code{Right}.
(Помните, мы говорим о \emph{чистых} функциях.)

Наконец, мы подходим к значению функции \code{absurd}:

\src{snippet15}
Учитывая, что \code{Void} переводится в ложь, мы получаем:

\[\mathit{false} \Rightarrow a\]
Всё следует из лжи (\emph{ex falso quodlibet}). Вот одно
возможное доказательство (реализация) этого утверждения (функции) в Haskell:

\begin{snip}{haskell}
absurd (Void a) = absurd a
\end{snip}
где \code{Void} определён как:

\begin{snip}{haskell}
newtype Void = Void Void
\end{snip}
Как всегда, тип \code{Void} хитрый. Это определение делает
невозможным сконструировать значение, потому что для того, чтобы сконструировать одно, вам
нужно предоставить одно. Следовательно, функция \code{absurd} никогда
не может быть вызвана.

Это все интересные примеры, но есть ли практическая сторона
изоморфизма Карри-Говарда? Вероятно, нет в повседневном программировании. Но
есть языки программирования, такие как Agda или Coq, которые используют
изоморфизм Карри-Говарда для доказательства теорем.

Компьютеры не только помогают математикам делать их работу --- они
революционизируют сами основы математики. Последняя горячая
исследовательская тема в этой области называется гомотопической теорией типов и является
продолжением теории типов. Она полна булевых, целых чисел, произведений и
копроизведений, типов функций и так далее. И, как бы для рассеивания любых сомнений,
теория формулируется в Coq и Agda. Компьютеры
революционизируют мир более чем одним способом.

\section{Библиография}

\begin{enumerate}
  \tightlist
  \item
        Ralf Hinze, Daniel W. H. James,
        \urlref{http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf}{Reason
          Isomorphically!}. Эта статья содержит доказательства всех тех школьных
        алгебраических тождеств в теории категорий, которые я упоминал в этой
        главе.
\end{enumerate}
