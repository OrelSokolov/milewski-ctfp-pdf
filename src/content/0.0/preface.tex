% !TEX root = ../../ctfp-print.tex

\begin{quote}
  Некоторое время я обдумывал идею написать книгу о теории категорий, 
  ориентированную на программистов. Заметьте, не на учёных-компьютерщиков,
  а на программистов --- скорее на инженеров, чем на учёных. Я знаю, что 
  это звучит безумно, и мне должно быть страшно. Я не могу отрицать, что 
  существует огромная пропасть между наукой и инженерией, потому что я 
  работал по обе стороны этого разделения. Но я всегда чувствовал очень 
  сильную потребность объяснять вещи. Я испытываю огромное восхищение 
  Ричардом Фейнманом, который был мастером простых объяснений. Я знаю, 
  что я не Фейнман, но постараюсь сделать всё возможное. Я начинаю с 
  публикации этого предисловия --- которое должно мотивировать читателя 
  изучить теорию категорий --- в надежде начать обсуждение и получить 
  обратную связь.\footnote{
    Вы также можете посмотреть, как я преподаю этот материал живой аудитории, на
    \href{https://goo.gl/GT2UWU}{https://goo.gl/GT2UWU} (или поищите
    ``bartosz milewski category theory'' на YouTube.)}
\end{quote}

\lettrine[lhang=0.17]{Я}{попытаюсь}, в пределах нескольких абзацев,
убедить вас, что эта книга написана для вас, и любые возражения, которые 
могут у вас возникнуть по поводу изучения одной из самых абстрактных 
ветвей математики в ваше «обильное свободное время», совершенно необоснованны.

Мой оптимизм основан на нескольких наблюдениях. Во-первых, теория категорий 
--- это сокровищница чрезвычайно полезных программистских идей. Haskell-программисты 
используют этот ресурс уже давно, и идеи медленно проникают в другие языки, 
но этот процесс идёт слишком медленно. Нам нужно его ускорить.

Во-вторых, существует много разных видов математики, и они привлекают разную 
аудиторию. У вас может быть аллергия на математический анализ или алгебру, 
но это не значит, что вам не понравится теория категорий. Я бы даже сказал, 
что теория категорий --- это тот вид математики, который особенно хорошо 
подходит для умов программистов. Это потому, что теория категорий --- вместо 
того чтобы иметь дело с частностями --- имеет дело со структурой. Она имеет 
дело с тем видом структуры, который делает программы композиционными.

Композиция лежит в самом корне теории категорий --- она является частью 
определения самой категории. И я буду убедительно доказывать, что композиция 
--- это суть программирования. Мы композировали вещи всегда, задолго до того, 
как какому-то великому инженеру пришла в голову идея подпрограммы. Когда-то 
принципы структурного программирования совершили революцию в программировании, 
потому что они сделали блоки кода композиционными. Затем появилось объектно-ориентированное 
программирование, которое всё о композиции объектов. Функциональное программирование 
--- это не только композиция функций и алгебраических типов данных --- оно делает 
параллелизм композиционным --- то, что практически невозможно с другими парадигмами 
программирования.

В-третьих, у меня есть секретное оружие, мясницкий нож, которым я буду резать 
математику, чтобы сделать её более приемлемой для программистов. Когда вы 
профессиональный математик, вы должны быть очень осторожны, чтобы правильно 
сформулировать все свои предположения, правильно квалифицировать каждое 
утверждение и строго построить все свои доказательства. Это делает математические 
статьи и книги чрезвычайно трудными для чтения для постороннего. Я физик по 
образованию, и в физике мы добились удивительных успехов, используя неформальные 
рассуждения. Математики смеялись над дельта-функцией Дирака, которая была 
придумана на месте великим физиком П. А. М. Дираком для решения некоторых 
дифференциальных уравнений. Они перестали смеяться, когда обнаружили совершенно 
новую ветвь математического анализа, называемую теорией обобщённых функций, 
которая формализовала идеи Дирака.

Конечно, используя размахивание руками, вы рискуете сказать что-то явно 
неправильное, поэтому я постараюсь убедиться, что за неформальными аргументами 
в этой книге стоит солидная математическая теория. У меня действительно лежит 
потрёпанный экземпляр книги Сондерса Мак-Лейна \emph{Категории для 
  работающего математика} на моей прикроватной тумбочке.

Поскольку это теория категорий \emph{для программистов}, я буду иллюстрировать 
все основные концепции, используя компьютерный код. Вы, вероятно, знаете, что 
функциональные языки ближе к математике, чем более популярные императивные языки. 
Они также предлагают больше абстрагирующих возможностей. Поэтому естественное 
искушение было бы сказать: вы должны выучить Haskell, прежде чем сокровища теории 
категорий станут доступны вам. Но это означало бы, что теория категорий не имеет 
применения вне функционального программирования, а это просто неправда. Поэтому 
я предоставлю много примеров на C++. Конечно, вам придётся преодолеть некоторый 
уродливый синтаксис, паттерны могут не выделяться на фоне многословия, и вам, 
возможно, придётся сделать немного копипасты вместо более высокой абстракции, 
но такова судьба C++ программиста.

Но вы не избежите Haskell. Вам не нужно становиться Haskell-программистом, 
но он вам нужен как язык для набросков и документирования идей, которые будут 
реализованы на C++. Именно так я начал работать с Haskell. Я обнаружил, что его 
лаконичный синтаксис и мощная система типов очень помогают в понимании и 
реализации шаблонов C++, структур данных и алгоритмов. Но поскольку я не могу 
ожидать, что читатели уже знают Haskell, я буду вводить его постепенно и 
объяснять всё по ходу дела.

Если вы опытный программист, вы можете спросить себя: я так долго писал код, 
не беспокоясь о теории категорий или функциональных методах, так что изменилось? 
Конечно, вы не можете не заметить, что в императивные языки постоянно вторгаются 
новые функциональные возможности. Даже Java, бастион объектно-ориентированного 
программирования, впустила лямбды. C++ недавно эволюционирует с бешеной скоростью 
--- новый стандарт каждые несколько лет --- пытаясь догнать меняющийся мир. Вся 
эта активность является подготовкой к разрушительным изменениям или, как мы, 
физики, называем это, фазовому переходу. Если вы продолжаете нагревать воду, 
она в конечном итоге закипит. Мы сейчас находимся в положении лягушки, которая 
должна решить, продолжать ли ей плавать во всё более горячей воде или начать 
искать альтернативы.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/img_1299.jpg}
\end{figure}

\noindent
Одна из сил, которая движет большими изменениями, --- это многоядерная революция. 
Преобладающая парадигма программирования, объектно-ориентированное программирование, 
ничего не даёт вам в области параллелизма и многопоточности, а вместо этого 
поощряет опасный и багованный дизайн. Сокрытие данных, основная предпосылка 
объектной ориентации, в сочетании с совместным использованием и мутацией, 
становится рецептом для состояний гонки. Идея объединения мьютекса с данными, 
которые он защищает, хороша, но, к сожалению, блокировки не композиционны, 
а сокрытие блокировок делает дедлоки более вероятными и их сложнее отлаживать.

Но даже в отсутствие параллелизма растущая сложность программных систем 
проверяет пределы масштабируемости императивной парадигмы. Проще говоря, 
побочные эффекты выходят из-под контроля. Конечно, функции с побочными эффектами 
часто удобны и просты в написании. Их эффекты в принципе могут быть закодированы 
в их именах и в комментариях. Функция с именем SetPassword или WriteFile явно 
мутирует какое-то состояние и генерирует побочные эффекты, и мы привыкли иметь 
с этим дело. Только когда мы начинаем композировать функции, которые имеют 
побочные эффекты поверх других функций, которые имеют побочные эффекты, и так 
далее, дела начинают идти плохо. Дело не в том, что побочные эффекты по своей 
сути плохи --- это тот факт, что они скрыты от глаз, что делает их невозможными 
для управления в больших масштабах. Побочные эффекты не масштабируются, а 
императивное программирование --- это всё о побочных эффектах.

Изменения в оборудовании и растущая сложность программного обеспечения заставляют 
нас переосмыслить основы программирования. Подобно строителям великих готических 
соборов Европы, мы оттачивали наше мастерство до пределов материала и структуры. 
Есть недостроенный готический \urlref{http://en.wikipedia.org/wiki/Beauvais_Cathedral}{собор 
  в Бове}, Франция, который свидетельствует об этой глубоко человеческой борьбе 
с ограничениями. Он был задуман, чтобы побить все предыдущие рекорды по высоте 
и лёгкости, но пострадал от серии обрушений. Специальные меры, такие как железные 
стержни и деревянные опоры, удерживают его от распада, но очевидно, что многое 
пошло не так. С современной точки зрения, это чудо, что так много готических 
структур были успешно завершены без помощи современного материаловедения, 
компьютерного моделирования, анализа конечных элементов и общей математики и 
физики. Я надеюсь, что будущие поколения будут так же восхищаться навыками 
программирования, которые мы демонстрировали при построении сложных операционных 
систем, веб-серверов и интернет-инфраструктуры. И, честно говоря, они должны, 
потому что мы сделали всё это на основе очень хлипких теоретических оснований. 
Мы должны исправить эти основания, если хотим двигаться вперёд.

\begin{figure}
  \centering
  \includegraphics[totalheight=0.5\textheight]{images/beauvais_interior_supports.jpg}
  \caption{Специальные меры, предотвращающие обрушение собора в Бове.}
\end{figure}
