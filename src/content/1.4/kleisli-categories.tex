% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{В}{ы видели, как моделировать} типы и чистые функции как категорию. Я также
упоминал, что есть способ моделировать побочные эффекты, или нечистые
функции, в теории категорий. Давайте посмотрим на один такой пример:
функции, которые логируют или трассируют своё выполнение. Что-то, что в
императивном языке, вероятно, было бы реализовано мутацией некоторого глобального
состояния, как в:

\begin{snip}{cpp}
string logger;

bool negate(bool b) {
    logger += "Not so! ";
    return !b;
}
\end{snip}
Вы знаете, что это не чистая функция, потому что её мемоизированная версия
не смогла бы произвести лог. Эта функция имеет \newterm{побочные эффекты}.

В современном программировании мы стараемся держаться подальше от глобального изменяемого состояния насколько
возможно --- хотя бы из-за усложнений с
конкурентностью. И вы никогда не поместили бы код вроде этого в библиотеку.

К счастью для нас, можно сделать эту функцию чистой. Вам просто
нужно передавать лог явно, на вход и на выход. Давайте сделаем это, добавив
строковый аргумент и спарив обычный вывод со строкой, которая содержит
обновлённый лог:

\begin{snip}{cpp}
pair<bool, string> negate(bool b, string logger) {
    return make_pair(!b, logger + "Not so! ");
}
\end{snip}
Эта функция чиста, у неё нет побочных эффектов, она возвращает одну и ту же пару
каждый раз, когда вызывается с одними и теми же аргументами, и её можно мемоизировать,
если необходимо. Однако, учитывая кумулятивную природу лога,
вам придётся мемоизировать все возможные истории, которые могут привести к данному
вызову. Будет отдельная запись в мемо для:

\begin{snip}{cpp}
negate(true, "It was the best of times. ");
\end{snip}
и

\begin{snip}{cpp}
negate(true, "It was the worst of times. ");
\end{snip}
и так далее.

Это также не очень хороший интерфейс для библиотечной функции. Вызывающие
свободны игнорировать строку в типе возврата, так что это не огромная
нагрузка; но они вынуждены передавать строку как вход, что может быть
неудобно.

Есть ли способ сделать то же самое менее навязчиво? Есть ли способ
разделить обязанности? В этом простом примере основная цель
функции \code{negate} --- превратить один Boolean в другой.
Логирование вторично. Конечно, сообщение, которое логируется, специфично для
функции, но задача агрегирования сообщений в один
непрерывный лог --- это отдельная обязанность. Мы всё ещё хотим, чтобы функция
производила строку, но мы хотели бы освободить её от производства лога. Итак,
вот компромиссное решение:

\begin{snip}{cpp}
pair<bool, string> negate(bool b) {
    return make_pair(!b, "Not so! ");
}
\end{snip}
Идея в том, что лог будет агрегироваться \emph{между} вызовами
функций.

Чтобы увидеть, как это можно сделать, давайте переключимся на немного более реалистичный
пример. У нас есть одна функция из string в string, которая превращает символы нижнего
регистра в верхний регистр:

\begin{snip}{cpp}
string toUpper(string s) {
    string result;
    int (*toupperp)(int) = &toupper; // toupper перегружен
    transform(begin(s), end(s), back_inserter(result), toupperp);
    return result;
}
\end{snip}
и другая, которая разбивает строку на вектор строк, разбивая её
по границам пробелов:

\begin{snip}{cpp}
vector<string> toWords(string s) {
    return words(s);
}
\end{snip}
Фактическая работа выполняется во вспомогательной функции \code{words}:

\begin{snip}{cpp}
vector<string> words(string s) {
    vector<string> result{""};
    for (auto i = begin(s); i != end(s); ++i)
    {
        if (isspace(*i))
            result.push_back(""); 
        else
            result.back() += *i;
    }
    return result;
}
\end{snip}
Мы хотим модифицировать функции \code{toUpper} и \code{toWords} так,
чтобы они добавляли строку сообщения поверх их обычных возвращаемых
значений.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/piggyback.jpg}
\end{figure}
\noindent
Мы ``приукрасим'' возвращаемые значения этих функций. Давайте сделаем это
обобщённым способом, определив шаблон \code{Writer}, который
инкапсулирует пару, чей первый компонент --- это значение произвольного типа
\code{A}, а второй компонент --- это строка:

\begin{snip}{cpp}
template<class A>
using Writer = pair<A, string>;
\end{snip}
Вот приукрашенные функции:

\begin{snip}{cpp}
Writer<string> toUpper(string s) {
    string result;
    int (*toupperp)(int) = &toupper;
    transform(begin(s), end(s), back_inserter(result), toupperp);
    return make_pair(result, "toUpper "); 
}

Writer<vector<string>> toWords(string s) { 
    return make_pair(words(s), "toWords ");
}
\end{snip}
Мы хотим скомпозировать эти две функции в другую приукрашенную функцию,
которая переводит строку в верхний регистр и разбивает её на слова, при этом
производя лог этих действий. Вот как мы можем это сделать:

\begin{snip}{cpp}
Writer<vector<string>> process(string s) {
    auto p1 = toUpper(s);
    auto p2 = toWords(p1.first);
    return make_pair(p2.first, p1.second + p2.second);
}
\end{snip}
Мы достигли нашей цели: агрегация лога больше не является
обязанностью отдельных функций. Они производят свои собственные
сообщения, которые затем, внешне, конкатенируются в больший лог.

Теперь представьте целую программу, написанную в этом стиле. Это кошмар
повторяющегося, подверженного ошибкам кода. Но мы программисты. Мы знаем, как
справляться с повторяющимся кодом: мы абстрагируем его! Однако это не ваша
обычная абстракция --- мы должны абстрагировать саму \newterm{композицию
  функций}. Но композиция --- это суть теории категорий,
так что прежде чем мы напишем больше кода, давайте проанализируем проблему с
категорной точки зрения.

\section{Категория Writer}

Идея приукрашивания типов возврата кучи функций, чтобы
добавить некоторую дополнительную функциональность, оказывается очень
плодотворной. Мы увидим много больше примеров этого. Отправная точка --- наша
обычная категория типов и функций. Мы оставим типы как
объекты, но переопределим наши морфизмы как приукрашенные функции.

Например, предположим, что мы хотим приукрасить функцию
\code{isEven}, которая идёт из \code{int} в \code{bool}. Мы превращаем её
в морфизм, который представлен приукрашенной функцией. Важный
момент в том, что этот морфизм всё ещё считается стрелкой
между объектами \code{int} и \code{bool}, даже если
приукрашенная функция возвращает пару:

\begin{snip}{cpp}
pair<bool, string> isEven(int n) {
    return make_pair(n % 2 == 0, "isEven ");
}
\end{snip}
По законам категории мы должны быть способны скомпозировать этот морфизм
с другим морфизмом, который идёт из объекта \code{bool} в
что угодно. В частности, мы должны быть способны скомпозировать его с нашим
более ранним \code{negate}:

\begin{snip}{cpp}
pair<bool, string> negate(bool b) {
    return make_pair(!b, "Not so! ");
}
\end{snip}
Очевидно, мы не можем скомпозировать эти два морфизма так же, как мы композируем
обычные функции, из-за несоответствия ввода/вывода. Их
композиция должна выглядеть скорее так:

\begin{snip}{cpp}
pair<bool, string> isOdd(int n) {
    pair<bool, string> p1 = isEven(n);
    pair<bool, string> p2 = negate(p1.first);
    return make_pair(p2.first, p1.second + p2.second);
}
\end{snip}
Итак, вот рецепт композиции двух морфизмов в этой новой
категории, которую мы конструируем:

\begin{enumerate}
  \tightlist
  \item
        Выполните приукрашенную функцию, соответствующую первому морфизму
  \item
        Извлеките первый компонент пары результата и передайте его в
        приукрашенную функцию, соответствующую второму морфизму
  \item
        Конкатенируйте второй компонент (строку) первого результата
        и второй компонент (строку) второго результата
  \item
        Верните новую пару, объединяющую первый компонент финального результата
        с конкатенированной строкой.
\end{enumerate}

Если мы хотим абстрагировать эту композицию как функцию высшего порядка в
C++, мы должны использовать шаблон, параметризованный тремя типами,
соответствующими трём объектам в нашей категории. Он должен принимать две
приукрашенные функции, которые композиционны согласно нашим правилам, и
возвращать третью приукрашенную функцию:

\begin{snip}{cpp}
template<class A, class B, class C>
function<Writer<C>(A)> compose(function<Writer<B>(A)> m1,
                               function<Writer<C>(B)> m2)
{
    return [m1, m2](A x) {
        auto p1 = m1(x);
        auto p2 = m2(p1.first);
        return make_pair(p2.first, p1.second + p2.second); 
    };
}
\end{snip}
Теперь мы можем вернуться к нашему более раннему примеру и реализовать композицию
\code{toUpper} и \code{toWords}, используя этот новый шаблон:

\begin{snip}{cpp}
Writer<vector<string>> process(string s) {
    return compose<string, string, vector<string>>(
        toUpper, toWords)(s);
}
\end{snip}
Всё ещё много шума с передачей типов в
шаблон \code{compose}. Этого можно избежать, если у вас есть
компилятор, совместимый с C++14, который поддерживает обобщённые лямбда-функции с
выводом типа возврата (благодарность за этот код Eric Niebler):

\begin{snip}{cpp}
auto const compose = [](auto m1, auto m2) { 
    return [m1, m2](auto x) { 
        auto p1 = m1(x);
        auto p2 = m2(p1.first);
        return make_pair(p2.first, p1.second + p2.second);
    };
};
\end{snip}
В этом новом определении реализация \code{process}
упрощается до:

\begin{snip}{cpp}
Writer<vector<string>> process(string s) {
    return compose(toUpper, toWords)(s);
}
\end{snip}
Но мы ещё не закончили. Мы определили композицию в нашей новой
категории, но каковы тождественные морфизмы? Это не наши обычные
тождественные функции! Они должны быть морфизмами из типа A обратно в тип
A, что означает, что они являются приукрашенными функциями вида:

\begin{snip}{cpp}
Writer<A> identity(A);
\end{snip}
Они должны вести себя как единицы относительно композиции. Если вы посмотрите
на наше определение композиции, вы увидите, что тождественный морфизм
должен передавать свой аргумент без изменений и только добавлять пустую
строку в лог:

\begin{snip}{cpp}
template<class A> Writer<A> identity(A x) {
    return make_pair(x, "");
}
\end{snip}
Вы можете легко убедить себя, что категория, которую мы только что определили,
действительно является законной категорией. В частности, наша композиция
тривиально ассоциативна. Если вы проследите, что происходит с первым
компонентом каждой пары, это просто обычная композиция функций, которая
ассоциативна. Вторые компоненты конкатенируются, и
конкатенация также ассоциативна.

Проницательный читатель может заметить, что было бы легко обобщить эту
конструкцию на любой моноид, а не только строковый моноид. Мы бы использовали
\code{mappend} внутри \code{compose} и \code{mempty} внутри
\code{identity} (вместо \code{+} и \code{""}). Действительно
нет причин ограничивать себя логированием только строк. Хороший писатель библиотек
должен быть способен идентифицировать минимум ограничений, которые
делают библиотеку работоспособной --- здесь единственное требование библиотеки логирования ---
чтобы лог имел моноидальные свойства.

\section{Writer в Haskell}

То же самое в Haskell немного более лаконично, и мы также получаем
намного больше помощи от компилятора. Давайте начнём с определения типа \code{Writer}:

\src{snippet01}
Здесь я просто определяю псевдоним типа, эквивалент \code{typedef}
(или \code{using}) в C++. Тип \code{Writer} параметризован
типовой переменной \code{a} и эквивалентен паре \code{a} и
\code{String}. Синтаксис для пар минимален: просто два элемента в
скобках, разделённые запятой.

Наши морфизмы --- это функции из произвольного типа в некоторый
тип \code{Writer}:

\src{snippet02}
Мы объявим композицию как забавный инфиксный оператор, иногда
называемый ``рыбой'':

\src{snippet03}
Это функция двух аргументов, каждый из которых является функцией сам по себе, и
возвращающая функцию. Первый аргумент имеет тип
\code{(a -> Writer b)}, второй ---
\code{(b -> Writer c)}, а результат ---
\code{(a -> Writer c)}.

Вот определение этого инфиксного оператора --- два аргумента
\code{m1} и \code{m2} появляются по обе стороны от символа
рыбы:

\src{snippet04}
Результат --- это лямбда-функция одного аргумента \code{x}. Лямбда
записывается как обратная косая черта --- думайте о ней как о греческой букве $\lambda$ с
ампутированной ногой.

Выражение \code{let} позволяет объявлять вспомогательные переменные. Здесь
результат вызова \code{m1} сопоставляется с образцом пары
переменных \code{(y, s1)}; а результат вызова \code{m2}
с аргументом \code{y} из первого образца сопоставляется с
\code{(z, s2)}.

В Haskell обычно сопоставлять пары с образцами, а не использовать
аксессоры, как мы делали в C++. Кроме этого есть довольно
прямое соответствие между двумя реализациями.

Общее значение выражения \code{let} указывается в его
клаузе \code{in}: здесь это пара, чей первый компонент --- \code{z},
а второй компонент --- конкатенация двух строк,
\code{s1++s2}.

Я также определю тождественный морфизм для нашей категории, но по
причинам, которые станут ясны намного позже, я назову его
\code{return}.

\src{snippet05}
Для полноты давайте посмотрим на Haskell-версии приукрашенных
функций \code{upCase} и \code{toWords}:

\src{snippet06}
Функция \code{map} соответствует C++ \code{transform}. Она
применяет символьную функцию \code{toUpper} к строке
\code{s}. Вспомогательная функция \code{words} определена в
стандартной библиотеке Prelude.

Наконец, композиция двух функций выполняется с
помощью оператора рыбы:

\src{snippet07}

\section{Категории Клейсли}

Вы могли догадаться, что я не изобрёл эту категорию на
месте. Это пример так называемой категории Клейсли --- категории,
основанной на монаде. Мы не готовы обсуждать монады ещё, но я хотел
дать вам вкус того, что они могут делать. Для наших ограниченных целей
категория Клейсли имеет в качестве объектов типы лежащего в основе
языка программирования. Морфизмы из типа $A$ в тип $B$ --- это функции, которые
идут из $A$ в тип, произведённый из $B$ с использованием конкретного приукрашивания.
Каждая категория Клейсли определяет свой собственный способ композиции таких морфизмов,
а также тождественные морфизмы относительно этой композиции.
(Позже мы увидим, что неточный термин ``приукрашивание'' соответствует
понятию эндофунктора в категории.)

Конкретная монада, которую я использовал как основу категории в этой
главе, называется \newterm{монада writer}, и она используется для логирования или
трассировки выполнения функций. Это также пример более
общего механизма для встраивания эффектов в чистые вычисления. Вы
видели ранее, что мы можем моделировать типы языков программирования и
функции в категории множеств (игнорируя дно, как обычно). Здесь
мы расширили эту модель на немного другую категорию, категорию,
где морфизмы представлены приукрашенными функциями, и их
композиция делает больше, чем просто передаёт вывод одной функции на
вход другой. У нас есть ещё одна степень свободы для игры:
сама композиция. Оказывается, что это именно та степень
свободы, которая делает возможным дать простую денотационную семантику
программам, которые в императивных языках традиционно реализуются
с использованием побочных эффектов.

\section{Задача}

Функция, которая не определена для всех возможных значений своего аргумента,
называется частичной функцией. Это не совсем функция в
математическом смысле, так что она не подходит под стандартную категорную форму. Однако
она может быть представлена функцией, которая возвращает приукрашенный
тип \code{optional}:

\begin{snip}{cpp}
template<class A> class optional {
    bool _isValid;
    A _value;
public: 
    optional()    : _isValid(false) {}
    optional(A v) : _isValid(true), _value(v) {}
    bool isValid() const { return _isValid; }
    A value() const { return _value; }
};
\end{snip}
Например, вот реализация приукрашенной функции
\code{safe\_root}:

\begin{snip}{cpp}
optional<double> safe_root(double x) {
    if (x >= 0) return optional<double>{sqrt(x)}; 
    else return optional<double>{};
}
\end{snip}
Вот задача:

\begin{enumerate}
  \tightlist
  \item
        Постройте категорию Клейсли для частичных функций (определите
        композицию и тождество).
  \item
        Реализуйте приукрашенную функцию \code{safe\_reciprocal}, которая
        возвращает корректный обратный элемент своего аргумента, если он отличается от
        нуля.
  \item
        Скомпозируйте функции \code{safe\_root} и \code{safe\_reciprocal}, чтобы реализовать
        \code{safe\_root\_reciprocal}, которая вычисляет \code{sqrt(1/x)}
        когда это возможно.
\end{enumerate}
