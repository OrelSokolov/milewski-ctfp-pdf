% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{М}{оноиды --- важная} концепция как в теории категорий,
так и в программировании. Категории соответствуют сильно типизированным языкам,
моноиды --- нетипизированным языкам. Это потому, что в моноиде вы можете композировать любые
две стрелки, так же, как в нетипизированном языке вы можете композировать любые две функции
(конечно, вы можете получить ошибку времени выполнения, когда выполняете вашу
программу).

Мы видели, что моноид может быть описан как категория с единственным
объектом, где вся логика закодирована в правилах композиции морфизмов.
Эта категорная модель полностью эквивалентна более традиционному
теоретико-множественному определению моноида, где мы ``умножаем'' два
элемента множества, чтобы получить третий элемент. Этот процесс
``умножения'' может быть далее препарирован на сначала формирование пары
элементов, а затем идентификацию этой пары с существующим элементом ---
их ``произведением.''

Что происходит, когда мы отказываемся от второй части умножения ---
идентификации пар с существующими элементами? Мы можем, например,
начать с произвольного множества, сформировать все возможные пары элементов и
назвать их новыми элементами. Затем мы спарим эти новые элементы со всеми
возможными элементами, и так далее. Это цепная реакция --- мы будем продолжать
добавлять новые элементы вечно. Результат, бесконечное множество, будет
\emph{почти} моноидом. Но моноиду также нужен единичный элемент и
закон ассоциативности. Нет проблем, мы можем добавить специальный единичный элемент и
идентифицировать некоторые из пар --- ровно столько, чтобы поддержать единицу и
ассоциативность.

Давайте посмотрим, как это работает в простом примере. Давайте начнём с множества из
двух элементов, $\{a, b\}$. Мы назовём их генераторами
свободного моноида. Сначала мы добавим специальный элемент $e$, который будет служить
единицей. Затем мы добавим все пары элементов и назовём их
``произведениями''. Произведение $a$ и $b$ будет парой
$(a, b)$. Произведение $b$ и $a$ будет парой
$(b, a)$, произведение $a$ с $a$ будет
$(a, a)$, произведение $b$ с $b$ будет
$(b, b)$. Мы также можем формировать пары с $e$, как
$(a, e)$, $(e, b)$ и т.д., но мы идентифицируем их с
$a$, $b$ и т.д. Так что в этом раунде мы только добавим
$(a, a)$, $(a, b)$ и $(b, a)$ и
$(b, b)$, и закончим с множеством
$\{e, a, b, (a, a), (a, b), (b, a), (b, b)\}$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/bunnies.jpg}
\end{figure}

\noindent
В следующем раунде мы продолжим добавлять элементы типа:
$(a, (a, b))$, $((a, b), a)$ и т.д. На этом этапе мы
должны убедиться, что ассоциативность выполняется, поэтому мы идентифицируем
$(a, (b, a))$ с $((a, b), a)$ и т.д. Другими словами,
нам не понадобятся внутренние скобки.

Вы можете догадаться, каков будет финальный результат этого процесса: мы
создадим все возможные списки из $a$ и $b$. На самом деле, если мы
представим $e$ как пустой список, мы можем увидеть, что наше
``умножение'' --- это не что иное, как конкатенация списков.

Этот вид конструкции, в которой вы продолжаете генерировать все возможные
комбинации элементов и выполняете минимальное количество
идентификаций --- ровно столько, чтобы поддержать законы --- называется свободной
конструкцией. То, что мы только что сделали, --- это сконструировать \newterm{свободный
  моноид} из множества генераторов $\{a, b\}$.

\section{Свободный моноид в Haskell}

Двухэлементное множество в Haskell эквивалентно типу \code{Bool},
и свободный моноид, порождённый этим множеством, эквивалентен типу
\code{{[}Bool{]}} (список \code{Bool}). (Я намеренно игнорирую
проблемы с бесконечными списками.)

Моноид в Haskell определяется классом типов:

\src{snippet01}
Это просто говорит, что каждый \code{Monoid} должен иметь нейтральный элемент,
который называется \code{mempty}, и бинарную функцию (умножение),
называемую \code{mappend}. Законы единицы и ассоциативности не могут быть
выражены в Haskell и должны быть проверены программистом каждый раз, когда
моноид инстанцируется.

Факт, что список любого типа образует моноид, описывается этим
определением экземпляра:

\src{snippet02}
Оно утверждает, что пустой список \code{{[}{]}} --- это единичный элемент, а
конкатенация списков \code{(++)} --- это бинарная операция.

Как мы видели, список типа \code{a} соответствует свободному моноиду
с множеством \code{a}, служащим как генераторы. Множество натуральных
чисел с умножением --- это не свободный моноид, потому что мы идентифицируем
множество произведений. Сравните, например:

\src{snippet03}
Это было просто, но вопрос в том, можем ли мы выполнить эту свободную
конструкцию в теории категорий, где нам не разрешено заглядывать внутрь
объектов? Мы будем использовать нашу рабочую лошадку: универсальную конструкцию.

Второй интересный вопрос: может ли любой моноид быть получен из какого-то
свободного моноида идентификацией более чем минимального количества элементов,
требуемого законами? Я покажу вам, что это следует напрямую из
универсальной конструкции.

\section{Универсальная конструкция свободного моноида}

Если вы вспомните наш предыдущий опыт с универсальными конструкциями, вы
можете заметить, что речь не столько о конструировании чего-то, сколько о
выборе объекта, который лучше всего подходит данному паттерну. Так что если мы хотим использовать
универсальную конструкцию для ``конструирования'' свободного моноида, мы должны
рассмотреть целую кучу моноидов, из которых выбрать один. Нам нужна
целая категория моноидов для выбора. Но образуют ли моноиды категорию?

Давайте сначала посмотрим на моноиды как множества, оснащённые дополнительной структурой,
определённой единицей и умножением. Мы выберем в качестве морфизмов те
функции, которые сохраняют моноидальную структуру. Такие
структуро-сохраняющие функции называются \newterm{гомоморфизмами}. Гомоморфизм моноидов
должен отображать произведение двух элементов в произведение
отображений двух элементов:

\src{snippet04}
и он должен отображать единицу в единицу.

Например, рассмотрите гомоморфизм из списков целых чисел в
целые числа. Если мы отображаем \code{{[}2{]}} в 2, а \code{{[}3{]}} в 3, мы
должны отобразить \code{{[}2, 3{]}} в 6, потому что конкатенация

\src{snippet05}
становится умножением

\src{snippet06}
Теперь давайте забудем о внутренней структуре индивидуальных моноидов и
только посмотрим на них как на объекты с соответствующими морфизмами. Вы получите
категорию $\cat{Mon}$ моноидов.

Хорошо, может быть, прежде чем мы забудем о внутренней структуре, давайте заметим
важное свойство. Каждый объект $\cat{Mon}$ может быть тривиально отображён
в множество. Это просто множество его элементов. Это множество называется
\newterm{лежащим в основе} множеством. На самом деле, не только мы можем отображать объекты
$\cat{Mon}$ в множества, но мы также можем отображать морфизмы $\cat{Mon}$
(гомоморфизмы) в функции. Опять, это кажется вроде тривиальным, но
станет полезным скоро. Это отображение объектов и морфизмов из
$\cat{Mon}$ в $\Set$ --- на самом деле функтор. Поскольку этот функтор
``забывает'' моноидальную структуру --- как только мы внутри простого множества,
мы больше не различаем единичный элемент и не заботимся об умножении
--- он называется \newterm{забывающим функтором}. Забывающие функторы появляются
регулярно в теории категорий.

Теперь у нас есть два разных взгляда на $\cat{Mon}$. Мы можем рассматривать его просто
как любую другую категорию с объектами и морфизмами. В этом взгляде мы
не видим внутренней структуры моноидов. Всё, что мы можем сказать о
конкретном объекте в $\cat{Mon}$, --- это что он соединяется с собой и с
другими объектами через морфизмы. Таблица ``умножения''
морфизмов --- правила композиции --- выводятся из другого взгляда:
моноиды-как-множества. Переходя к теории категорий, мы не потеряли этот взгляд
полностью --- мы всё ещё можем получить к нему доступ через наш забывающий функтор.

Чтобы применить универсальную конструкцию, нам нужно определить специальное
свойство, которое позволило бы нам искать через категорию моноидов и
выбрать лучшего кандидата для свободного моноида. Но свободный моноид определяется
его генераторами. Разные выборы генераторов производят разные
свободные моноиды (список \code{Bool} --- это не то же самое, что список
\code{Int}). Наша конструкция должна начаться с множества генераторов. Так что
мы вернулись к множествам!

Вот где забывающий функтор вступает в игру. Мы можем использовать его для
рентгеновского просвечивания наших моноидов. Мы можем идентифицировать генераторы на рентгеновских изображениях
этих капель. Вот как это работает:

Мы начинаем с множества генераторов, $x$. Это множество в
$\Set$.

Паттерн, который мы собираемся совместить, состоит из моноида $m$ ---
объекта $\cat{Mon}$ --- и функции $p$ в $\Set$:

\src{snippet07}
где $U$ --- наш забывающий функтор из $\cat{Mon}$ в
$\Set$. Это странный гетерогенный паттерн --- половина в
$\cat{Mon}$ и половина в $\Set$.

Идея в том, что функция $p$ идентифицирует множество
генераторов внутри рентгеновского изображения $m$. Не важно, что
функции могут быть плохи в идентификации точек внутри множеств (они могут
их схлопывать). Всё будет отсортировано универсальной конструкцией,
которая выберет лучшего представителя этого паттерна.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoid-pattern.jpg}
\end{figure}

\noindent
Мы также должны определить ранжирование среди кандидатов. Предположим, у нас есть
другой кандидат: моноид $n$ и функция, которая идентифицирует
генераторы в его рентгеновском изображении:

\src{snippet08}
Мы скажем, что $m$ лучше, чем $n$, если существует
морфизм моноидов (это структуро-сохраняющий гомоморфизм):

\src{snippet09}
чей образ под $U$ (помните, $U$ --- функтор, поэтому он
отображает морфизмы в функции) факторизуется через $p$:

\src{snippet10}
Если вы думаете о $p$ как о выборе генераторов в $m$;
и $q$ как о выборе ``тех же'' генераторов в $n$; тогда
вы можете думать о $h$ как об отображении этих генераторов между двумя
моноидами. Помните, что $h$, по определению, сохраняет моноидальную
структуру. Это означает, что произведение двух генераторов в одном моноиде будет
отображено в произведение соответствующих двух генераторов во втором
моноиде, и так далее.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoid-ranking.jpg}
\end{figure}

\noindent
Это ранжирование может быть использовано для нахождения лучшего кандидата --- свободного моноида.
Вот определение:

\begin{quote}
  Мы скажем, что $m$ (вместе с функцией $p$) ---
  \textbf{свободный моноид} с генераторами $x$ тогда и только тогда, когда существует
  \emph{уникальный} морфизм $h$ из $m$ в любой другой
  моноид $n$ (вместе с функцией $q$), который удовлетворяет
  вышеуказанному свойству факторизации.
\end{quote}
Кстати, это отвечает на наш второй вопрос. Функция
$U h$ --- та, которая имеет силу схлопнуть несколько
элементов $U m$ в единственный элемент $U n$. Это
схлопывание соответствует идентификации некоторых элементов свободного моноида.
Следовательно, любой моноид с генераторами $x$ может быть получен из
свободного моноида, основанного на $x$, идентификацией некоторых элементов.
Свободный моноид --- тот, где только минимум идентификаций
был сделан.

Мы вернёмся к свободным моноидам, когда будем говорить о сопряжениях.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Вы можете подумать (как и я, изначально), что требование, чтобы
        гомоморфизм моноидов сохранял единицу, избыточно. В конце концов, мы
        знаем, что для всех $a$

        \begin{snip}{text}
h a * h e = h (a * e) = h a
\end{snip}
        Так что $h e$ действует как правая единица (и, по аналогии, как левая
        единица). Проблема в том, что $h a$, для всех $a$, может
        только покрывать подмоноид целевого моноида. Может быть ``истинная''
        единица вне образа $h$. Покажите, что изоморфизм
        между моноидами, который сохраняет умножение, должен автоматически
        сохранять единицу.
  \item
        Рассмотрите гомоморфизм моноидов из списков целых чисел с
        конкатенацией в целые числа с умножением. Каков образ
        пустого списка \code{{[}{]}}? Предположите, что все одноэлементные списки
        отображаются в целые числа, которые они содержат, то есть \code{{[}3{]}}
        отображается в 3 и т.д. Каков образ \code{{[}1, 2, 3, 4{]}}?
        Сколько разных списков отображаются в целое число 12? Есть ли какой-либо другой
        гомоморфизм между двумя моноидами?
  \item
        Что такое свободный моноид, порождённый одноэлементным множеством? Можете ли вы увидеть,
        чему он изоморфен?
\end{enumerate}
