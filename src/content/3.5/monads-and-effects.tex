% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{Т}{еперь, когда мы знаем}, для чего нужна монада --- она позволяет нам композировать
приукрашенные функции --- действительно интересный вопрос, почему
приукрашенные функции так важны в функциональном программировании. Мы уже
видели один пример, монаду \code{Writer}, где приукрашивание
позволило нам создавать и накапливать лог через множественные вызовы функций.
Проблема, которая иначе была бы решена с использованием нечистых функций (например,
доступом и модификацией некоторого глобального состояния), была решена чистыми
функциями.

\section{Проблема}

Вот короткий список похожих проблем, скопированный из
знаменитой статьи Эудженио Могги,\footnote{Eugenio Moggi:
  \href{https://doi.org/10.1016/0890-5401(91)90052-4}{
    Notions of Computation and Monads}. Inf. Comput. 93(1): 55-92 (1991).}
все из которых традиционно решаются отказом от чистоты функций.

\begin{itemize}
  \tightlist
  \item
        Частичность: вычисления, которые могут не завершиться
  \item
        Недетерминизм: вычисления, которые могут вернуть много результатов
  \item
        Побочные эффекты: вычисления, которые получают доступ/модифицируют состояние

        \begin{itemize}
          \tightlist
          \item
                Состояние только для чтения, или окружение
          \item
                Состояние только для записи, или лог
          \item
                Состояние для чтения/записи
        \end{itemize}
  \item
        Исключения: частичные функции, которые могут не сработать
  \item
        Продолжения: способность сохранить состояние программы и затем восстановить
        его по требованию
  \item
        Интерактивный ввод
  \item
        Интерактивный вывод
\end{itemize}

Что действительно поражает воображение, так это то, что все эти проблемы могут быть решены
используя один и тот же умный трюк: обращение к приукрашенным функциям.
Конечно, приукрашивание будет полностью различным в каждом случае.

Вы должны понять, что на этом этапе нет требования, чтобы
приукрашивание было монадическим. Только когда мы настаиваем на композиции
--- возможности разложить одну приукрашенную функцию на меньшие
приукрашенные функции --- нам нужна монада. Опять, поскольку каждое из
приукрашиваний различно, монадическая композиция будет реализована
по-разному, но общий паттерн тот же. Это очень простой
паттерн: композиция, которая ассоциативна и оснащена тождеством.

Следующая секция тяжела на примерах Haskell. Не стесняйтесь бегло просмотреть или даже
пропустить её, если вы жаждете вернуться к теории категорий или если вы
уже знакомы с реализацией монад в Haskell.

\section{Решение}

Сначала давайте проанализируем способ, которым мы использовали монаду \code{Writer}. Мы
начали с чистой функции, которая выполняла определённую задачу --- для данных
аргументов она производила определённый вывод. Мы заменили эту функцию
другой функцией, которая приукрасила исходный вывод, спарив его со
строкой. Это было наше решение проблемы логирования.

Мы не могли остановиться там, потому что в общем случае мы не хотим иметь дело с
монолитными решениями. Нам нужно было иметь возможность разложить одну
лог-производящую функцию на меньшие лог-производящие функции. Именно
композиция этих меньших функций привела нас к концепции
монады.

Что действительно удивительно, так это то, что тот же паттерн приукрашивания
типов возврата функций работает для большого разнообразия проблем, которые
обычно потребовали бы отказа от чистоты. Давайте пройдём по нашему списку и
идентифицируем приукрашивание, которое применяется к каждой проблеме по очереди.

\subsection{Частичность}

Мы модифицируем тип возврата каждой функции, которая может не завершиться,
превращая его в ``поднятый'' тип --- тип, который содержит все значения
исходного типа плюс специальное ``дно'' значение $\bot$. Например,
тип \code{Bool}, как множество, содержал бы два элемента:
\code{True} и \code{False}. Поднятый \code{Bool} содержит
три элемента. Функции, которые возвращают поднятый \code{Bool}, могут
произвести \code{True} или \code{False}, или выполняться вечно.

Забавная вещь в том, что в ленивом языке типа Haskell бесконечная
функция может фактически вернуть значение, и это значение может быть передано
следующей функции. Мы называем это специальное значение дном. Пока
это значение явно не нужно (например, для сопоставления с образцом
или производства как вывод), оно может быть передано без
останова выполнения программы. Поскольку каждая функция Haskell
может быть потенциально незавершающейся, все типы в Haskell предполагаются
поднятыми. Вот почему мы часто говорим о категории $\Hask$
Haskell (поднятых) типов и функций, а не о более простой
$\Set$. Не ясно, однако, что $\Hask$ --- настоящая
категория (см. этот
\urlref{http://math.andrej.com/2016/08/06/hask-is-not-a-category/}{пост Андрея
  Бауэра}).

\subsection{Недетерминизм}

Если функция может вернуть много разных результатов, она может также вернуть
их все сразу. Семантически недетерминированная функция
эквивалентна функции, которая возвращает список результатов. Это имеет много
смысла в ленивом языке со сборкой мусора. Например, если всё,
что вам нужно, --- одно значение, вы можете просто взять голову списка, а
хвост никогда не будет вычислен. Если вам нужно случайное значение, используйте генератор
случайных чисел, чтобы выбрать n-й элемент списка. Ленивость даже
позволяет вам вернуть бесконечный список результатов.

В монаде списка --- реализации Haskell недетерминированных
вычислений --- \code{join} реализован как \code{concat}.
Помните, что \code{join} должен выровнять контейнер
контейнеров --- \code{concat} конкатенирует список списков в
единственный список. \code{return} создаёт одноэлементный список:

\src{snippet01}
Оператор bind для монады списка задаётся общей формулой:
\code{fmap}, за которым следует \code{join}, что в этом случае даёт:

\src{snippet02}
Здесь функция \code{k}, которая сама производит список, применяется
к каждому элементу списка \code{as}. Результат --- список списков,
который выравнивается с использованием \code{concat}.

С точки зрения программиста работа со списком легче, чем, например,
вызов недетерминированной функции в цикле или
реализация функции, которая возвращает итератор (хотя
\urlref{http://ericniebler.com/2014/04/27/range-comprehensions/}{в современном
  C++} возврат ленивого диапазона был бы почти эквивалентен возврату
списка в Haskell).

Хороший пример творческого использования недетерминизма --- в игровом
программировании. Например, когда компьютер играет в шахматы против человека,
он не может предсказать следующий ход противника. Однако он может сгенерировать
список всех возможных ходов и проанализировать их один за другим. Аналогично
недетерминированный парсер может сгенерировать список всех возможных разборов для
данного выражения.

Даже если мы можем интерпретировать функции, возвращающие списки, как
недетерминированные, применения монады списка намного шире.
Это потому, что сшивание вместе вычислений, которые производят списки, ---
идеальная функциональная замена для итеративных конструкций --- циклов ---
которые используются в императивном программировании. Единственный цикл часто может быть
переписан с использованием \code{fmap}, который применяет тело цикла к каждому
элементу списка. Нотация \code{do} в монаде списка может быть
использована для замены сложных вложенных циклов.

Мой любимый пример --- программа, которая генерирует пифагоровы тройки
--- тройки положительных целых чисел, которые могут образовать стороны прямоугольных треугольников.

\src{snippet03}
Первая строка говорит нам, что \code{z} получает элемент из бесконечного
списка положительных чисел \code{{[}1..{]}}. Затем \code{x} получает
элемент из (конечного) списка \code{{[}1..z{]}} чисел между 1
и \code{z}. Наконец, \code{y} получает элемент из списка
чисел между \code{x} и \code{z}. У нас есть три числа
$1 \leqslant x \leqslant y \leqslant z$ в нашем
распоряжении. Функция \code{guard} принимает выражение \code{Bool}
и возвращает список юнитов:

\src{snippet04}
Эта функция (которая является членом большего класса, называемого
\code{MonadPlus}) используется здесь для фильтрации не-пифагоровых троек.
Действительно, если вы посмотрите на реализацию bind (или связанный
оператор \code{>>}), вы заметите, что
когда дан пустой список, он производит пустой список. С другой стороны,
когда дан непустой список (здесь одноэлементный список, содержащий юнит
\code{{[}(){]}}), bind вызовет продолжение, здесь
\code{return (x, y, z)}, которое производит одноэлементный список с
проверенной пифагоровой тройкой. Все эти одноэлементные списки будут
конкатенированы охватывающими bind'ами, чтобы произвести финальный (бесконечный)
результат. Конечно, вызывающий \code{triples} никогда не сможет
потребить весь список, но это не важно, потому что Haskell
ленив.

Проблема, которая обычно потребовала бы набор из трёх вложенных циклов, была
драматически упрощена с помощью монады списка и
нотации \code{do}. Как будто этого было недостаточно, Haskell позволяет вам
упростить этот код ещё дальше, используя списочное включение:

\src{snippet05}
Это просто дальнейший синтаксический сахар для монады списка (строго
говоря, \code{MonadPlus}).

Вы можете увидеть похожие конструкции в других функциональных или императивных
языках под видом генераторов и корутин.

\subsection{Состояние только для чтения}

Функция, которая имеет доступ только для чтения к некоторому внешнему состоянию, или
окружению, всегда может быть заменена функцией, которая принимает это
окружение как дополнительный аргумент. Чистая функция
\code{(a, e) -> b} (где \code{e} --- тип
окружения) не выглядит, на первый взгляд, как стрелка Клейсли. Но
как только мы каррируем её в
\code{a -> (e -> b)}, мы узнаём
приукрашивание как наш старый друг, функтор reader:

\src{snippet06}
Вы можете интерпретировать функцию, возвращающую \code{Reader}, как производящую
мини-исполняемый файл: действие, которое для данного окружения производит
желаемый результат. Есть вспомогательная функция \code{runReader} для выполнения
такого действия:

\src{snippet07}
Оно может произвести разные результаты для разных значений
окружения.

Обратите внимание, что и функция, возвращающая \code{Reader}, и
само действие \code{Reader} чисты.

Чтобы реализовать bind для монады \code{Reader}, сначала заметьте, что вы
должны произвести функцию, которая принимает окружение \code{e} и
производит \code{b}:

\src{snippet08}
Внутри лямбды мы можем выполнить действие \code{ra}, чтобы произвести
\code{a}:

\src{snippet09}
Затем мы можем передать \code{a} в продолжение \code{k}, чтобы получить новое
действие \code{rb}:

\src{snippet10}
Наконец, мы можем запустить действие \code{rb} с окружением
\code{e}:

\src{snippet11}
Чтобы реализовать \code{return}, мы создаём действие, которое игнорирует
окружение и возвращает неизменённое значение.

Собирая всё вместе, после нескольких упрощений, мы получаем
следующее определение:

\src{snippet12}

\subsection{Состояние только для записи}

Это просто наш начальный пример с логированием. Приукрашивание задаётся
функтором \code{Writer}:

\src{snippet13}
Для полноты есть также тривиальный помощник \code{runWriter}, который
распаковывает конструктор данных:

\src{snippet14}
Как мы видели раньше, чтобы сделать \code{Writer} композируемым,
\code{w} должен быть моноидом. Вот экземпляр монады для
\code{Writer}, записанный в терминах оператора bind:

\src{snippet15}

\subsection{Состояние}

Функции, которые имеют доступ для чтения/записи к состоянию, комбинируют
приукрашивания \code{Reader} и \code{Writer}. Вы можете
думать о них как о чистых функциях, которые принимают состояние как дополнительный аргумент
и производят пару значение/состояние как результат:
\code{(a, s) -> (b, s)}. После каррирования мы получаем их
в форме стрелок Клейсли
\code{a -> (s -> (b, s))}, с
приукрашиванием, абстрагированным в функтор \code{State}:

\src{snippet16}
Опять, мы можем смотреть на стрелку Клейсли как на возвращающую действие, которое может
быть выполнено с использованием вспомогательной функции:

\src{snippet17}
Разные начальные состояния могут произвести не только разные результаты, но
также и разные финальные состояния.

Реализация bind для монады \code{State} очень похожа
на таковую для монады \code{Reader}, за исключением того, что нужно позаботиться
о передаче правильного состояния на каждом шаге:

\src{snippet18}
Вот полный экземпляр:

\src{snippet19}
Есть также две вспомогательные стрелки Клейсли, которые могут быть использованы для манипуляции
состоянием. Одна из них извлекает состояние для инспекции:

\src{snippet20}
а другая заменяет его полностью новым состоянием:

\src{snippet21}

\subsection{Исключения}

Императивная функция, которая бросает исключение, --- на самом деле частичная
функция --- это функция, которая не определена для некоторых значений своих
аргументов. Простейшая реализация исключений в терминах чистых
тотальных функций использует функтор \code{Maybe}. Частичная функция
расширяется до тотальной функции, которая возвращает \code{Just a}, когда это
имеет смысл, и \code{Nothing}, когда нет. Если мы хотим также
вернуть некоторую информацию о причине неудачи, мы можем использовать
функтор \code{Either} вместо этого (с первым типом, фиксированным, например,
в \code{String}).

Вот экземпляр \code{Monad} для \code{Maybe}:

\src{snippet22}
Обратите внимание, что монадическая композиция для \code{Maybe} правильно
короткозамыкает вычисление (продолжение \code{k} никогда не
вызывается), когда обнаружена ошибка. Это поведение, которое мы ожидаем от
исключений.

\subsection{Продолжения}

Это ситуация ``Не звоните нам, мы вам позвоним!'', которую вы можете испытать
после собеседования на работу. Вместо получения прямого ответа вы
должны предоставить обработчик, функцию, которая будет вызвана с результатом.
Этот стиль программирования особенно полезен, когда результат не
известен в момент вызова, потому что, например, он
вычисляется другим потоком или доставляется с удалённого веб-сайта.
Стрелка Клейсли в этом случае возвращает функцию, которая принимает обработчик,
который представляет ``остаток вычисления'':

\src{snippet23}
Обработчик \code{a -> r}, когда он в конце концов вызван,
производит результат типа \code{r}, и этот результат возвращается в
конце. Продолжение параметризовано типом результата. (На
практике это часто какой-то индикатор статуса.)

Есть также вспомогательная функция для выполнения действия, возвращённого
стрелкой Клейсли. Она принимает обработчик и передаёт его в продолжение:

\src{snippet24}
Композиция продолжений печально известна своей сложностью, так что её
обработка через монаду и, в частности, нотацию \code{do}
имеет крайнее преимущество.

Давайте выясним реализацию bind. Сначала давайте посмотрим на
урезанную сигнатуру:

\src{snippet25}
Наша цель --- создать функцию, которая принимает обработчик
\code{(b -> r)} и производит результат \code{r}. Так что
это наша отправная точка:

\src{snippet26}
Внутри лямбды мы хотим вызвать функцию \code{ka} с подходящим
обработчиком, который представляет остаток вычисления. Мы
реализуем этот обработчик как лямбду:

\src{snippet27}
В этом случае остаток вычисления включает сначала вызов
\code{kab} с \code{a}, а затем передачу \code{hb} в
результирующее действие \code{kb}:

\src{snippet28}
Как вы можете видеть, продолжения композируются изнутри наружу. Финальный обработчик
\code{hb} вызывается из самого внутреннего слоя вычисления.
Вот полный экземпляр:

\src{snippet29}

\subsection{Интерактивный ввод}

Это самая хитрая проблема и источник большой путаницы.
Ясно, что функция типа \code{getChar}, если бы она возвращала
символ, набранный на клавиатуре, не могла бы быть чистой. Но что, если она
возвращала бы символ внутри контейнера? Пока не было бы способа
извлечь символ из этого контейнера, мы могли бы утверждать, что
функция чиста. Каждый раз, когда вы вызываете \code{getChar}, она возвращала бы
в точности тот же контейнер. Концептуально этот контейнер содержал бы
суперпозицию всех возможных символов.

Если вы знакомы с квантовой механикой, у вас не должно быть проблем
с пониманием этой аналогии. Это как коробка с
котом Шрёдингера внутри --- за исключением того, что нет способа открыть или заглянуть
внутрь коробки. Коробка определяется с использованием специального встроенного
функтора \code{IO}. В нашем примере \code{getChar} может быть объявлен
как стрелка Клейсли:

\src{snippet30}
(На самом деле, поскольку функция из типа unit эквивалентна выбору
значения типа возврата, объявление \code{getChar}
упрощается до \code{getChar :: IO Char}.)

Будучи функтором, \code{IO} позволяет вам манипулировать его содержимым, используя
\code{fmap}. И как функтор, он может хранить содержимое любого типа,
а не только символа. Реальная полезность этого подхода становится очевидной,
когда вы рассматриваете, что в Haskell \code{IO} --- монада. Это означает,
что вы способны композировать стрелки Клейсли, которые производят объекты \code{IO}.

Вы могли бы подумать, что композиция Клейсли позволила бы вам заглянуть в
содержимое объекта \code{IO} (таким образом ``схлопывая волновую
функцию'', если бы мы продолжили квантовую аналогию). Действительно, вы
могли бы скомпозировать \code{getChar} с другой стрелкой Клейсли, которая принимает
символ и, скажем, конвертирует его в целое число. Подвох в том, что эта
вторая стрелка Клейсли могла бы только вернуть это целое число как
\code{(IO\ Int)}. Опять вы закончите с суперпозицией всех
возможных целых чисел. И так далее. Кот Шрёдингера никогда не выходит из
мешка. Как только вы внутри монады \code{IO}, нет выхода из
неё. Нет эквивалента \code{runState} или \code{runReader}
для монады \code{IO}. Нет \code{runIO}!

Так что вы можете сделать с результатом стрелки Клейсли, объектом \code{IO},
кроме композиции его с другой стрелкой Клейсли? Ну, вы можете
вернуть его из \code{main}. В Haskell \code{main} имеет
сигнатуру:

\src{snippet31}
и вы вольны думать об этом как о стрелке Клейсли:

\src{snippet32}
С этой перспективы программа Haskell --- это просто одна большая стрелка Клейсли
в монаде \code{IO}. Вы можете скомпозировать её из меньших стрелок Клейсли,
используя монадическую композицию. Дело системы времени выполнения --- сделать что-то
с результирующим объектом \code{IO} (также называемым действием \code{IO}).

Обратите внимание, что сама стрелка --- чистая функция --- это чистые функции
полностью вниз. Грязная работа делегирована системе. Когда она
наконец выполняет действие \code{IO}, возвращённое из \code{main}, она
делает все виды гадких вещей типа чтения пользовательского ввода, модификации файлов,
печати неприятных сообщений, форматирования диска и так далее. Программа Haskell
никогда не пачкает свои руки (ну, за исключением случаев, когда она вызывает
\code{unsafePerformIO}, но это другая история).

Конечно, поскольку Haskell ленив, \code{main} возвращается почти
немедленно, и грязная работа начинается сразу. Именно во время
выполнения действия \code{IO} результаты чистых
вычислений запрашиваются и вычисляются по требованию. Так что, в реальности,
выполнение программы --- это чередование чистого (Haskell) и грязного
(системного) кода.

Есть альтернативная интерпретация монады \code{IO}, которая
даже более причудлива, но имеет полный смысл как математическая модель. Она
рассматривает всю Вселенную как объект в программе. Обратите внимание, что
концептуально императивная модель рассматривает Вселенную как внешний
глобальный объект, так что процедуры, которые выполняют I/O, имеют побочные эффекты в силу
взаимодействия с этим объектом. Они могут и читать, и модифицировать
состояние Вселенной.

Мы уже знаем, как иметь дело с состоянием в функциональном программировании --- мы
используем монаду состояния. В отличие от простого состояния, однако, состояние
Вселенной не может быть легко описано с использованием стандартных структур данных. Но
мы не должны, пока мы никогда не взаимодействуем с ним напрямую. Достаточно,
что мы предполагаем, что существует тип \code{RealWorld}, и
каким-то чудом космической инженерии среда выполнения способна предоставить
объект этого типа. Действие \code{IO} --- это просто функция:

\src{snippet33}
Или в терминах монады \code{State}:

\src{snippet34}
Однако \code{>=>} и \code{return} для
монады \code{IO} должны быть встроены в язык.

\subsection{Интерактивный вывод}

Та же монада \code{IO} используется для инкапсуляции интерактивного вывода.
\code{RealWorld} должен содержать все выходные устройства. Вы можете
задаться вопросом, почему мы не можем просто вызывать выходные функции из Haskell и притворяться,
что они ничего не делают. Например, почему у нас есть:

\src{snippet35}
а не более простое:

\src{snippet36}
Две причины: Haskell ленив, так что он никогда не вызвал бы функцию, чей
вывод --- здесь объект unit --- не используется ни для чего. И даже
если бы он не был ленив, он всё ещё мог бы свободно изменять порядок таких вызовов
и таким образом искажать вывод. Единственный способ принудительно выполнить последовательное выполнение
двух функций в Haskell --- через зависимость данных. Ввод одной
функции должен зависеть от вывода другой. Передача \code{RealWorld}
между действиями \code{IO} принуждает к последовательности.

Концептуально, в этой программе:

\src{snippet37}
действие, которое печатает ``World!'', получает как ввод Вселенную, в
которой ``Hello '' уже на экране. Оно выводит новую Вселенную
с ``Hello World!'' на экране.

\section{Заключение}

Конечно, я только поцарапал поверхность монадического программирования.
Монады не только выполняют чистыми функциями то, что обычно делается
с побочными эффектами в императивном программировании, но они также делают это с
высокой степенью контроля и безопасности типов. Однако они не без недостатков.
Главная жалоба на монады в том, что они не легко
композируются друг с другом. Конечно, вы можете комбинировать большинство базовых
монад, используя библиотеку трансформеров монад. Относительно легко
создать стек монад, который комбинирует, скажем, состояние с исключениями, но
нет формулы для стыковки произвольных монад вместе.
