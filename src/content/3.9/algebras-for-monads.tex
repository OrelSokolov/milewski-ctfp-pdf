% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{Е}{сли мы интерпретируем} эндофункторы как способы определения выражений, алгебры
позволяют нам вычислять их, а монады позволяют нам формировать и манипулировать ими.
Комбинируя алгебры с монадами, мы не только получаем много функциональности,
но также можем ответить на несколько интересных вопросов.

Один такой вопрос касается отношения между монадами и сопряжениями.
Как мы видели, каждое сопряжение \hyperref[monads-categorically]{определяет
  монаду} (и комонаду). Вопрос в том: может ли каждая монада (комонада) быть
выведена из сопряжения? Ответ положительный. Существует целое
семейство сопряжений, которые генерируют данную монаду. Я покажу вам два
таких сопряжения.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.25\textwidth]{images/pigalg.png}
\end{figure}

\noindent
Давайте пересмотрим определения. Монада --- эндофунктор $m$,
оснащённый двумя естественными преобразованиями, которые удовлетворяют некоторым условиям
когерентности. Компоненты этих преобразований в $a$:
\begin{align*}
  \eta_a & \Colon a \to m\ a         \\
  \mu_a  & \Colon m\ (m\ a) \to m\ a
\end{align*}
Алгебра для того же эндофунктора --- выбор конкретного
объекта --- носителя $a$ --- вместе с морфизмом:
\[\mathit{alg} \Colon m\ a \to a\]
Первая вещь, которую нужно заметить, --- что алгебра идёт в противоположном
направлении к $\eta_a$. Интуиция в том, что $\eta_a$ создаёт
тривиальное выражение из значения типа $a$. Первое условие когерентности,
которое делает алгебру совместимой с монадой, гарантирует, что
вычисление этого выражения, используя алгебру, чей носитель --- $a$,
даёт нам обратно исходное значение:
\[\mathit{alg} \circ \eta_a = \id_a\]
Второе условие возникает из факта, что есть два способа
вычисления дважды вложенного выражения $m\ (m\ a)$. Мы можем сначала
применить $\mu_a$, чтобы выровнять выражение, а затем использовать вычислитель
алгебры; или мы можем применить поднятый вычислитель, чтобы вычислить
внутренние выражения, а затем применить вычислитель к результату. Мы хотели бы,
чтобы две стратегии были эквивалентны:
\[\mathit{alg} \circ \mu_a = \mathit{alg} \circ m\ \mathit{alg}\]
Здесь $m\ \mathit{alg}$ --- морфизм, результирующий из подъёма
$\mathit{alg}$, используя функтор $m$. Следующие коммутирующие
диаграммы описывают два условия (я заменил $m$ на
$T$ в ожидании того, что следует):

\begin{figure}[H]
  \centering
  \begin{subfigure}
    \centering
    \begin{tikzcd}[column sep=large, row sep=large]
      a \arrow[rd, equal] \arrow[r, "\eta_a"]
      & Ta \arrow[d, "\mathit{alg}"] \\
      & a
    \end{tikzcd}
  \end{subfigure}
  \hspace{1cm}
  \begin{subfigure}
    \centering
    \begin{tikzcd}[column sep=large, row sep=large]
      T(Ta) \arrow[r, "T\ \mathit{alg}"] \arrow[d, "\mu_a"]
      & Ta \arrow[d, "\mathit{alg}"] \\
      Ta \arrow[r, "\mathit{alg}"]
      & a
    \end{tikzcd}
  \end{subfigure}
\end{figure}

\noindent
Мы также можем выразить эти условия в Haskell:

\src{snippet01}
Давайте посмотрим на небольшой пример. Алгебра для эндофунктора списка
состоит из некоторого типа \code{a} и функции, которая производит
\code{a} из списка \code{a}. Мы можем выразить эту функцию, используя
\code{foldr}, выбирая как тип элемента, так и тип аккумулятора
равными \code{a}:

\src{snippet02}
Эта конкретная алгебра специфицируется функцией с двумя аргументами, давайте
назовём её \code{f}, и значением \code{z}. Функтор списка случается
также быть монадой, с \code{return}, превращающим значение в одноэлементный
список. Композиция алгебры, здесь \code{foldr f z}, после
\code{return} принимает \code{x} в:

\src{snippet03}
где действие \code{f} записано в инфиксной нотации.
Алгебра совместима с монадой, если следующее условие
когерентности удовлетворено для каждого \code{x}:

\src{snippet04}
Если мы смотрим на \code{f} как на бинарный оператор, это условие говорит нам,
что \code{z} --- правая единица.

Второе условие когерентности действует на список списков. Действие
\code{join} конкатенирует индивидуальные списки. Затем мы можем свернуть
результирующий список. С другой стороны, мы можем сначала свернуть индивидуальные
списки, а затем свернуть результирующий список. Опять, если мы интерпретируем
\code{f} как бинарный оператор, это условие говорит нам, что эта
бинарная операция ассоциативна. Эти условия определённо
выполнены, когда \code{(a, f, z)} --- моноид.

\section{$T$-алгебры}

Поскольку математики предпочитают называть свои монады $T$, они называют
алгебры, совместимые с ними, $T$-алгебрами. $T$-алгебры для данной монады $T$
в категории $\cat{C}$ образуют категорию, называемую категорией Эйленберга-Мура,
часто обозначаемую $\cat{C}^T$. Морфизмы в этой
категории --- гомоморфизмы алгебр. Это те же гомоморфизмы,
которые мы видели определёнными для $F$-алгебр.

$T$-алгебра --- пара, состоящая из объекта-носителя и вычислителя,
$(a, f)$. Есть очевидный забывающий функтор $U^T$ из
$\cat{C}^T$ в $\cat{C}$, который отображает $(a, f)$ в $a$. Он
также отображает гомоморфизм $T$-алгебр в соответствующий морфизм
между объектами-носителями в $\cat{C}$. Вы можете вспомнить из нашего обсуждения
сопряжений, что левый сопряжённый к забывающему функтору называется
свободным функтором.

Левый сопряжённый к $U^T$ называется $F^T$. Он отображает объект
$a$ в $\cat{C}$ в свободную алгебру в $\cat{C}^T$. Носитель
этой свободной алгебры --- $T a$. Её вычислитель --- морфизм из
$T (T a)$ обратно в $T a$. Поскольку $T$ --- монада,
мы можем использовать монадическое $\mu_a$ (\code{join} в Haskell) как
вычислитель.

Мы всё ещё должны показать, что это $T$-алгебра. Для этого два условия
когерентности должны быть удовлетворены:
\begin{align*}
  \mathit{alg} & \circ \eta_{Ta} = \id_{Ta}     \\
  \mathit{alg} & \circ \mu_a = \mathit{alg} \circ T\ \mathit{alg}
\end{align*}
Но это просто монадические законы, если вы подставите $\mu$ для
алгебры.

Как вы можете вспомнить, каждое сопряжение определяет монаду. Оказывается, что
сопряжение между $F^T$ и $U^T$
определяет именно ту монаду $T$, которая была использована в конструкции
категории Эйленберга-Мура. Поскольку мы можем выполнить эту конструкцию для
каждой монады, мы заключаем, что каждая монада может быть сгенерирована из
сопряжения. Позже я покажу вам, что есть другое сопряжение, которое
генерирует ту же монаду.

Вот план: сначала я покажу вам, что $F^T$ действительно левый
сопряжённый $U^T$. Я сделаю это, определив единицу и коединицу
этого сопряжения и доказав, что соответствующие треугольные
тождества удовлетворены. Затем я покажу вам, что монада, порождённая
этим сопряжением, действительно наша исходная монада.

Единица сопряжения --- естественное преобразование:
\[\eta \Colon I \to U^T \circ F^T\]
Давайте вычислим компоненту $a$ этого преобразования.
Тождественный функтор даёт нам $a$. Свободный функтор производит свободную
алгебру $(T a, \mu_a)$, а забывающий функтор редуцирует её к
$T a$. Всего мы получаем отображение из $a$ в
$T a$. Мы просто используем единицу монады $T$ как
единицу этого сопряжения.

Давайте посмотрим на коединицу:
\[\varepsilon \Colon F^T \circ U^T \to I\]
Давайте вычислим её компоненту в некоторой $T$-алгебре $(a, f)$.
Забывающий функтор забывает $f$, а свободный функтор производит
пару $(T a, \mu_a)$. Так что чтобы определить компоненту
коединицы $\varepsilon$ в $(a, f)$, нам нужен правильный морфизм в
категории Эйленберга-Мура, или гомоморфизм $T$-алгебр:
\[(T a, \mu_a) \to (a, f)\]
Такой гомоморфизм должен отображать носитель $T a$ в $a$.
Давайте просто воскресим забытый вычислитель $f$. На этот раз мы
используем его как гомоморфизм $T$-алгебр. Действительно, та же коммутирующая
диаграмма, которая делает $f$ $T$-алгеброй, может быть переинтерпретирована, чтобы показать,
что это гомоморфизм $T$-алгебр:

\begin{figure}[H]
  \centering
  \begin{tikzcd}[column sep=large, row sep=large]
    T(Ta) \arrow[r, "T f"] \arrow[d, "\mu_a"]
    & Ta \arrow[d, "f"] \\
    Ta \arrow[r, "f"]
    & a
  \end{tikzcd}
\end{figure}

\noindent
Таким образом, мы определили компоненту естественного преобразования коединицы
$\varepsilon$ в $(a, f)$ (объекте в категории $T$-алгебр)
как $f$.

Чтобы завершить сопряжение, нам также нужно показать, что единица и
коединица удовлетворяют треугольным тождествам. Это:

\begin{figure}[H]
  \centering
  \begin{subfigure}
    \centering
    \begin{tikzcd}[column sep=large, row sep=large]
      Ta \arrow[rd, equal] \arrow[r, "T \eta_a"]
      & T(Ta) \arrow[d, "\mu_a"] \\
      & Ta
    \end{tikzcd}
  \end{subfigure}%
  \hspace{1cm}
  \begin{subfigure}
    \centering
    \begin{tikzcd}[column sep=large, row sep=large]
      a \arrow[rd, equal] \arrow[r, "\eta_a"]
      & Ta \arrow[d, "f"] \\
      & a
    \end{tikzcd}
  \end{subfigure}
\end{figure}

\noindent
Первое выполняется из-за закона единицы для монады $T$.
Второе --- просто закон $T$-алгебры $(a, f)$.

Мы установили, что два функтора образуют сопряжение:
\[F^T \dashv U^T\]
Каждое сопряжение порождает монаду. Круговое путешествие
\[U^T \circ F^T\]
--- эндофунктор в $\cat{C}$, который порождает соответствующую монаду.
Давайте посмотрим, каково его действие на объект $a$. Свободная алгебра,
созданная $F^T$, --- $(T a, \mu_a)$. Забывающий функтор
$U^T$ отбрасывает вычислитель. Так что действительно, у нас есть:
\[U^T \circ F^T = T\]
Как ожидалось, единица сопряжения --- единица монады $T$.

Вы можете вспомнить, что коединица сопряжения производит монадическое
умножение через следующую формулу:
\[\mu = R \circ \varepsilon \circ L\]
Это горизонтальная композиция трёх естественных преобразований, два
из них --- тождественные естественные преобразования, отображающие, соответственно,
$L$ в $L$, а $R$ в $R$. То, что
посередине, коединица, --- естественное преобразование, чья компонента в
алгебре $(a, f)$ --- это $f$.

Давайте вычислим компоненту $\mu_a$. Мы сначала горизонтально композируем
$\varepsilon$ после $F^T$, что приводит к компоненте
$\varepsilon$ в $F^T a$. Поскольку $F^T$ принимает $a$ в
алгебру $(T a, \mu_a)$, а $\varepsilon$ выбирает вычислитель, мы заканчиваем
с $\mu_a$. Горизонтальная композиция слева с $U^T$
ничего не меняет, поскольку действие $U^T$ на морфизмы
тривиально. Так что действительно, $\mu$, полученная из сопряжения, --- та же
самая, что и $\mu$ исходной монады $T$.

\section{Категория Клейсли}

Мы видели категорию Клейсли раньше. Это категория, сконструированная из
другой категории $\cat{C}$ и монады $T$. Мы назовём эту
категорию $\cat{C}_T$. Объекты в категории Клейсли
$\cat{C}_T$ --- объекты $\cat{C}$, но морфизмы
различны. Морфизм $f_{\cat{K}}$ из $a$ в $b$ в
категории Клейсли соответствует морфизму $f$ из
$a$ в $T b$ в исходной категории. Мы называем этот
морфизм стрелкой Клейсли из $a$ в $b$.

Композиция морфизмов в категории Клейсли определяется в терминах
монадической композиции стрелок Клейсли. Например, давайте скомпозируем
$g_{\cat{K}}$ после $f_{\cat{K}}$. В категории Клейсли у нас есть:
\begin{gather*}
  f_{\cat{K}} \Colon a \to b \\
  g_{\cat{K}} \Colon b \to c
\end{gather*}
что в категории $\cat{C}$ соответствует:
\begin{gather*}
  f \Colon a \to T b \\
  g \Colon b \to T c
\end{gather*}
Мы определяем композицию:
\[h_{\cat{K}} = g_{\cat{K}} \circ f_{\cat{K}}\]
как стрелку Клейсли в $\cat{C}$
\begin{align*}
  h & \Colon a \to T c          \\
  h & = \mu \circ (T g) \circ f
\end{align*}
В Haskell мы бы написали это как:

\src{snippet05}
Есть функтор $F$ из $\cat{C}$ в $\cat{C}_T$,
который действует тривиально на объекты. На морфизмах он отображает $f$ в
$\cat{C}$ в морфизм в $\cat{C}_T$, создавая
стрелку Клейсли, которая приукрашивает возвращаемое значение $f$. Для данного
морфизма:
\[f \Colon a \to b\]
он создаёт морфизм в $\cat{C}_T$ с
соответствующей стрелкой Клейсли:
\[\eta \circ f\]
В Haskell мы бы написали это как:

\src{snippet06}
Мы также можем определить функтор $G$ из $\cat{C}_T$
обратно в $\cat{C}$. Он принимает объект $a$ из категории
Клейсли и отображает его в объект $T a$ в $\cat{C}$. Его действие
на морфизм $f_{\cat{K}}$, соответствующий стрелке Клейсли:
\[f \Colon a \to T b\]
--- это морфизм в $\cat{C}$:
\[T a \to T b\]
заданный сначала подъёмом $f$, а затем применением $\mu$:
\[\mu_{T b} \circ T f\]
В нотации Haskell это читалось бы:

\begin{snipv}
G f\textsubscript{T} = join . fmap f
\end{snipv}
Вы можете узнать это как определение монадического bind в терминах
\code{join}.

Легко увидеть, что два функтора образуют сопряжение:
\[F \dashv G\]
и их композиция $G \circ F$ воспроизводит исходную монаду $T$.

Так что это второе сопряжение, которое производит ту же монаду. На самом деле
есть целая категория сопряжений $\cat{Adj}(\cat{C}, T)$, которые приводят
к той же монаде $T$ на $\cat{C}$. Сопряжение Клейсли, которое мы только что
видели, --- начальный объект в этой категории, а
сопряжение Эйленберга-Мура --- терминальный объект.

\section{Коалгебры для комонад}

Аналогичные конструкции могут быть сделаны для любой
\hyperref[comonads]{комонады}
$W$. Мы можем определить категорию коалгебр, которые совместимы
с комонадой. Они заставляют следующие диаграммы коммутировать:

\begin{figure}[H]
  \centering
  \begin{subfigure}
    \centering
    \begin{tikzcd}[column sep=large, row sep=large]
      a \arrow[rd, equal]
      & Wa \arrow[l, "\varepsilon_a"'] \\
      & a \arrow[u, "\mathit{coa}"']
    \end{tikzcd}
  \end{subfigure}%
  \hspace{1cm}
  \begin{subfigure}
    \centering
    \begin{tikzcd}[column sep=large, row sep=large]
      W(Wa)
      & Wa \arrow[l, "W\ \mathit{coa}"'] \\
      Wa \arrow[u, "\delta_a"]
      & a \arrow[u, "\mathit{coa}"] \arrow[l, "\mathit{coa}"']
    \end{tikzcd}
  \end{subfigure}
\end{figure}

\noindent
где $\mathit{coa}$ --- морфизм ковычисления коалгебры, чей
носитель --- $a$:
\[\mathit{coa} \Colon a \to W a\]
а $\varepsilon$ и $\delta$ --- два естественных преобразования,
определяющие комонаду (в Haskell их компоненты называются
\code{extract} и \code{duplicate}).

Есть очевидный забывающий функтор $U^W$ из категории
этих коалгебр в $\cat{C}$. Он просто забывает ковычисление. Мы
рассмотрим его правый сопряжённый $F^W$.
\[U^W \dashv F^W\]
Правый сопряжённый к забывающему функтору называется косвободным функтором.
$F^W$ генерирует косвободные коалгебры. Он назначает объекту
$a$ в $\cat{C}$ коалгебру $(W a, \delta_a)$.
Сопряжение воспроизводит исходную комонаду как композит
$U^W \circ F^W$.

Аналогично, мы можем сконструировать ко-категорию Клейсли с ко-стрелками Клейсли
и регенерировать комонаду из соответствующего сопряжения.

\section{Линзы}

Давайте вернёмся к нашему обсуждению линз. Линза может быть написана как
коалгебра:
\[\mathit{coalg}_s \Colon a \to \mathit{Store}\ s\ a\]
для функтора $\mathit{Store}\ s$:

\src{snippet07}
Эта коалгебра также может быть выражена как пара функций:
\begin{align*}
  \mathit{set} & \Colon a \to s \to a \\
  \mathit{get} & \Colon a \to s
\end{align*}
(Думайте об $a$ как означающем ``всё'', а $s$ как
``малую'' часть этого.) В терминах этой пары у нас есть:
\[\mathit{coalg}_s\ a = \mathit{Store}\ (\mathit{set}\ a)\ (\mathit{get}\ a)\]
Здесь $a$ --- значение типа $a$. Обратите внимание, что частично
применённый \code{set} --- функция $s \to a$.

Мы также знаем, что $\mathit{Store}\ s$ --- комонада:

\src{snippet08}
Вопрос в том: при каких условиях линза является коалгеброй для этой
комонады? Первое условие когерентности:
\[\varepsilon_a \circ \mathit{coalg} = \idarrow[a]\]
переводится в:

\src{snippet16}
Это закон линзы, который выражает факт, что если вы устанавливаете поле
структуры $a$ в его предыдущее значение, ничего не меняется.
Этот закон также известен как GETPUT.

Второе условие:
\[\mathit{fmap}\ \mathit{coalg} \circ \mathit{coalg} = \delta_a \circ \mathit{coalg}\]
требует немного больше работы. Сначала вспомните определение
\code{fmap} для функтора \code{Store}:

\src{snippet09}
Применение \code{fmap coalg} к результату \code{coalg} даёт нам:

\src{snippet10}
С другой стороны, применение \code{duplicate} к результату
\code{coalg} производит:

\src{snippet11}
Чтобы эти два выражения были равны, две функции под
\code{Store} должны быть равны при действии на произвольное \code{s}:

\src{snippet12}
Раскрывая \code{coalg}, мы получаем:

\src{snippet13}
Это эквивалентно двум оставшимся законам линзы. Первый:

\src{snippet14}
говорит нам, что установка значения поля дважды --- то же самое, что установка
его один раз. Этот закон также известен как PUTPUT. Второй закон:

\src{snippet15}
говорит нам, что получение значения поля, которое было установлено в $s$,
даёт $s$ обратно. Этот закон также известен как PUTGET.

Линза, которая удовлетворяет GETPUT и PUTGET, называется хорошо ведущей себя линзой.
Если линза также удовлетворяет PUTPUT, она называется очень хорошо ведущей себя линзой.
Так что, другими словами, очень хорошо ведущая себя линза действительно коалгебра комонады для
функтора \code{Store}.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Каково действие свободного функтора
        $F^T \Colon C \to C^T$ на морфизмы. Подсказка: используйте
        условие естественности для монадического $\mu$.
  \item
        Определите сопряжение:
        \[U^W \dashv F^W\]
  \item
        Докажите, что вышеуказанное сопряжение воспроизводит исходную комонаду.
\end{enumerate}
