% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{К}{атегория типов и функций} играет важную роль в
программировании, так что давайте поговорим о том, что такое типы и зачем они нам нужны.

\section{Кому нужны типы?}

Кажется, есть некоторые противоречия относительно преимуществ статической vs.
динамической и сильной vs. слабой типизации. Позвольте мне проиллюстрировать эти выборы
мысленным экспериментом. Представьте миллионы обезьян за компьютерными клавиатурами,
счастливо нажимающих случайные клавиши, производящих программы, компилирующих и запускающих
их.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/img_1329.jpg}
\end{figure}

\noindent
На машинном языке любая комбинация байтов, произведённая обезьянами,
будет принята и запущена. Но с языками более высокого уровня мы
ценим тот факт, что компилятор способен обнаруживать лексические и
грамматические ошибки. Много обезьян останутся без бананов, но
оставшиеся программы будут иметь больше шансов быть полезными. Проверка типов
предоставляет ещё один барьер против бессмысленных программ.
Более того, в то время как в динамически типизированном языке несоответствия типов были бы
обнаружены во время выполнения, в сильно типизированных статически проверяемых языках
несоответствия типов обнаруживаются во время компиляции, устраняя множество
неправильных программ до того, как у них появится шанс запуститься.

Итак, вопрос в том, хотим ли мы сделать обезьян счастливыми или хотим
производить корректные программы?

Обычная цель в мысленном эксперименте с печатающими обезьянами --- это
производство полных работ Шекспира. Наличие проверки орфографии
и проверки грамматики в цикле резко увеличило бы шансы.
Аналог проверки типов пошёл бы ещё дальше, убедившись, что,
как только Ромео объявлен человеком, он не отращивает листья или не ловит
фотоны в своём мощном гравитационном поле.

\section{Типы о композиционности}

Теория категорий о композиции стрелок. Но не любые две стрелки могут быть
скомпозированы. Целевой объект одной стрелки должен быть таким же, как исходный
объект следующей стрелки. В программировании мы передаём результаты
одной функции в другую. Программа не будет работать, если целевая
функция не способна правильно интерпретировать данные, произведённые
исходной функцией. Два конца должны подходить для композиции. Чем
сильнее система типов языка, тем лучше это соответствие может быть
описано и механически проверено.

Единственный серьёзный аргумент, который я слышу против сильной статической проверки типов,
заключается в том, что она может устранить некоторые программы, которые семантически корректны. На
практике это происходит крайне редко и, в любом случае, каждый язык
предоставляет какую-то лазейку для обхода системы типов, когда это
действительно необходимо. Даже в Haskell есть \code{unsafeCoerce}. Но такие
устройства должны использоваться осмотрительно. Персонаж Франца Кафки, Грегор
Замза, нарушает систему типов, когда он превращается в гигантское насекомое,
и мы все знаем, чем это заканчивается.

Другой аргумент, который я часто слышу, заключается в том, что работа с типами накладывает слишком
большую нагрузку на программиста. Я мог бы посочувствовать этому чувству
после того, как мне самому пришлось написать несколько объявлений итераторов в C++,
за исключением того, что существует технология, называемая \newterm{выведение типов}, которая позволяет
компилятору выводить большинство типов из контекста, в котором они
используются. В C++ теперь можно объявить переменную \code{auto} и позволить
компилятору определить её тип.

В Haskell, за редкими исключениями, аннотации типов чисто
опциональны. Программисты склонны использовать их в любом случае, потому что они могут рассказать
многое о семантике кода, и они делают ошибки компиляции проще для
понимания. Обычная практика в Haskell --- начинать проект с
проектирования типов. \sloppy{Позже аннотации типов управляют реализацией
  и становятся комментариями, принудительно применяемыми компилятором.}

Сильная статическая типизация часто используется как оправдание для нетестирования
кода. Вы иногда можете услышать, как Haskell-программисты говорят: ``Если оно
компилируется, оно должно быть правильным.'' Конечно, нет гарантии, что
типо-корректная программа корректна в смысле производства правильного
вывода. Результат этого беспечного отношения состоит в том, что в нескольких исследованиях
Haskell не намного опередил остальных в качестве кода, как можно
было бы ожидать. Похоже, что в коммерческой обстановке давление на
исправление багов применяется только до определённого уровня качества, который имеет
всё отношение к экономике разработки программного обеспечения и
толерантности конечного пользователя, и очень мало отношения к языку
программирования или методологии. Лучшим критерием было бы измерить, сколько
проектов отстают от графика или поставляются с резко сокращённой
функциональностью.

Что касается аргумента, что модульное тестирование может заменить сильную типизацию,
рассмотрите обычную практику рефакторинга в сильно типизированных языках:
изменение типа аргумента определённой функции. В сильно
типизированном языке достаточно изменить объявление этой функции
и затем исправить все ошибки сборки. В слабо типизированном языке тот факт,
что функция теперь ожидает другие данные, не может быть распространён на места
вызова. Модульное тестирование может поймать некоторые несоответствия, но тестирование
почти всегда является вероятностным, а не детерминированным процессом.
Тестирование --- плохая замена доказательства.

\section{Что такое типы?}

Простейшая интуиция для типов заключается в том, что они являются множествами значений.
Тип \code{Bool} (помните, конкретные типы начинаются с заглавной буквы
в Haskell) --- это двухэлементное множество \code{True} и \code{False}.
Тип \code{Char} --- это множество всех символов Unicode, таких как
\code{a} или \code{ą}.

Множества могут быть конечными или бесконечными. Тип \code{String}, который является
синонимом списка \code{Char}, является примером бесконечного множества.

Когда мы объявляем \code{x} как \code{Integer}:

\src{snippet01}
мы говорим, что это элемент множества целых чисел.
\code{Integer} в Haskell --- это бесконечное множество, и его можно использовать для
арифметики произвольной точности. Существует также конечное множество \code{Int},
которое соответствует машинному типу, точно так же, как C++ \code{int}.

Есть некоторые тонкости, которые делают эту идентификацию типов и
множеств сложной. Есть проблемы с полиморфными функциями, которые включают
циклические определения, и с тем фактом, что у вас не может быть множества всех
множеств; но, как я обещал, я не буду придирчив к математике. Великая вещь
в том, что существует категория множеств, которая называется $\Set$, и
мы просто будем работать с ней. В $\Set$ объекты --- это множества, а морфизмы
(стрелки) --- это функции.

$\Set$ --- это очень особая категория, потому что мы можем фактически заглянуть
внутрь её объектов и получить много интуиций от этого. Например,
мы знаем, что пустое множество не имеет элементов. Мы знаем, что есть
особые одноэлементные множества. Мы знаем, что функции отображают элементы одного
множества в элементы другого множества. Они могут отображать два элемента в один, но
не один элемент в два. Мы знаем, что тождественная функция отображает каждый
элемент множества в себя, и так далее. План состоит в том, чтобы постепенно забыть
всю эту информацию и вместо этого выразить все эти понятия в чисто
категорных терминах, то есть в терминах объектов и стрелок.

В идеальном мире мы просто сказали бы, что типы Haskell --- это множества, а
функции Haskell --- это математические функции между множествами. Есть только
одна маленькая проблема: математическая функция не выполняет никакого кода
--- она просто знает ответ. Функция Haskell должна вычислить
ответ. Это не проблема, если ответ может быть получен за конечное
количество шагов --- каким бы большим ни было это число. Но есть некоторые
вычисления, которые включают рекурсию, и они могут никогда не завершиться. Мы
не можем просто запретить незавершающиеся функции в Haskell, потому что
различие между завершающимися и незавершающимися функциями
неразрешимо --- знаменитая проблема остановки. Вот почему компьютерные
учёные придумали блестящую идею, или большой хак, в зависимости от
вашей точки зрения, расширить каждый тип ещё одним специальным значением,
называемым \newterm{дном} и обозначаемым \code{\_|\_}, или
Unicode $\bot$. Это ``значение'' соответствует незавершающемуся вычислению.
Итак, функция, объявленная как:

\src{snippet02}
может вернуть \code{True}, \code{False} или \code{\_|\_};
последнее означает, что она никогда не завершится.

Интересно, что как только вы принимаете дно как часть системы типов, удобно
рассматривать каждую ошибку времени выполнения как дно и даже позволять
функциям возвращать дно явно. Последнее обычно делается
с использованием выражения \code{undefined}, как в:

\src{snippet03}
Это определение типо-проверяется, потому что \code{undefined} вычисляется в
дно, которое является членом любого типа, включая \code{Bool}. Вы можете
даже написать:

\src{snippet04}
(без \code{x}), потому что дно также является членом типа
\code{Bool -> Bool}.

Функции, которые могут вернуть дно, называются частичными, в отличие от тотальных
функций, которые возвращают допустимые результаты для каждого возможного аргумента.

Из-за дна вы увидите категорию типов и функций Haskell,
называемую $\Hask$, а не $\Set$. С
теоретической точки зрения это источник бесконечных
осложнений, поэтому на этом этапе я использую свой мясницкий нож и
завершаю эту линию рассуждений. С прагматической точки зрения
нормально игнорировать незавершающиеся функции и дно и рассматривать
$\Hask$ как настоящий $\Set$.\footnote{Nils Anders Danielsson,
  John Hughes, Patrik Jansson, Jeremy Gibbons, \href{http://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf}{
    Fast and Loose Reasoning is Morally Correct}. Эта статья предоставляет обоснование для игнорирования дна в большинстве контекстов.}

\section{Зачем нам нужна математическая модель?}

Как программист вы близко знакомы с синтаксисом и грамматикой
вашего языка программирования. Эти аспекты языка обычно
описываются с использованием формальной нотации в самом начале спецификации языка.
Но значение, или семантика, языка гораздо труднее
описать; это занимает гораздо больше страниц, редко бывает достаточно формальным и почти
никогда не полным. Отсюда бесконечные дискуссии среди языковых
юристов и целая кустарная индустрия книг, посвящённых экзегезе
тонкостей языковых стандартов.

Существуют формальные инструменты для описания семантики языка, но
из-за их сложности они в основном используются с упрощёнными
академическими языками, а не с реальными программистскими бегемотами. Один такой инструмент,
называемый \newterm{операционная семантика}, описывает механику выполнения программы.
Он определяет формализованный идеализированный интерпретатор. Семантика
промышленных языков, таких как C++, обычно описывается с использованием
неформальных операционных рассуждений, часто в терминах ``абстрактной
машины.''

Проблема в том, что очень трудно доказывать вещи о программах, используя
операционную семантику. Чтобы показать свойство программы, вы по существу
должны ``запустить её'' через идеализированный интерпретатор.

Не важно, что программисты никогда не выполняют формальные доказательства
корректности. Мы всегда ``думаем'', что пишем правильные программы. Никто
не сидит за клавиатурой, говоря: ``О, я просто брошу несколько строк кода
и посмотрю, что произойдёт.'' Мы думаем, что код, который мы пишем, будет выполнять
определённые действия, которые произведут желаемые результаты. Мы обычно довольно
удивлены, когда это не так. Это означает, что мы действительно рассуждаем о программах, которые
пишем, и мы обычно делаем это, запуская интерпретатор в наших головах. Просто
действительно сложно отслеживать все переменные. Компьютеры хороши
в запуске программ --- люди нет! Если бы мы были, нам не нужны были бы
компьютеры.

Но есть альтернатива. Она называется \newterm{денотационная семантика},
и она основана на математике. В денотационной семантике каждая программная
конструкция получает своё математическое толкование. С этим, если вы
хотите доказать свойство программы, вы просто доказываете математическую
теорему. Вы можете подумать, что доказательство теорем трудно, но факт в том,
что мы, люди, накапливали математические методы тысячи
лет, так что есть богатство накопленных знаний, к которым можно обратиться.
Также, по сравнению с теоремами, которые доказывают профессиональные
математики, проблемы, с которыми мы сталкиваемся в программировании,
обычно довольно просты, если не тривиальны.

Рассмотрим определение факториальной функции в Haskell, который является
языком, весьма пригодным для денотационной семантики:

\src{snippet05}
Выражение \code{{[}1..n{]}} --- это список целых чисел от \code{1} до \code{n}.
Функция \code{product} умножает все элементы списка. Это
точно так же, как определение факториала, взятое из математического текста. Сравните это
с C:

\begin{snip}{c}
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
\end{snip}
Нужно ли мне говорить больше?

Ладно, я буду первым, кто признает, что это был дешёвый выстрел! Факториальная
функция имеет очевидное математическое денотационное значение. Проницательный читатель может
спросить: какая математическая модель для чтения символа с
клавиатуры или отправки пакета по сети? Долгое время
это был бы неудобный вопрос, ведущий к довольно запутанному
объяснению. Казалось, что денотационная семантика не лучше всего подходит
для значительного числа важных задач, которые были необходимы для
написания полезных программ, и с которыми можно было легко справиться
операционной семантикой. Прорыв пришёл из теории категорий.
Eugenio Moggi обнаружил, что вычислительный эффект может быть отображён на
монады. Это оказалось важным наблюдением, которое не только
дало денотационной семантике новую жизнь и сделало чисто функциональные
программы более удобными, но также пролило новый свет на традиционное
программирование. Я расскажу о монадах позже, когда мы разработаем больше
категорных инструментов.

Одно из важных преимуществ наличия математической модели для
программирования заключается в том, что можно выполнять формальные доказательства
корректности программного обеспечения. Это может показаться не таким важным, когда вы
пишете потребительское программное обеспечение, но есть области программирования, где
цена неудачи может быть непомерной, или где человеческая жизнь поставлена на карту. Но
даже при написании веб-приложений для системы здравоохранения вы можете
оценить мысль, что функции и алгоритмы из стандартной
библиотеки Haskell поставляются с доказательствами корректности.

\section{Чистые и грязные функции}

Вещи, которые мы называем функциями в C++ или любом другом императивном языке,
не те же вещи, которые математики называют функциями. Математическая
функция --- это просто отображение значений на значения.

Мы можем реализовать математическую функцию в языке программирования: такая
функция, получив входное значение, вычислит выходное значение. Функция
для получения квадрата числа, вероятно, умножит входное
значение на себя. Она будет делать это каждый раз, когда вызывается, и
гарантированно производит один и тот же результат каждый раз, когда вызывается с одним и
тем же входом. Квадрат числа не меняется с фазами
Луны.

Также вычисление квадрата числа не должно иметь побочного эффекта
в виде выдачи вкусного угощения для вашей собаки. ``Функция'', которая делает это,
не может быть легко смоделирована как математическая функция.

В языках программирования функции, которые всегда производят один и тот же результат
при одном и том же входе и не имеют побочных эффектов, называются \newterm{чистыми
  функциями}. В чисто функциональном языке, таком как Haskell, все функции
чисты. Из-за этого легче дать этим языкам денотационную
семантику и моделировать их, используя теорию категорий. Что касается других языков,
всегда возможно ограничить себя чистым подмножеством или рассуждать
о побочных эффектах отдельно. Позже мы увидим, как монады позволяют нам моделировать
все виды эффектов, используя только чистые функции. Так что мы действительно ничего не теряем,
ограничивая себя математическими функциями.

\section{Примеры типов}

Как только вы поймёте, что типы --- это множества, вы можете придумать довольно
экзотические типы. Например, какой тип соответствует пустому
множеству? Нет, это не C++ \code{void}, хотя этот тип \emph{называется}
\code{Void} в Haskell. Это тип, который не населён никакими
значениями. Вы можете определить функцию, которая принимает \code{Void}, но вы
никогда не сможете её вызвать. Чтобы вызвать её, вам нужно предоставить значение типа
\code{Void}, а их просто нет. Что касается того, что эта функция может
вернуть, нет никаких ограничений. Она может вернуть любой тип
(хотя никогда не вернёт, потому что её нельзя вызвать). Другими словами,
это функция, которая полиморфна по типу возврата. Haskell-программисты имеют
имя для неё:

\src{snippet06}
(Помните, \code{a} --- это типовая переменная, которая может обозначать любой тип.)
Имя не случайно. Есть более глубокая интерпретация типов
и функций в терминах логики, называемая изоморфизмом Карри-Говарда.
Тип \code{Void} представляет ложь, а тип функции
\code{absurd} соответствует утверждению, что из лжи следует
всё, как в латинском изречении ``ex falso sequitur quodlibet.''

Далее идёт тип, который соответствует одноэлементному множеству. Это тип, который
имеет только одно возможное значение. Это значение просто ``есть.'' Вы можете не
сразу распознать его как таковой, но это C++ \code{void}.
Подумайте о функциях из и в этот тип. Функция из \code{void}
всегда может быть вызвана. Если это чистая функция, она всегда вернёт
тот же результат. Вот пример такой функции:

\begin{snip}{c}
int f44() { return 44; }
\end{snip}
Вы можете подумать об этой функции как о принимающей ``ничего'', но, как мы только что
видели, функция, которая принимает ``ничего'', никогда не может быть вызвана, потому что
нет значения, представляющего ``ничего.'' Так что принимает эта функция?
Концептуально она принимает фиктивное значение, которого существует только один
экземпляр, поэтому нам не нужно упоминать его явно. В Haskell,
однако, есть символ для этого значения: пустая пара скобок,
\code{()}. Итак, по забавному совпадению (или это совпадение?),
вызов функции void выглядит одинаково в C++ и в Haskell. Также,
из-за любви Haskell к лаконичности, тот же символ \code{()}
используется для типа, конструктора и единственного значения, соответствующего
одноэлементному множеству. Итак, вот эта функция в Haskell:

\src{snippet07}
Первая строка объявляет, что \code{f44} принимает тип \code{()},
произносимый ``юнит,'' в тип \code{Integer}. Вторая строка
определяет \code{f44} путём сопоставления с образцом единственного конструктора для unit,
а именно \code{()}, и производит число 44. Вы вызываете эту функцию,
предоставляя значение unit \code{()}:

\begin{snip}{c}
f44 ()
\end{snip}
Обратите внимание, что каждая функция от unit эквивалентна выбору одного
элемента из целевого типа (здесь выбирается \code{Integer} 44). На
самом деле вы могли бы думать о \code{f44} как о другом представлении для
числа 44. Это пример того, как мы можем заменить явное упоминание
элементов множества разговором о функциях (стрелках) вместо этого.
Функции от unit к любому типу $A$ находятся во взаимно однозначном соответствии с
элементами этого множества $A$.

Что насчёт функций с типом возврата \code{void}, или, в Haskell,
с типом возврата unit? В C++ такие функции используются для побочных
эффектов, но мы знаем, что это не настоящие функции в
математическом смысле слова. Чистая функция, которая возвращает unit, ничего
не делает: она отбрасывает свой аргумент.

Математически функция из множества $A$ в одноэлементное множество отображает каждый
элемент $A$ в единственный элемент этого одноэлементного множества. Для каждого $A$
существует ровно одна такая функция. Вот эта функция для
\code{Integer}:

\src{snippet08}
Вы даёте ей любое целое число, и она даёт вам обратно unit. В духе
лаконичности Haskell позволяет использовать шаблон подстановки, подчёркивание,
для аргумента, который отбрасывается. Таким образом, вам не нужно изобретать
имя для него. Итак, вышеприведённое можно переписать как:

\src{snippet09}
Обратите внимание, что реализация этой функции не только не зависит
от значения, переданного ей, но даже не зависит от типа
аргумента.

Функции, которые могут быть реализованы с одной и той же формулой для любого типа,
называются параметрически полиморфными. Вы можете реализовать целое семейство
таких функций одним уравнением, используя параметр типа вместо
конкретного типа. Как мы должны назвать полиморфную функцию из любого типа
в тип unit? Конечно, мы назовём её \code{unit}:

\src{snippet10}
В C++ вы бы написали эту функцию как:

\begin{snip}{cpp}
template<class T>
void unit(T) {}
\end{snip}
Далее в типологии типов идёт двухэлементное множество. В C++ оно называется
\code{bool}, а в Haskell, предсказуемо, \code{Bool}. Разница
в том, что в C++ \code{bool} --- это встроенный тип, тогда как в Haskell его
можно определить следующим образом:

\src{snippet11}
(Способ прочитать это определение: \code{Bool} --- это либо
\code{True}, либо \code{False}.) В принципе, также должно быть возможно
определить булев тип в C++ как перечисление:

\begin{snip}{cpp}
enum bool {
    true,
    false
};
\end{snip}
но C++ \code{enum} --- это тайно целое число. C++11
``\code{enum class}'' можно было бы использовать вместо этого, но тогда вам
пришлось бы квалифицировать его значения именем класса, как в
\code{bool::true} и \code{bool::false}, не говоря уже о необходимости
включать соответствующий заголовок в каждый файл, который его использует.

Чистые функции из \code{Bool} просто выбирают два значения из целевого
типа, одно, соответствующее \code{True}, и другое для \code{False}.

Функции в \code{Bool} называются \newterm{предикатами}. Например,
библиотека Haskell \code{Data.Char} полна предикатов, таких как
\code{isAlpha} или \code{isDigit}. В C++ есть похожая библиотека
\code{}, которая определяет, среди прочего, \code{isalpha} и
\code{isdigit}, но они возвращают \code{int}, а не
Boolean. Фактические предикаты определены в \code{std::ctype} и
имеют форму \code{ctype::is(alpha, c)}, \code{ctype::is(digit, c)} и т.д.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Определите функцию высшего порядка (или функциональный объект) \code{memoize}
        на вашем любимом языке. Эта функция принимает чистую функцию
        \code{f} в качестве аргумента и возвращает функцию, которая ведёт себя почти
        точно так же, как \code{f}, за исключением того, что она вызывает оригинальную
        функцию только один раз для каждого аргумента, сохраняет результат внутренне и
        впоследствии возвращает этот сохранённый результат каждый раз, когда вызывается с
        тем же аргументом. Вы можете отличить мемоизированную функцию от
        оригинала, наблюдая за её производительностью. Например, попробуйте мемоизировать
        функцию, которая долго вычисляется. Вам придётся ждать
        результата в первый раз, когда вы её вызовете, но при последующих вызовах с
        тем же аргументом вы должны получить результат немедленно.
  \item
        Попробуйте мемоизировать функцию из вашей стандартной библиотеки, которую вы обычно
        используете для генерации случайных чисел. Работает ли это?
  \item
        Большинство генераторов случайных чисел можно инициализировать с помощью seed.
        Реализуйте функцию, которая принимает seed, вызывает генератор случайных
        чисел с этим seed и возвращает результат. Мемоизируйте эту
        функцию. Работает ли это?
  \item
        Какие из этих функций C++ являются чистыми? Попробуйте их мемоизировать и наблюдайте,
        что происходит, когда вы вызываете их несколько раз: мемоизированные и нет.

        \begin{enumerate}
          \tightlist
          \item
                Факториальная функция из примера в тексте.
          \item
                \begin{minted}{cpp}
std::getchar()
\end{minted}
          \item
                \begin{minted}{cpp}
bool f() {
    std::cout << "Hello!" << std::endl;
    return true;
}
\end{minted}
          \item
                \begin{minted}{cpp}
int f(int x) {
    static int y = 0;
    y += x;
    return y;
}
\end{minted}
        \end{enumerate}
  \item
        Сколько существует различных функций из \code{Bool} в
        \code{Bool}? Можете ли вы реализовать их все?
  \item
        Нарисуйте картинку категории, единственными объектами которой являются типы
        \code{Void}, \code{()} (unit) и \code{Bool}; со стрелками,
        соответствующими всем возможным функциям между этими типами. Пометьте
        стрелки именами функций.
\end{enumerate}
