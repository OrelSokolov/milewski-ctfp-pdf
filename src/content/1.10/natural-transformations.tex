% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{М}{ы говорили о} функторах как отображениях между категориями, которые сохраняют
их структуру.

Функтор ``встраивает'' одну категорию в другую. Он может
схлопывать несколько вещей в одну, но никогда не разрывает связи. Один
способ думать об этом --- что с помощью функтора мы моделируем одну
категорию внутри другой. Исходная категория служит моделью,
чертежом, для некоторой структуры, которая является частью целевой категории.

\begin{figure}[H]
  \centering\includegraphics[width=0.4\textwidth]{images/1_functors.jpg}
\end{figure}

\noindent
Может быть много способов встраивания одной категории в другую. Иногда
они эквивалентны, иногда очень различны. Один может схлопнуть
всю исходную категорию в один объект, другой может отобразить каждый объект в
разный объект, а каждый морфизм в разный морфизм. Один и тот же
чертёж может быть реализован многими разными способами. Естественные
преобразования помогают нам сравнивать эти реализации. Они являются отображениями
функторов --- специальными отображениями, которые сохраняют их функториальную природу.

Рассмотрим два функтора $F$ и $G$ между категориями
$\cat{C}$ и $\cat{D}$. Если вы сосредоточитесь только на одном объекте $a$ в
$\cat{C}$, он отображается в два объекта: $F a$ и $G a$.
Отображение функторов должно следовательно отображать $F a$ в
$G a$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/2_natcomp.jpg}
\end{figure}

\noindent
Обратите внимание, что $F a$ и $G a$ --- объекты в одной и той же
категории $\cat{D}$. Отображения между объектами в одной и той же категории не должны
идти против зерна категории. Мы не хотим делать
искусственные связи между объектами. Поэтому \emph{естественно} использовать
существующие связи, а именно морфизмы. Естественное преобразование --- это
выбор морфизмов: для каждого объекта $a$ оно выбирает один
морфизм из $F a$ в $G a$. Если мы называем естественное
преобразование $\alpha$, этот морфизм называется \newterm{компонентой}
$\alpha$ в $a$, или $\alpha_a$.

\[\alpha_a \Colon F a \to G a\]
Имейте в виду, что $a$ --- это объект в $\cat{C}$, в то время как $\alpha_a$
--- это морфизм в $\cat{D}$.

Если для некоторого $a$ нет морфизма между $F a$ и
$G a$ в $\cat{D}$, не может быть естественного преобразования
между $F$ и $G$.

Конечно, это только половина истории, потому что функторы не только отображают
объекты, они также отображают морфизмы. Так что же делает естественное
преобразование с этими отображениями? Оказывается, что отображение
морфизмов фиксировано --- при любом естественном преобразовании между $F$ и $G$,
$F f$ должен быть преобразован в $G f$. Более того,
отображение морфизмов двумя функторами резко ограничивает
выборы, которые мы имеем в определении естественного преобразования, совместимого
с ним. Рассмотрим морфизм $f$ между двумя объектами $a$
и $b$ в $\cat{C}$. Он отображается в два морфизма, $F f$
и $G f$ в $\cat{D}$:

\begin{gather*}
  F f \Colon F a \to F b \\
  G f \Colon G a \to G b
\end{gather*}
Естественное преобразование $\alpha$ предоставляет два дополнительных морфизма,
которые завершают диаграмму в \emph{D}:

\begin{gather*}
  \alpha_a \Colon F a \to G a \\
  \alpha_b \Colon F b \to G b
\end{gather*}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/3_naturality.jpg}
\end{figure}

\noindent
Теперь у нас есть два способа попасть из $F a$ в $G b$. Чтобы
убедиться, что они равны, мы должны наложить \newterm{условие естественности},
которое выполняется для любого $f$:

\[G f \circ \alpha_a = \alpha_b \circ F f\]
Условие естественности --- довольно строгое требование. Например,
если морфизм $F f$ обратим, естественность
определяет $\alpha_b$ в терминах $\alpha_a$. Оно \emph{транспортирует}
$\alpha_a$ вдоль $f$:

\[\alpha_b = (G f) \circ \alpha_a \circ (F f)^{-1}\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/4_transport.jpg}
\end{figure}

\noindent
Если существует более одного обратимого морфизма между двумя объектами, все
эти транспорты должны совпадать. В общем случае, однако, морфизмы не
обратимы; но вы можете видеть, что существование естественных
преобразований между двумя функторами далеко не гарантировано. Так что
редкость или изобилие функторов, которые связаны естественными
преобразованиями, может многое сказать вам о структуре категорий,
между которыми они действуют. Мы увидим некоторые примеры этого, когда будем говорить
о пределах и лемме Ёнеды.

Глядя на естественное преобразование покомпонентно, можно сказать, что оно
отображает объекты в морфизмы. Из-за условия естественности можно
также сказать, что оно отображает морфизмы в коммутирующие квадраты --- есть один
коммутирующий квадрат естественности в $\cat{D}$ для каждого морфизма в $\cat{C}$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/naturality.jpg}
\end{figure}

\noindent
Это свойство естественных преобразований очень удобно во многих
категорных конструкциях, которые часто включают коммутирующие диаграммы. С
разумным выбором функторов много этих условий коммутативности
могут быть превращены в условия естественности. Мы увидим примеры
этого, когда доберёмся до пределов, копределов и сопряжений.

Наконец, естественные преобразования могут быть использованы для определения изоморфизмов
функторов. Говорить, что два функтора естественно изоморфны, почти
как говорить, что они одинаковы. \newterm{Естественный изоморфизм} определяется как
естественное преобразование, чьи компоненты --- все изоморфизмы
(обратимые морфизмы).

\section{Полиморфные функции}

Мы говорили о роли функторов (или, более конкретно,
эндофункторов) в программировании. Они соответствуют конструкторам типов, которые
отображают типы в типы. Они также отображают функции в функции, и это
отображение реализуется функцией высшего порядка \code{fmap} (или
\code{transform}, \code{then} и подобными в C++).

Для конструирования естественного преобразования мы начинаем с объекта, здесь
типа, \code{a}. Один функтор, \code{F}, отображает его в тип
$F a$. Другой функтор, \code{G}, отображает его в $G a$.
Компонента естественного преобразования \code{alpha} в \code{a}
--- это функция из $F a$ в $G a$. В псевдо-Haskell:

\begin{snipv}
alpha\textsubscript{a} :: F a -> G a
\end{snipv}
Естественное преобразование --- это параметрически полиморфная функция, которая определена для
всех типов \code{a}:

\src{snippet01}
\code{forall a} опционален в Haskell (и на самом деле требует
включения расширения языка \code{ExplicitForAll}). Обычно
вы бы написали это так:

\src{snippet02}
Имейте в виду, что это действительно семейство функций, параметризованное
\code{a}. Это ещё один пример лаконичности синтаксиса Haskell.
Похожая конструкция в C++ была бы немного более многословной:

\begin{snip}{cpp}
template<class A> G<A> alpha(F<A>);
\end{snip}
Есть более глубокое различие между полиморфными функциями Haskell
и обобщёнными функциями C++, и оно отражено в способе, которым эти
функции реализуются и проверяются на типы. В Haskell полиморфная
функция должна быть определена единообразно для всех типов. Одна формула должна работать
для всех типов. Это называется \newterm{параметрический полиморфизм}.

C++, с другой стороны, поддерживает по умолчанию \newterm{ad hoc полиморфизм},
что означает, что шаблон не должен быть хорошо определён для всех
типов. Будет ли шаблон работать для данного типа, решается во время
инстанцирования, где конкретный тип подставляется вместо параметра типа.
Проверка типов откладывается, что, к сожалению, часто приводит к
непонятным сообщениям об ошибках.

В C++ также есть механизм для перегрузки функций и
специализации шаблонов, который позволяет разные определения одной и той же функции
для разных типов. В Haskell эта функциональность предоставляется классами типов
и семействами типов.

Параметрический полиморфизм Haskell имеет неожиданное следствие: любая
полиморфная функция типа:

\src{snippet03}
где \code{F} и \code{G} --- функторы, автоматически удовлетворяет
условию естественности. Вот оно в категорной нотации ($f$
--- это функция $f \Colon a \to b$):

\[G f \circ \alpha_a = \alpha_b \circ F f\]
В Haskell действие функтора \code{G} на морфизм \code{f}
реализуется с использованием \code{fmap}. Сначала я напишу это в
псевдо-Haskell, с явными аннотациями типов:

\begin{snipv}
fmap\textsubscript{G} f . alpha\textsubscript{a} = alpha\textsubscript{b} . fmap\textsubscript{F} f
\end{snipv}
Из-за вывода типов эти аннотации не нужны, и
следующее уравнение выполняется:

\begin{snip}{text}
fmap f . alpha = alpha . fmap f
\end{snip}
Это всё ещё не настоящий Haskell --- равенство функций не выразимо
в коде --- но это тождество, которое может быть использовано программистом в
уравнительном рассуждении; или компилятором для реализации оптимизаций.

Причина, по которой условие естественности автоматично в Haskell, связана
с ``теоремами бесплатно''. Параметрический полиморфизм, который используется для
определения естественных преобразований в Haskell, накладывает очень сильные
ограничения на реализацию --- одна формула для всех типов. Эти
ограничения переводятся в уравнительные теоремы о таких функциях. В
случае функций, которые преобразуют функторы, свободные теоремы --- это
условия естественности.\footnote{
  Вы можете прочитать больше о свободных теоремах в моём
  блоге \href{https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/}{``Parametricity:
    Money for Nothing and Theorems for Free}.''}

Один способ думать о функторах в Haskell, который я упоминал ранее,
--- рассматривать их как обобщённые контейнеры. Мы можем продолжить эту аналогию
и рассматривать естественные преобразования как рецепты для переупаковки
содержимого одного контейнера в другой контейнер. Мы не трогаем
сами элементы: мы не модифицируем их и не создаём новые.
Мы просто копируем (некоторые из) них, иногда несколько раз, в
новый контейнер.

Условие естественности становится утверждением, что не имеет значения,
модифицируем ли мы элементы сначала, через применение
\code{fmap}, и переупаковываем позже; или переупаковываем сначала, а затем модифицируем
элементы в новом контейнере, с его собственной реализацией
\code{fmap}. Эти два действия, переупаковка и \code{fmap}пинг,
ортогональны. ``Одно перемещает яйца, другое их варит.''

Давайте посмотрим на несколько примеров естественных преобразований в Haskell.
Первое между функтором списка и функтором \code{Maybe}. Оно
возвращает голову списка, но только если список непустой:

\src{snippet04}
Это функция, полиморфная в \code{a}. Она работает для любого типа
\code{a}, без ограничений, поэтому это пример параметрического
полиморфизма. Следовательно, это естественное преобразование между двумя
функторами. Но просто для того, чтобы убедить себя, давайте проверим условие
естественности.

\src{snippet05}
У нас есть два случая для рассмотрения; пустой список:

\src{snippet06}

\src{snippet07}
и непустой список:

\src{snippet08}

\src{snippet09}
Я использовал реализацию \code{fmap} для списков:

\src{snippet10}
и для \code{Maybe}:

\src{snippet11}
Интересный случай --- когда один из функторов --- тривиальный
функтор \code{Const}. Естественное преобразование из или в
функтор \code{Const} выглядит как функция, которая либо
полиморфна в своём типе возврата, либо в своём типе аргумента.

Например, \code{length} может рассматриваться как естественное
преобразование из функтора списка в функтор \code{Const Int}:

\src{snippet12}
Здесь \code{unConst} используется для снятия конструктора \code{Const}:

\src{snippet13}
Конечно, на практике \code{length} определяется как:

\src{snippet14}
что эффективно скрывает факт, что это естественное преобразование.

Найти параметрически полиморфную функцию \emph{из}
функтора \code{Const} немного сложнее, потому что это потребовало бы
создания значения из ничего. Лучшее, что мы можем сделать:

\src{snippet15}
Другой общий функтор, который мы уже видели и который будет играть
важную роль в лемме Ёнеды, --- это функтор \code{Reader}. Я
перепишу его определение как \code{newtype}:

\src{snippet16}
Он параметризован двумя типами, но (ковариантно) функториален только
во втором:

\src{snippet17}
Для каждого типа \code{e} вы можете определить семейство естественных
преобразований из \code{Reader e} в любой другой функтор \code{f}.
Мы увидим позже, что члены этого семейства всегда находятся во взаимно однозначном
соответствии с элементами \code{f e}
(\hyperref[the-yoneda-lemma]{лемма Ёнеды}).

Например, рассмотрим несколько тривиальный тип unit \code{()} с
одним элементом \code{()}. Функтор \code{Reader ()} принимает любой тип
\code{a} и отображает его в тип функции \code{() -> a}.
Это просто все функции, которые выбирают один элемент из множества
\code{a}. Их столько же, сколько элементов в
\code{a}. Теперь давайте рассмотрим естественные преобразования из этого функтора
в функтор \code{Maybe}:

\src{snippet18}
Есть только два таких, \code{dumb} и \code{obvious}:

\src{snippet19}
и

\src{snippet20}
(Единственное, что вы можете сделать с \code{g}, --- это применить его к значению
unit \code{()}.)

И действительно, как предсказано леммой Ёнеды, они соответствуют
двум элементам типа \code{Maybe ()}, которые являются \code{Nothing}
и \code{Just ()}. Мы вернёмся к лемме Ёнеды позже ---
это был просто небольшой тизер.

\section{За пределами естественности}

Параметрически полиморфная функция между двумя функторами (включая
краевой случай функтора \code{Const}) всегда является естественным
преобразованием. Поскольку все стандартные алгебраические типы данных --- функторы,
любая полиморфная функция между такими типами --- это естественное преобразование.

У нас также есть типы функций в нашем распоряжении, и они функториальны в
своём типе возврата. Мы можем использовать их для построения функторов (как
функтор \code{Reader}) и определения естественных преобразований, которые являются
функциями высшего порядка.

Однако типы функций не ковариантны в типе аргумента. Они
\newterm{контравариантны}. Конечно, контравариантные функторы эквивалентны
ковариантным функторам из противоположной категории. Полиморфные функции
между двумя контравариантными функторами всё ещё являются естественными преобразованиями в
категорном смысле, за исключением того, что они работают на функторах из
противоположной категории в типы Haskell.

Вы можете вспомнить пример контравариантного функтора, на который мы смотрели
раньше:

\src{snippet21}
Этот функтор контравариантен в \code{a}:

\src{snippet22}
Мы можем написать полиморфную функцию из, скажем, \code{Op Bool} в
\code{Op String}:

\src{snippet23}
Но поскольку два функтора не ковариантны, это не естественное
преобразование в $\Hask$. Однако, поскольку они оба
контравариантны, они удовлетворяют ``противоположному'' условию естественности:

\src{snippet24}[b]
Обратите внимание, что функция \code{f} должна идти в противоположном направлении,
чем то, что вы бы использовали с \code{fmap}, из-за сигнатуры
\code{contramap}:

\src{snippet25}
Есть ли конструкторы типов, которые не являются функторами, будь то ковариантные
или контравариантные? Вот один пример:

\src{snippet26}
Это не функтор, потому что один и тот же тип \code{a} используется и в
отрицательной (контравариантной), и в положительной (ковариантной) позиции. Вы
не можете реализовать \code{fmap} или \code{contramap} для этого типа.
Следовательно, функция сигнатуры:

\src{snippet27}
где \code{f} --- произвольный функтор, не может быть естественным
преобразованием. Интересно, что есть обобщение естественных
преобразований, называемое динатуральными преобразованиями, которое имеет дело с такими
случаями. Мы доберёмся до них, когда будем обсуждать концы.

\section{Категория функторов}

Теперь, когда у нас есть отображения между функторами --- естественные преобразования
--- естественно задать вопрос, образуют ли функторы
категорию. И действительно, образуют! Есть одна категория функторов для каждой
пары категорий, $\cat{C}$ и $\cat{D}$. Объекты в этой категории --- функторы из
$\cat{C}$ в $\cat{D}$, а морфизмы --- естественные преобразования между этими
функторами.

Мы должны определить композицию двух естественных преобразований, но это
довольно просто. Компоненты естественных преобразований --- морфизмы, и
мы знаем, как композировать морфизмы.

Действительно, давайте возьмём естественное преобразование $\alpha$ из функтора $F$ в $G$. Его
компонента в объекте $a$ --- это некоторый морфизм:
\[\alpha_a \Colon F a \to G a\]
Мы хотим скомпозировать $\alpha$ с $\beta$, которое является естественным преобразованием из
функтора $G$ в $H$. Компонента $\beta$ в $a$ --- это морфизм:
\[\beta_a \Colon G a \to H a\]
Эти морфизмы композиционны, и их композиция --- другой
морфизм:
\[\beta_a \circ \alpha_a \Colon F a \to H a\]
Мы будем использовать этот морфизм как компоненту естественного преобразования
$\beta \cdot \alpha$ --- композицию двух естественных преобразований $\beta$ после $\alpha$:
\[(\beta \cdot \alpha)_a = \beta_a \circ \alpha_a\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/5_vertical.jpg}
\end{figure}

\noindent
Один (долгий) взгляд на диаграмму убеждает нас, что результат этой
композиции действительно является естественным преобразованием из F в H:
\[H f \circ (\beta \cdot \alpha)_a = (\beta \cdot \alpha)_b \circ F f\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/6_verticalnaturality.jpg}
\end{figure}

\noindent
Композиция естественных преобразований ассоциативна, потому что их
компоненты, которые являются обычными морфизмами, ассоциативны относительно
своей композиции.

Наконец, для каждого функтора $F$ существует тождественное естественное преобразование
$1_F$, чьи компоненты --- тождественные морфизмы:
\[\id_{F a} \Colon F a \to F a\]
Итак, действительно, функторы образуют категорию.

Слово о нотации. Следуя Сондерсу Мак-Лейну, я использую точку для
вида композиции естественных преобразований, который я только что описал.
Проблема в том, что есть два способа композиции естественных преобразований.
Это называется вертикальной композицией, потому что функторы обычно
расположены вертикально на диаграммах, которые её описывают. Вертикальная
композиция важна в определении категории функторов. Я объясню
горизонтальную композицию вскоре.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/6a_vertical.jpg}
\end{figure}

\noindent
Категория функторов между категориями $\cat{C}$ и $\cat{D}$ записывается как
$\cat{Fun(C, D)}$, или $\cat{{[}C, D{]}}$, или иногда как
$\cat{D^C}$. Эта последняя нотация предполагает, что категория функторов сама
может рассматриваться как объект-функция (экспоненциал) в некоторой другой
категории. Действительно ли это так?

Давайте посмотрим на иерархию абстракций, которую мы строили
до сих пор. Мы начали с категории, которая является коллекцией
объектов и морфизмов. Категории сами (или, строго говоря,
\emph{малые} категории, чьи объекты образуют множества) сами являются объектами
в категории более высокого уровня $\Cat$. Морфизмы в этой категории ---
функторы. Hom-множество в $\Cat$ --- это множество функторов. Например,
$\cat{Cat(C, D)}$ --- это множество функторов между двумя категориями $\cat{C}$ и $\cat{D}$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/7_cathomset.jpg}
\end{figure}

\noindent
Категория функторов $\cat{{[}C, D{]}}$ также является множеством функторов между двумя
категориями (плюс естественные преобразования как морфизмы). Её объекты ---
те же, что и члены $\cat{Cat(C, D)}$. Более того, категория функторов,
будучи категорией, должна сама быть объектом $\Cat$ (так
случается, что категория функторов между двумя малыми категориями сама
мала). У нас есть отношение между Hom-множеством в категории и
объектом в той же категории. Ситуация точно такая же, как с
экспоненциальным объектом, который мы видели в последней секции. Давайте посмотрим, как мы
можем сконструировать последний в $\Cat$.

Как вы можете вспомнить, чтобы сконструировать экспоненциал, нам нужно
сначала определить произведение. В $\Cat$ это оказывается относительно
просто, потому что малые категории --- \emph{множества} объектов, и мы знаем,
как определить декартовы произведения множеств. Итак, объект в произведении
категорий $\cat{C\times D}$ --- это просто пара объектов, $(c, d)$, один из $\cat{C}$
и один из $\cat{D}$. Аналогично, морфизм между двумя такими парами,
$(c, d)$ и $(c', d')$, --- это пара морфизмов, $(f, g)$, где
$f \Colon c \to c'$ и $g \Colon d \to d'$. Эти пары морфизмов
композируются покомпонентно, и всегда есть тождественная пара, которая
просто пара тождественных морфизмов. Чтобы сделать длинную историю короткой,
$\Cat$ --- это полноценная декартово замкнутая категория, в которой есть
экспоненциальный объект $\cat{D^C}$ для любой пары категорий.
И под ``объектом'' в $\Cat$ я имею в виду категорию, так что
$\cat{D^C}$ --- это категория, которую мы можем идентифицировать с
категорией функторов между $\cat{C}$ и $\cat{D}$.

\section{2-категории}

Убрав это с пути, давайте присмотримся к $\Cat$. По
определению любое Hom-множество в $\Cat$ --- это множество функторов. Но, как мы
видели, функторы между двумя объектами имеют более богатую структуру, чем
просто множество. Они образуют категорию, с естественными преобразованиями, действующими как
морфизмы. Поскольку функторы рассматриваются как морфизмы в $\Cat$,
естественные преобразования --- это морфизмы между морфизмами.

Эта более богатая структура --- пример $\cat{2}$-категории, обобщения
категории, где, кроме объектов и морфизмов (которые могут быть названы
$1$-морфизмами в этом контексте), есть также $2$-морфизмы, которые являются
морфизмами между морфизмами.

В случае $\Cat$, рассматриваемого как $\cat{2}$-категория, у нас есть:

\begin{itemize}
  \tightlist
  \item
        Объекты: (Малые) категории
  \item
        1-морфизмы: Функторы между категориями
  \item
        2-морфизмы: Естественные преобразования между функторами.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/8_cat-2-cat.jpg}
\end{figure}

\noindent
Вместо Hom-множества между двумя категориями $\cat{C}$ и $\cat{D}$ у нас есть
Hom-категория --- категория функторов $\cat{D^C}$. У нас есть
обычная композиция функторов: функтор $F$ из $\cat{D^C}$
композируется с функтором $G$ из $\cat{E^D}$, чтобы дать $G \circ F$ из
$\cat{E^C}$. Но у нас также есть композиция внутри каждой
Hom-категории --- вертикальная композиция естественных преобразований, или
2-морфизмов, между функторами.

С двумя видами композиции в $\cat{2}$-категории возникает вопрос: как
они взаимодействуют друг с другом?

Давайте выберем два функтора, или 1-морфизма, в $\Cat$:
\begin{gather*}
  F \Colon \cat{C} \to \cat{D} \\
  G \Colon \cat{D} \to \cat{E}
\end{gather*}
и их композицию:
\[G \circ F \Colon \cat{C} \to \cat{E}\]
Предположим, у нас есть два естественных преобразования, $\alpha$ и $\beta$, которые действуют,
соответственно, на функторы $F$ и $G$:
\begin{gather*}
  \alpha \Colon F \to F' \\
  \beta \Colon G \to G'
\end{gather*}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/10_horizontal.jpg}
\end{figure}

\noindent
Обратите внимание, что мы не можем применить вертикальную композицию к этой паре, потому что
цель $\alpha$ отличается от источника $\beta$. На самом деле они являются
членами двух разных категорий функторов: $\cat{D^C}$ и $\cat{E^D}$.
Однако мы можем применить композицию к функторам
$F'$ и $G'$, потому что цель $F'$ --- это источник $G'$ --- это
категория $\cat{D}$. Каково отношение между функторами $G' \circ F'$ и $G \circ F$?

Имея $\alpha$ и $\beta$ в нашем распоряжении, можем ли мы определить естественное преобразование
из $G \circ F$ в $G' \circ F'$? Позвольте мне набросать конструкцию.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/9_horizontal.jpg}
\end{figure}

\noindent
Как обычно, мы начинаем с объекта $a$ в $\cat{C}$. Его образ расщепляется на
два объекта в $\cat{D}$: $F a$ и $F'a$. Есть также
морфизм, компонента $\alpha$, соединяющая эти два объекта:
\[\alpha_a \Colon F a \to F'a\]
При переходе из $\cat{D}$ в $\cat{E}$ эти два объекта расщепляются дальше на четыре
объекта: $G (F a)$, $G'(F a)$, $G (F'a)$, $G'(F'a)$.
У нас также есть четыре морфизма, образующих квадрат. Два из этих морфизмов ---
компоненты естественного преобразования $\beta$:
\begin{gather*}
  \beta_{F a} \Colon G (F a) \to G'(F a) \\
  \beta_{F'a} \Colon G (F'a) \to G'(F'a)
\end{gather*}
Два других --- образы $\alpha_a$ под двумя
функторами (функторы отображают морфизмы):
\begin{gather*}
  G \alpha_a \Colon G (F a) \to G (F'a) \\
  G'\alpha_a \Colon G'(F a) \to G'(F'a)
\end{gather*}
Это много морфизмов. Наша цель --- найти морфизм, который идёт из
$G (F a)$ в $G'(F'a)$, кандидат для
компоненты естественного преобразования, соединяющего два функтора $G \circ F$
и $G' \circ F'$. На самом деле есть не один, а два пути, которые мы можем взять из
$G (F a)$ в $G'(F'a)$:
\begin{gather*}
  G'\alpha_a \circ \beta_{F a} \\
  \beta_{F'a} \circ G \alpha_a
\end{gather*}
К счастью для нас, они равны, потому что квадрат, который мы сформировали, оказывается
квадратом естественности для $\beta$.

Мы только что определили компоненту естественного преобразования из $G \circ F$
в $G' \circ F'$. Доказательство естественности для этого преобразования довольно
прямолинейно, если у вас есть достаточно терпения.

Мы называем это естественное преобразование \newterm{горизонтальной композицией}
$\alpha$ и $\beta$:
\[\beta \circ \alpha \Colon G \circ F \to G' \circ F'\]
Опять же, следуя Мак-Лейну, я использую маленький круг для горизонтальной
композиции, хотя вы также можете встретить звёздочку на её месте.

Вот категорное эмпирическое правило: каждый раз, когда у вас есть композиция, вы
должны искать категорию. У нас есть вертикальная композиция естественных
преобразований, и она часть категории функторов. Но как насчёт
горизонтальной композиции? В какой категории она живёт?

Способ выяснить это --- посмотреть на $\Cat$ боком. Смотрите на
естественные преобразования не как на стрелки между функторами, а как на стрелки
между категориями. Естественное преобразование сидит между двумя
категориями, теми, которые соединены функторами, которые оно преобразует.
Мы можем думать о нём как о соединении этих двух категорий.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/sideways.jpg}
\end{figure}

\noindent
Давайте сосредоточимся на двух объектах $\Cat$ --- категориях $\cat{C}$ и $\cat{D}$. Есть
множество естественных преобразований, которые идут между функторами, которые
соединяют $\cat{C}$ с $\cat{D}$. Эти естественные преобразования --- наши новые стрелки из $\cat{C}$
в $\cat{D}$. По тому же принципу есть естественные преобразования, идущие между
функторами, которые соединяют $\cat{D}$ с $\cat{E}$, которые мы можем рассматривать как новые стрелки, идущие
из $\cat{D}$ в $\cat{E}$. Горизонтальная композиция --- это композиция этих стрелок.

У нас также есть тождественная стрелка, идущая из $\cat{C}$ в $\cat{C}$. Это
тождественное естественное преобразование, которое отображает тождественный функтор на $\cat{C}$ в себя.
Обратите внимание, что тождество для горизонтальной композиции также является тождеством
для вертикальной композиции, но не наоборот.

Наконец, две композиции удовлетворяют закону взаимозаменяемости:
\[(\beta' \cdot \alpha') \circ (\beta \cdot \alpha) = (\beta' \circ \beta) \cdot (\alpha' \circ \alpha)\]
Я процитирую Сондерса Мак-Лейна здесь: Читатель может получить удовольствие, записав
очевидные диаграммы, необходимые для доказательства этого факта.

Есть ещё один кусочек нотации, который может пригодиться в
будущем. В этой новой боковой интерпретации $\Cat$ есть
два способа попасть из объекта в объект: используя функтор или используя
естественное преобразование. Однако мы можем переинтерпретировать стрелку функтора
как специальный вид естественного преобразования: тождественное естественное
преобразование, действующее на этом функторе. Поэтому вы часто увидите эту
нотацию:
\[F \circ \alpha\]
где $F$ --- функтор из $\cat{D}$ в $\cat{E}$, а $\alpha$ --- естественное преобразование
между двумя функторами, идущими из $\cat{C}$ в $\cat{D}$. Поскольку вы не можете скомпозировать
функтор с естественным преобразованием, это интерпретируется как
горизонтальная композиция тождественного естественного преобразования
$1_F$ после $\alpha$.

Аналогично:
\[\alpha \circ F\]
это горизонтальная композиция $\alpha$ после $1_F$.

\section{Заключение}

Это завершает первую часть книги. Мы выучили базовый
словарь теории категорий. Вы можете думать об объектах и категориях
как о существительных; а о морфизмах, функторах и естественных преобразованиях как о глаголах.
Морфизмы соединяют объекты, функторы соединяют категории, естественные
преобразования соединяют функторы.

Но мы также видели, что то, что выглядит как действие на одном уровне
абстракции, становится объектом на следующем уровне. Множество морфизмов
превращается в объект-функцию. Как объект, он может быть источником или
целью другого морфизма. Это идея, лежащая в основе функций высшего
порядка.

Функтор отображает объекты в объекты, поэтому мы можем использовать его как
конструктор типа, или параметрический тип. Функтор также отображает морфизмы, поэтому он
является функцией высшего порядка --- \code{fmap}. Есть несколько простых
функторов, таких как \code{Const}, произведение и копроизведение, которые могут быть использованы
для генерации большого разнообразия алгебраических типов данных. Типы функций
также функториальны, как ковариантно, так и контравариантно, и могут быть использованы для
расширения алгебраических типов данных.

Функторы могут рассматриваться как объекты в категории функторов. Как таковые,
они становятся источниками и целями морфизмов: естественных преобразований.
Естественное преобразование --- это специальный тип полиморфной функции.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Определите естественное преобразование из функтора \code{Maybe} в
        функтор списка. Докажите условие естественности для него.
  \item
        Определите хотя бы два разных естественных преобразования между
        \code{Reader ()} и функтором списка. Сколько существует различных списков из
        \code{()}?
  \item
        Продолжите предыдущее упражнение с \code{Reader Bool} и
        \code{Maybe}.
  \item
        Покажите, что горизонтальная композиция естественных преобразований удовлетворяет
        условию естественности (подсказка: используйте компоненты). Это хорошее упражнение
        в погоне за диаграммами.
  \item
        Напишите короткое эссе о том, как вы можете получить удовольствие от записи очевидных
        диаграмм, необходимых для доказательства закона взаимозаменяемости.
  \item
        Создайте несколько тестовых случаев для противоположного условия естественности
        преобразований между разными функторами \code{Op}. Вот один
        выбор:

        \begin{snip}{haskell}
op :: Op Bool Int
op = Op (\x -> x > 0)
\end{snip}
        и

        \begin{snip}{haskell}
f :: String -> Int
f x = read x
\end{snip}
\end{enumerate}
