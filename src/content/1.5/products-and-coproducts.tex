% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{Д}{ревнегреческий} драматург Еврипид однажды сказал: ``Каждый человек подобен
компании, которую он обычно держит.'' Мы определяемся нашими отношениями.
Нигде это не более верно, чем в теории категорий. Если мы хотим выделить
конкретный объект в категории, мы можем сделать это только, описав
его паттерн отношений с другими объектами (и самим собой). Эти
отношения определяются морфизмами.

Существует общая конструкция в теории категорий, называемая
\newterm{универсальная конструкция}, для определения объектов в терминах их
отношений. Один способ сделать это --- выбрать паттерн, конкретную
форму, построенную из объектов и морфизмов, и искать все её
вхождения в категории. Если это достаточно распространённый паттерн, и
категория большая, шансы, что у вас будет много и много совпадений. 
Хитрость в том, чтобы установить какой-то рейтинг среди этих совпадений и выбрать
то, что можно считать лучшим соответствием.

Этот процесс напоминает способ, которым мы выполняем веб-поиски. Запрос ---
это как паттерн. Очень общий запрос даст вам большую \emph{полноту}:
много совпадений. Некоторые могут быть релевантны, другие нет. Чтобы исключить нерелевантные
совпадения, вы уточняете свой запрос. Это увеличивает его \emph{точность}.
Наконец, поисковая система ранжирует совпадения и, надеюсь, тот
результат, который вас интересует, будет на вершине списка.

\section{Начальный объект}

Простейшая форма --- это единственный объект. Очевидно, что существует столько же
экземпляров этой формы, сколько объектов в данной категории. Это
много для выбора. Нам нужно установить какой-то рейтинг и попытаться
найти объект, который возглавляет эту иерархию. Единственное средство в нашем
распоряжении --- это морфизмы. Если вы думаете о морфизмах как о стрелках, то возможно,
что существует общий чистый поток стрелок от одного конца
категории к другому. Это верно в упорядоченных категориях, например, в
частичных порядках. Мы могли бы обобщить это понятие старшинства объекта,
сказав, что объект $a$ ``более начальный'', чем объект $b$, если
существует стрелка (морфизм), идущая из $a$ в $b$. Мы бы тогда
определили \emph{начальный} объект как тот, который имеет стрелки, идущие ко
всем другим объектам. Очевидно, нет гарантии, что такой объект
существует, и это нормально. Большая проблема в том, что может быть слишком много
таких объектов: полнота хорошая, но точность отсутствует. Решение ---
взять подсказку из упорядоченных категорий --- они допускают не более одной
стрелки между любыми двумя объектами: есть только один способ быть меньше, чем
или равным другому объекту. Что приводит нас к этому определению
начального объекта:

\begin{quote}
  \textbf{Начальный объект} --- это объект, который имеет один и только один
  морфизм, идущий к любому объекту в категории.
\end{quote}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/initial.jpg}
\end{figure}

\noindent
Однако даже это не гарантирует уникальность начального
объекта (если он существует). Но это гарантирует следующую лучшую вещь:
уникальность \newterm{с точностью до изоморфизма}. Изоморфизмы очень важны в
теории категорий, поэтому я вскоре поговорю о них. Пока давайте просто
согласимся, что уникальность с точностью до изоморфизма оправдывает использование ``начальный'' в
определении начального объекта.

Вот некоторые примеры: начальный объект в частично упорядоченном множестве
(часто называемом \newterm{poset}) --- это его наименьший элемент. Некоторые posets не
имеют начального объекта --- как множество всех целых чисел, положительных и
отрицательных, с отношением меньше-или-равно для морфизмов.

В категории множеств и функций начальный объект --- это пустое
множество. Помните, пустое множество соответствует типу Haskell
\code{Void} (нет соответствующего типа в C++), а уникальная
полиморфная функция из \code{Void} в любой другой тип называется
\code{absurd}:

\src{snippet01}
Именно это семейство морфизмов делает \code{Void} начальным
объектом в категории типов.

\section{Терминальный объект}

Давайте продолжим с паттерном одного объекта, но давайте изменим способ,
которым мы ранжируем объекты. Мы скажем, что объект $a$ ``более терминальный'',
чем объект $b$, если существует морфизм, идущий из $b$ в
$a$ (обратите внимание на обращение направления). Мы будем искать
объект, который более терминальный, чем любой другой объект в категории.
Снова мы будем настаивать на уникальности:

\begin{quote}
  \textbf{Терминальный объект} --- это объект с одним и только одним
  морфизмом, приходящим к нему из любого объекта в категории.
\end{quote}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/final.jpg}
\end{figure}

\noindent
И снова терминальный объект уникален с точностью до изоморфизма, что я
покажу вскоре. Но сначала давайте посмотрим на некоторые примеры. В poset
терминальный объект, если он существует, --- это самый большой объект. В
категории множеств терминальный объект --- это синглетон. Мы уже
говорили о синглетонах --- они соответствуют типу \code{void} в
C++ и типу unit \code{()} в Haskell. Это тип, который имеет только
одно значение --- неявное в C++ и явное в Haskell, обозначаемое как
\code{()}. Мы также установили, что существует одна и только одна чистая
функция из любого типа в тип unit:

\src{snippet02}
так что все условия для терминального объекта удовлетворены.

Обратите внимание, что в этом примере условие уникальности критично, потому что
есть другие множества (на самом деле, все они, за исключением пустого множества),
которые имеют входящие морфизмы из каждого множества. Например, есть
функция, возвращающая Boolean (предикат), определённая для каждого типа:

\src{snippet03}
Но \code{Bool} не является терминальным объектом. Есть как минимум ещё одна
функция, возвращающая \code{Bool}, из каждого типа (за исключением \code{Void}, для которого обе функции равны \code{absurd}):

\src{snippet04}
Настаивание на уникальности даёт нам именно ту точность, чтобы сузить
определение терминального объекта до одного типа.

\section{Двойственность}

Вы не можете не заметить симметрию между тем, как мы определили
начальный объект и терминальный объект. Единственная разница между
ними была направление морфизмов. Оказывается, что для любой категории $\cat{C}$
мы можем определить \newterm{противоположную категорию} $\cat{C}^\mathit{op}$ просто
обратив все стрелки. Противоположная категория автоматически удовлетворяет
всем требованиям категории, если мы одновременно
переопределим композицию. Если исходные морфизмы
$f \Colon a \to b$ и $g \Colon b \to c$ композировались
в $h \Colon a \to c$ с $h = g \circ f$, то обращённые
морфизмы $f^\mathit{op} \Colon b \to a$ и $g^\mathit{op} \Colon c \to b$ будут композироваться в
$h^\mathit{op} \Colon c \to a$ с $h^\mathit{op} = f^\mathit{op} \circ g^\mathit{op}$. И обращение
тождественных стрелок --- это (каламбур!) no-op.

Двойственность --- это очень важное свойство категорий, потому что оно удваивает
производительность каждого математика, работающего в теории категорий. Для
каждой конструкции, которую вы придумываете, существует её противоположность; и для
каждой теоремы, которую вы доказываете, вы получаете одну бесплатно. Конструкции в
противоположной категории часто префиксированы ``ко'', так что у вас есть произведения
и копроизведения, монады и комонады, конусы и коконусы, пределы и
копределы и так далее. Нет кокомонад, однако, потому что обращение
стрелок дважды возвращает нас в исходное состояние.

Отсюда следует, что терминальный объект --- это начальный объект в
противоположной категории.

\section{Изоморфизмы}

Как программисты, мы хорошо знаем, что определение равенства --- это нетривиальная
задача. Что означает для двух объектов быть равными? Должны ли они
занимать одно и то же место в памяти (равенство указателей)? Или достаточно,
чтобы значения всех их компонентов были равны? Равны ли два комплексных
числа, если одно выражено как действительная и мнимая часть, а
другое как модуль и угол? Вы бы подумали, что математики
выяснили значение равенства, но они не выяснили. У них
та же проблема множественных конкурирующих определений равенства. Есть
пропозициональное равенство, интенсиональное равенство, экстенсиональное
равенство и равенство как путь в гомотопической теории типов. А затем есть
более слабые понятия изоморфизма и даже более слабые эквивалентности.

Интуиция в том, что изоморфные объекты выглядят одинаково --- они имеют
одинаковую форму. Это означает, что каждая часть одного объекта соответствует некоторой
части другого объекта во взаимно однозначном отображении. Насколько могут сказать наши
инструменты, два объекта --- это идеальная копия друг друга.
Математически это означает, что существует отображение из объекта $a$ в
объект $b$, и существует отображение из объекта $b$ обратно в
объект $a$, и они являются обратными друг другу. В теории
категорий мы заменяем отображения морфизмами. Изоморфизм --- это
обратимый морфизм; или пара морфизмов, один из которых является обратным
другого.

Мы понимаем обратное в терминах композиции и тождества: Морфизм
$g$ является обратным морфизма $f$, если их композиция --- это
тождественный морфизм. Это фактически два уравнения, потому что есть
два способа скомпозировать два морфизма:

\src{snippet05}
Когда я сказал, что начальный (терминальный) объект уникален с точностью до
изоморфизма, я имел в виду, что любые два начальных (терминальных) объекта
изоморфны. Это фактически легко увидеть. Предположим, что у нас есть два
начальных объекта $i_{1}$ и $i_{2}$. Поскольку
$i_{1}$ начальный, существует уникальный морфизм $f$ из
$i_{1}$ в $i_{2}$. По тому же токену, поскольку
$i_{2}$ начальный, существует уникальный морфизм $g$ из
$i_{2}$ в $i_{1}$. Какова композиция
этих двух морфизмов?

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/uniqueness.jpg}
  \caption{Все морфизмы на этой диаграмме уникальны.}
\end{figure}

\noindent
Композиция $g \circ f$ должна быть морфизмом из $i_{1}$ в
$i_{1}$. Но $i_{1}$ начальный, поэтому может быть только
один морфизм, идущий из $i_{1}$ в $i_{1}$.
Поскольку мы находимся в категории, мы знаем, что существует тождественный морфизм
из $i_{1}$ в $i_{1}$, и поскольку есть место
только для одного, это должен быть он. Следовательно, $g \circ f$ равно
тождеству. Аналогично, $f \circ g$ должно быть равно тождеству, потому что может
быть только один морфизм из $i_{2}$ обратно в
$i_{2}$. Это доказывает, что $f$ и $g$ должны быть
обратными друг другу. Следовательно, любые два начальных объекта изоморфны.

Обратите внимание, что в этом доказательстве мы использовали уникальность морфизма из
начального объекта в себя. Без этого мы не могли бы доказать часть ``с точностью до
изоморфизма''. Но зачем нам нужна уникальность $f$ и
$g$? Потому что не только начальный объект уникален с точностью до
изоморфизма, он уникален с точностью до \emph{уникального} изоморфизма. В принципе
может быть более одного изоморфизма между двумя объектами, но это не
случай здесь. Эта ``уникальность с точностью до уникального изоморфизма'' ---
важное свойство всех универсальных конструкций.

\section{Произведения}

Следующая универсальная конструкция --- это произведение. Мы знаем, что такое
декартово произведение двух множеств: это множество пар. Но каков
паттерн, который соединяет множество-произведение с его составляющими множествами? Если мы
можем это выяснить, мы сможем обобщить это на другие категории.

Всё, что мы можем сказать, --- это что существуют две функции, проекции, из
произведения в каждую из составляющих. В Haskell эти две функции
называются \code{fst} и \code{snd}, и они выбирают, соответственно,
первый и второй компонент пары:

\src{snippet06}

\src{snippet07}
Здесь функции определены путём сопоставления с образцом их аргументов:
образец, который соответствует любой паре, --- это \code{(x, y)}, и он извлекает её
компоненты в переменные \code{x} и \code{y}.

Эти определения можно ещё больше упростить с использованием
подстановочных знаков:

\src{snippet08}
В C++ мы бы использовали шаблонные функции, например:

\begin{snip}{cpp}
template<class A, class B> A
fst(pair<A, B> const & p) {
    return p.first;
}
\end{snip}
Вооружившись этими, казалось бы, очень ограниченными знаниями, давайте попытаемся определить
паттерн объектов и морфизмов в категории множеств, который
приведёт нас к конструкции произведения двух множеств, $a$ и
$b$. Этот паттерн состоит из объекта $c$ и двух морфизмов
$p$ и $q$, соединяющих его с $a$ и $b$,
соответственно:

\src{snippet09}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/productpattern.jpg}
\end{figure}

\noindent
Все $c$, которые подходят под этот паттерн, будут считаться кандидатами для
произведения. Их может быть много.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/productcandidates.jpg}
\end{figure}

\noindent
Например, давайте выберем в качестве наших составляющих два типа Haskell,
\code{Int} и \code{Bool}, и получим выборку кандидатов для
их произведения.

Вот один: \code{Int}. Может ли \code{Int} считаться кандидатом для
произведения \code{Int} и \code{Bool}? Да, может --- и вот
его проекции:

\src{snippet10}
Это довольно жалко, но оно соответствует критериям.

Вот другой: \code{(Int, Int, Bool)}. Это кортеж из трёх
элементов, или тройка. Вот два морфизма, которые делают его легитимным
кандидатом (мы используем сопоставление с образцом на тройках):

\src{snippet11}
Вы могли заметить, что в то время как наш первый кандидат был слишком мал --- он
покрывал только измерение \code{Int} произведения; второй был
слишком велик --- он ложно дублировал измерение \code{Int}.

Но мы ещё не исследовали другую часть универсальной
конструкции: ранжирование. Мы хотим иметь возможность сравнивать два экземпляра
нашего паттерна. Мы хотим сравнить один кандидат объект $c$ и его
две проекции $p$ и $q$ с другим кандидатом объектом
$c'$ и его двумя проекциями $p'$ и $q'$. Мы хотели бы
сказать, что $c$ ``лучше'', чем $c'$, если существует морфизм
$m$ из $c'$ в $c$ --- но это слишком слабо. Мы также
хотим, чтобы его проекции были ``лучше'' или ``более универсальны'', чем
проекции $c'$. Что это означает, так это то, что проекции
$p'$ и $q'$ могут быть реконструированы из $p$ и $q$, используя $m$:

\src{snippet12}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/productranking.jpg}
\end{figure}

\noindent
Другой способ взглянуть на эти уравнения --- это что $m$
\emph{факторизует} $p'$ и $q'$. Просто представьте, что эти
уравнения в натуральных числах, и точка --- это умножение:
$m$ --- это общий фактор, разделяемый $p'$ и $q'$.

Просто для построения некоторой интуиции позвольте мне показать вам, что пара
\code{(Int, Bool)} с двумя каноническими проекциями, \code{fst}
и \code{snd}, действительно \emph{лучше}, чем два кандидата, которые я
представил ранее.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/not-a-product.jpg}
\end{figure}

\noindent
Отображение \code{m} для первого кандидата:

\src{snippet13}
Действительно, две проекции, \code{p} и \code{q}, могут быть
реконструированы как:

\src{snippet14}
\code{m} для второго примера аналогично уникально определён:

\src{snippet15}
Мы смогли показать, что \code{(Int, Bool)} лучше, чем любой из
двух кандидатов. Давайте посмотрим, почему обратное не верно. Могли бы мы
найти некоторый \code{m'}, который помог бы нам реконструировать \code{fst}
и \code{snd} из \code{p} и \code{q}?

\src{snippet16}
В нашем первом примере \code{q} всегда возвращал \code{True}, и мы
знаем, что есть пары, второй компонент которых \code{False}. Мы
не можем реконструировать \code{snd} из \code{q}.

Второй пример другой: мы сохраняем достаточно информации после
запуска либо \code{p}, либо \code{q}, но есть более одного способа
факторизовать \code{fst} и \code{snd}. Поскольку и \code{p}, и
\code{q} игнорируют второй компонент тройки, наш \code{m'}
может поместить в него что угодно. Мы можем иметь:

\src{snippet17}

или
\src{snippet18}
и так далее.

Собирая всё вместе, для любого типа \code{c} с двумя проекциями
\code{p} и \code{q} существует уникальный \code{m} из \code{c}
в декартово произведение \code{(a, b)}, которое факторизует их. На самом деле
он просто комбинирует \code{p} и \code{q} в пару.

\src{snippet19}
Это делает декартово произведение \code{(a, b)} нашим лучшим соответствием, что
означает, что эта универсальная конструкция работает в категории множеств. Она
выбирает произведение любых двух множеств.

Теперь давайте забудем о множествах и определим произведение двух объектов в любой
категории, используя ту же универсальную конструкцию. Такое произведение не
всегда существует, но когда существует, оно уникально с точностью до уникального изоморфизма.

\begin{quote}
  \textbf{Произведение} двух объектов $a$ и $b$ --- это объект
  $c$, оснащённый двумя проекциями, такой что для любого другого объекта
  $c'$, оснащённого двумя проекциями, существует уникальный морфизм
  $m$ из $c'$ в $c$, который факторизует эти проекции.
\end{quote}

\noindent
Функция (высшего порядка), которая производит факторизующую функцию
\code{m} из двух кандидатов, иногда называется
\newterm{факторизатор}. В нашем случае это будет функция:

\src{snippet20}

\section{Копроизведение}

Как и каждая конструкция в теории категорий, произведение имеет двойственное,
которое называется копроизведение. Когда мы обращаем стрелки в паттерне произведения,
мы получаем объект $c$, оснащённый двумя
\emph{инъекциями}, \code{i} и \code{j}: морфизмами из $a$
и $b$ в $c$.

\src{snippet21}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/coproductpattern.jpg}
\end{figure}

\noindent
Ранжирование также инвертировано: объект $c$ ``лучше'', чем объект
$c'$, который оснащён инъекциями $i'$ и $j'$,
если существует морфизм $m$ из $c$ в $c'$, который
факторизует инъекции:

\src{snippet22}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/coproductranking.jpg}
\end{figure}

\noindent
``Лучший'' такой объект, тот, у которого есть уникальный морфизм, соединяющий его с
любым другим паттерном, называется копроизведением, и, если он существует, уникален с точностью
до уникального изоморфизма.

\begin{quote}
  \textbf{Копроизведение} двух объектов $a$ и $b$ --- это объект
  $c$, оснащённый двумя инъекциями, такой что для любого другого объекта
  $c'$, оснащённого двумя инъекциями, существует уникальный морфизм
  $m$ из $c$ в $c'$, который факторизует эти инъекции.
\end{quote}

\noindent
В категории множеств копроизведение --- это \emph{дизъюнктное объединение}
двух множеств. Элемент дизъюнктного объединения $a$ и $b$ ---
это либо элемент $a$, либо элемент $b$. Если два множества
перекрываются, дизъюнктное объединение содержит две копии общей части. Вы
можете думать об элементе дизъюнктного объединения как о помеченном
идентификатором, который указывает его происхождение.

Для программиста легче понять копроизведение в терминах
типов: это помеченное объединение двух типов. C++ поддерживает объединения, но они
не помечены. Это означает, что в вашей программе вы должны как-то отслеживать,
какой член объединения действителен. Чтобы создать помеченное объединение, вы
должны определить тег --- перечисление --- и объединить его с
объединением. Например, помеченное объединение \code{int} и
\code{char const *} может быть реализовано как:

\begin{snip}{cpp}
struct Contact {
    enum { isPhone, isEmail } tag;
    union { int phoneNum; char const * emailAddr; };
};
\end{snip}
Две инъекции могут быть реализованы либо как конструкторы, либо как
функции. Например, вот первая инъекция как функция
\code{PhoneNum}:

\begin{snip}{cpp}
Contact PhoneNum(int n) {
    Contact c;
    c.tag = isPhone;
    c.phoneNum = n;
    return c;
}
\end{snip}
Она инъецирует целое число в \code{Contact}.

Помеченное объединение также называется \newterm{вариант}, и есть очень
общая реализация варианта в библиотеке boost,
\code{boost::variant}.

В Haskell вы можете объединить любые типы данных в помеченное объединение,
разделяя конструкторы данных вертикальной чертой. Пример \code{Contact}
переводится в объявление:

\src{snippet23}
Здесь \code{PhoneNum} и \code{EmailAddr} служат и как
конструкторы (инъекции), и как теги для сопоставления с образцом (подробнее об
этом позже). Например, вот как вы бы сконструировали контакт,
используя номер телефона:

\src{snippet24}
В отличие от канонической реализации произведения, которая встроена в
Haskell как примитивная пара, каноническая реализация
копроизведения --- это тип данных, называемый \code{Either}, который определён в
стандартном Prelude как:

\src{snippet25}
Он параметризован двумя типами, \code{a} и \code{b}, и имеет два
конструктора: \code{Left}, который принимает значение типа \code{a}, и
\code{Right}, который принимает значение типа \code{b}.

Так же, как мы определили факторизатор для произведения, мы можем определить его
для копроизведения. Для данного типа-кандидата \code{c} и двух инъекций-кандидатов
\code{i} и \code{j} факторизатор для \code{Either}
производит факторизующую функцию:

\src{snippet26}

\section{Асимметрия}

Мы видели два набора двойственных определений: определение терминального
объекта может быть получено из определения начального объекта
обращением направления стрелок; аналогичным образом, определение
копроизведения может быть получено из определения произведения. Тем не менее в
категории множеств начальный объект очень отличается от финального
объекта, и копроизведение очень отличается от произведения. Мы увидим позже,
что произведение ведёт себя как умножение, с терминальным объектом,
играющим роль единицы; тогда как копроизведение ведёт себя больше как сумма,
с начальным объектом, играющим роль нуля. В частности, для
конечных множеств размер произведения --- это произведение размеров
отдельных множеств, а размер копроизведения --- это сумма размеров.

Это показывает, что категория множеств не симметрична относительно
инверсии стрелок.

Обратите внимание, что в то время как пустое множество имеет уникальный морфизм в любое множество (функция
\code{absurd}), у него нет морфизмов, возвращающихся. Одноэлементное
множество имеет уникальный морфизм, приходящий к нему из любого множества, но оно
\emph{также} имеет исходящие морфизмы в каждое множество (за исключением пустого).
Как мы видели ранее, эти исходящие морфизмы из терминального
объекта играют очень важную роль выбора элементов других множеств (пустое
множество не имеет элементов, так что нечего выбирать).

Именно отношение одноэлементного множества к произведению выделяет его
из копроизведения. Рассмотрим использование одноэлементного множества, представленного
типом unit \code{()}, как ещё один --- значительно более слабый ---
кандидат для паттерна произведения. Оснастим его двумя проекциями
\code{p} и \code{q}: функциями из синглетона в каждое из
составляющих множеств. Каждая выбирает конкретный элемент из любого множества.
Поскольку произведение универсально, также есть (уникальный) морфизм
\code{m} из нашего кандидата, синглетона, в произведение. Этот
морфизм выбирает элемент из множества-произведения --- он выбирает
конкретную пару. Он также факторизует две проекции:

\src{snippet27}
Когда действуют на одноэлементном значении \code{()}, единственном элементе
одноэлементного множества, эти два уравнения становятся:

\src{snippet28}
Поскольку \code{m ()} --- это элемент произведения, выбранный \code{m},
эти уравнения говорят нам, что элемент, выбранный \code{p} из
первого множества, \code{p ()}, --- это первый компонент пары, выбранной
\code{m}. Аналогично, \code{q ()} равно второму компоненту.
Это полностью согласуется с нашим пониманием, что элементы
произведения --- это пары элементов из составляющих множеств.

Нет такой простой интерпретации копроизведения. Мы могли бы попробовать
одноэлементное множество как кандидат для копроизведения в попытке
извлечь элементы из него, но там у нас были бы две инъекции,
идущие в него, а не две проекции, выходящие из него. Они бы
ничего не сказали нам об их источниках (на самом деле, мы видели, что они игнорируют
входной параметр). Ни уникальный морфизм из копроизведения
в наш синглетон. Категория множеств просто выглядит очень по-разному, когда
видна из направления начального объекта, чем когда видна
с терминального конца.

Это не внутреннее свойство множеств, это свойство функций,
которые мы используем как морфизмы в $\Set$. Функции, в общем,
асимметричны. Позвольте мне объяснить.

Функция должна быть определена для каждого элемента своей области определения (в
программировании мы называем это \newterm{тотальная} функция), но она не должна
покрывать весь кодомен. Мы видели некоторые экстремальные случаи: функции
из одноэлементного множества --- функции, которые выбирают только один элемент в
кодомене. (На самом деле, функции из пустого множества --- настоящие
экстремумы.) Когда размер домена намного меньше размера
кодомена, мы часто думаем о таких функциях как о встраивании домена
в кодомен. Например, мы можем думать о функции из
одноэлементного множества как о встраивании его единственного элемента в кодомен. Я называю
их \newterm{встраивающие} функции, но математики предпочитают давать
имя противоположному: функции, которые плотно заполняют свои кодомены,
называются \newterm{сюръективными} или \newterm{на}.

Другой источник асимметрии --- то, что функциям разрешено отображать много
элементов домена в один элемент кодомена. Они могут
их схлопывать. Экстремальный случай --- это функции, которые отображают целые множества в
синглетон. Вы видели полиморфную функцию \code{unit}, которая делает
именно это. Схлопывание может только усиливаться композицией.
Композиция двух схлопывающих функций ещё более схлопывающая, чем
отдельные функции. Математики имеют название для несхлопывающих
функций: они называют их \newterm{инъективными} или \newterm{один-к-одному}.

Конечно, есть некоторые функции, которые не являются ни встраивающими, ни
схлопывающими. Они называются \newterm{биекции}, и они действительно
симметричны, потому что они обратимы. В категории множеств
изоморфизм --- это то же самое, что биекция.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Покажите, что терминальный объект уникален с точностью до уникального изоморфизма.
  \item
        Что является произведением двух объектов в poset? Подсказка: используйте универсальную
        конструкцию.
  \item
        Что является копроизведением двух объектов в poset?
  \item
        Реализуйте эквивалент Haskell \code{Either} как обобщённый тип
        на вашем любимом языке (отличном от Haskell).
  \item
        Покажите, что \code{Either} --- это ``лучшее'' копроизведение, чем \code{int},
        оснащённый двумя инъекциями:

        \begin{snip}{cpp}
int i(int n) { return n; }
int j(bool b) { return b ? 0: 1; }
\end{snip}

        Подсказка: Определите функцию

        \begin{snip}{cpp}
int m(Either const & e);
\end{snip}

        которая факторизует \code{i} и \code{j}.
  \item
        Продолжая предыдущую проблему: Как бы вы аргументировали, что \code{int}
        с двумя инъекциями \code{i} и \code{j} не может быть ``лучше'',
        чем \code{Either}?
  \item
        Всё ещё продолжая: А как насчёт этих инъекций?

        \begin{snip}{cpp}
int i(int n) {
    if (n < 0) return n;
    return n + 2;
}

int j(bool b) { return b ? 0: 1; }
\end{snip}
  \item
        Придумайте более слабый кандидат для копроизведения \code{int} и
        \code{bool}, который не может быть лучше, чем \code{Either}, потому что он
        допускает несколько приемлемых морфизмов из него в \code{Either}.
\end{enumerate}

\section{Библиография}

\begin{enumerate}
  \tightlist
  \item
        The Catsters,
        \urlref{https://www.youtube.com/watch?v=upCSDIO9pjc}{Products and
          Coproducts} видео.
\end{enumerate}
