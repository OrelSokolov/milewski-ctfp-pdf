% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{Р}{искуя прозвучать} как заезженная пластинка, я скажу о функторах следующее: функтор — это очень простая, но мощная идея. Теория категорий просто полна такими простыми, но мощными идеями. Функтор — это отображение между категориями. Для двух категорий $\cat{C}$ и $\cat{D}$ функтор $F$ отображает объекты в $\cat{C}$ в объекты в $\cat{D}$ — это функция на объектах. Если $a$ — объект в $\cat{C}$, мы запишем его образ в $\cat{D}$ как $F a$ (без скобок). Но категория — это не только объекты — это объекты и морфизмы, которые их связывают. Функтор также отображает морфизмы — это функция на морфизмах. Но он отображает морфизмы не как попало — он сохраняет связи. Так что если морфизм $f$ в $\cat{C}$ связывает объект $a$ с объектом $b$,
\[f \Colon a \to b\]
образ $f$ в $\cat{D}$, $F f$, будет связывать образ $a$ с образом $b$:
\[F f \Colon F a \to F b\]

(Это смесь математических и Haskell-ных обозначений, которая, надеюсь, уже имеет смысл. Я не буду использовать скобки при применении функторов к объектам или морфизмам.)

\begin{figure}[H]
  \centering\includegraphics[width=0.3\textwidth]{images/functor.jpg}
\end{figure}

\noindent
Как видите, функтор сохраняет структуру категории: то, что связано в одной категории, будет связано и в другой. Но в структуре категории есть нечто большее: есть также композиция морфизмов. Если $h$ — это композиция $f$ и $g$:
\[h = g \circ f\]
мы хотим, чтобы его образ под действием $F$ был композицией образов $f$ и $g$:
\[F h = F g \circ F f\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/functorcompos.jpg}
\end{figure}

\noindent
Наконец, мы хотим, чтобы все тождественные морфизмы в $\cat{C}$ отображались в тождественные морфизмы в $\cat{D}$:
\[F \idarrow[a] = \idarrow[F a]\]

\noindent
Здесь $\idarrow[a]$ — тождественный морфизм на объекте $a$, а $\idarrow[F a]$ — тождественный морфизм на $F a$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/functorid.jpg}
\end{figure}

\noindent
Заметьте, что эти условия делают функторы гораздо более ограниченными, чем обычные функции. Функторы должны сохранять структуру категории. Если представить категорию как коллекцию объектов, соединённых сетью морфизмов, то функтору не позволено разрывать эту ткань. Он может склеивать объекты, может склеивать несколько морфизмов в один, но он никогда не может разрывать вещи на части. Это ограничение «без разрывов» похоже на условие непрерывности, которое вы можете знать из математического анализа. В этом смысле функторы «непрерывны» (хотя существует ещё более ограничительное понятие непрерывности для функторов). Так же, как и функции, функторы могут делать и схлопывание, и вложение. Аспект вложения более заметен, когда исходная категория намного меньше целевой. В крайнем случае, исходной может быть тривиальная синглтонная категория — категория с одним объектом и одним морфизмом (тождественным). Функтор из синглтонной категории в любую другую категорию просто выбирает объект в этой категории. Это полностью аналогично свойству морфизмов из синглтонных множеств выбирать элементы в целевых множествах. Максимально схлопывающий функтор называется постоянным функтором $\Delta_c$. Он отображает каждый объект исходной категории в один выбранный объект $c$ в целевой категории. Он также отображает каждый морфизм исходной категории в тождественный морфизм $\idarrow[c]$. Он ведёт себя как чёрная дыра, уплотняя всё в одну сингулярность. Мы увидим больше этого функтора, когда будем обсуждать пределы и копределы.

\section{Функторы в программировании}

Давайте спустимся на землю и поговорим о программировании. У нас есть наша категория типов и функций. Мы можем говорить о функторах, которые отображают эту категорию в себя — такие функторы называются эндофункторами. Так что же такое эндофунктор в категории типов? Прежде всего, он отображает типы в типы. Мы видели примеры таких отображений, возможно, не осознавая, что это именно они. Я говорю об определениях типов, которые были параметризованы другими типами. Давайте рассмотрим несколько примеров.

\subsection{Функтор Maybe}

Определение \code{Maybe} — это отображение из типа \code{a} в тип \code{Maybe a}:

\src{snippet01}
Вот важная тонкость: \code{Maybe} сам по себе не тип, это \emph{конструктор типа}. Вы должны дать ему аргумент типа, например \code{Int} или \code{Bool}, чтобы превратить его в тип. \code{Maybe} без какого-либо аргумента представляет функцию на типах. Но можем ли мы превратить \code{Maybe} в функтор? (Отныне, когда я говорю о функторах в контексте программирования, я почти всегда буду иметь в виду эндофункторы.) Функтор — это не только отображение объектов (здесь, типов), но и отображение морфизмов (здесь, функций). Для любой функции из \code{a} в \code{b}:

\src{snippet02}
мы хотели бы получить функцию из \code{Maybe a} в \code{Maybe b}. Чтобы определить такую функцию, у нас будет два случая для рассмотрения, соответствующих двум конструкторам \code{Maybe}. Случай \code{Nothing} прост: мы просто вернём \code{Nothing} обратно. И если аргумент — это \code{Just}, мы применим функцию \code{f} к его содержимому. Так что образ \code{f} под действием \code{Maybe} — это функция:

\src{snippet03}
(Кстати, в Haskell вы можете использовать апострофы в именах переменных, что очень удобно в таких случаях.) В Haskell мы реализуем часть функтора, отображающую морфизмы, как функцию высшего порядка под названием \code{fmap}. В случае \code{Maybe} она имеет следующую сигнатуру:

\src{snippet04}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/functormaybe.jpg}
\end{figure}

\noindent
Мы часто говорим, что \code{fmap} \emph{поднимает} функцию. Поднятая функция действует на значения \code{Maybe}. Как обычно, из-за каррирования эту сигнатуру можно интерпретировать двумя способами: как функцию одного аргумента — которая сама является функцией \code{(a -> b)} — возвращающую функцию \code{(Maybe a -> Maybe b)}; или как функцию двух аргументов, возвращающую \code{Maybe b}:

\src{snippet05}
Основываясь на нашем предыдущем обсуждении, вот как мы реализуем \code{fmap} для \code{Maybe}:

\src{snippet06}
Чтобы показать, что конструктор типа \code{Maybe} вместе с функцией \code{fmap} образуют функтор, мы должны доказать, что \code{fmap} сохраняет тождество и композицию. Это называется «законами функтора», но они просто обеспечивают сохранение структуры категории.

\subsection{Уравнительные рассуждения}

Чтобы доказать законы функтора, я буду использовать \newterm{уравнительные рассуждения}, что является распространённой техникой доказательства в Haskell. Она использует тот факт, что функции в Haskell определены как равенства: левая часть равна правой части. Вы всегда можете подставить одну вместо другой, возможно, переименовывая переменные, чтобы избежать конфликтов имён. Думайте об этом как о встраивании функции или, наоборот, рефакторинге выражения в функцию. Возьмём в качестве примера тождественную функцию:

\src{snippet07}
Если вы видите, например, \code{id y} в каком-то выражении, вы можете заменить его на \code{y} (встраивание). Далее, если вы видите \code{id}, применённую к выражению, скажем \code{id (y + 2)}, вы можете заменить её на само выражение \code{(y + 2)}. И эта подстановка работает в обе стороны: вы можете заменить любое выражение \code{e} на \code{id e} (рефакторинг). Если функция определена через сопоставление с образцом, вы можете использовать каждое подопределение независимо. Например, учитывая приведённое выше определение \code{fmap}, вы можете заменить \code{fmap f Nothing} на \code{Nothing}, или наоборот. Давайте посмотрим, как это работает на практике. Начнём с сохранения тождества:

\src{snippet08}
Есть два случая для рассмотрения: \code{Nothing} и \code{Just}. Вот первый случай (я использую Haskell-псевдокод для преобразования левой части в правую):

\begin{snip}{haskell}
  fmap id Nothing
= { определение fmap }
  Nothing
= { определение id }
  id Nothing
\end{snip}
Заметьте, что на последнем шаге я использовал определение \code{id} в обратную сторону. Я заменил выражение \code{Nothing} на \code{id\ Nothing}. На практике вы проводите такие доказательства, «сжигая свечу с обоих концов», пока не получите одно и то же выражение посередине — здесь это было \code{Nothing}. Второй случай тоже прост:

\begin{snip}{haskell}
  fmap id (Just x)
= { определение fmap }
  Just (id x)
= { определение id }
  Just x
= { определение id }
  id (Just x)
\end{snip}
Теперь покажем, что \code{fmap} сохраняет композицию:

\src{snippet09}
Сначала случай \code{Nothing}:

\begin{snip}{haskell}
  fmap (g . f) Nothing
= { определение fmap }
  Nothing
= { определение fmap }
  fmap g Nothing
= { определение fmap }
  fmap g (fmap f Nothing)
\end{snip}
А затем случай \code{Just}:

\begin{snip}{haskell}
  fmap (g . f) (Just x)
= { определение fmap }
  Just ((g . f) x)
= { определение композиции }
  Just (g (f x))
= { определение fmap }
  fmap g (Just (f x))
= { определение fmap }
  fmap g (fmap f (Just x))
= { определение композиции }
  (fmap g . fmap f) (Just x)
\end{snip}
Стоит подчеркнуть, что уравнительные рассуждения не работают для «функций» в стиле C++ с побочными эффектами. Рассмотрим этот код:

\begin{snip}{cpp}
int square(int x) {
    return x * x;
}

int counter() {
    static int c = 0;
    return c++;
}

double y = square(counter());
\end{snip}
Используя уравнительные рассуждения, вы могли бы встроить \code{square} и получить:

\begin{snip}{cpp}
double y = counter() * counter();
\end{snip}
Это определенно не является допустимым преобразованием и не даст тот же результат. Несмотря на это, компилятор C++ попытается использовать уравнительные рассуждения, если вы реализуете \code{square} как макрос, с катастрофическими последствиями.

\subsection{Optional}

Функторы легко выражаются в Haskell, но они могут быть определены в любом языке, который поддерживает обобщённое программирование и функции высшего порядка. Рассмотрим аналог \code{Maybe} в C++, шаблонный тип \code{optional}. Вот набросок реализации (реальная реализация намного сложнее, dealing с различными способами передачи аргумента, с семантикой копирования и с проблемами управления ресурсами, характерными для C++):

\begin{snip}{cpp}
template<class T>
class optional {
    bool _isValid; // тег
    T _v;
public:
    optional()    : _isValid(false) {}        // Nothing
    optional(T x) : _isValid(true) , _v(x) {} // Just
    bool isValid() const { return _isValid; }
    T val() const { return _v; } };
\end{snip}
Этот шаблон предоставляет одну часть определения функтора: отображение типов. Он отображает любой тип \code{T} в новый тип \code{optional<T>}. Давайте определим его действие на функции:

\begin{snip}{cpp}
template<class A, class B>
std::function<optional<B>(optional<A>)>
fmap(std::function<B(A)> f) {
    return [f](optional<A> opt) {
        if (!opt.isValid())
            return optional<B>{};
        else
            return optional<B>{ f(opt.val()) };
    };
}
\end{snip}
Это функция высшего порядка, принимающая функцию как аргумент и возвращающая функцию. Вот неукарренная версия:

\begin{snip}{cpp}
template<class A, class B>
optional<B> fmap(std::function<B(A)> f, optional<A> opt) {
    if (!opt.isValid())
        return optional<B>{};
    else
        return optional<B>{ f(opt.val()) };
}
\end{snip}
Также есть вариант сделать \code{fmap} шаблонным методом \code{optional}. Это изобилие выбора делает абстрагирование паттерна функтора в C++ проблемой. Должен ли функтор быть интерфейсом для наследования (к сожалению, вы не можете иметь шаблонные виртуальные функции)? Должен ли это быть каррированный или неукарренный свободный шаблон функции? Может ли компилятор C++ правильно вывести отсутствующие типы, или они должны быть указаны явно? Рассмотрим ситуацию, когда входная функция \code{f} принимает \code{int} и возвращает \code{bool}. Как компилятор определит тип \code{g}:

\begin{snip}{cpp}
auto g = fmap(f);
\end{snip}
особенно если в будущем будет несколько функторов, перегружающих \code{fmap}? (Мы скоро увидим больше функторов.)

\subsection{Классы типов}

Так как же Haskell справляется с абстрагированием функтора? Он использует механизм классов типов. Класс типов определяет семейство типов, которые поддерживают общий интерфейс. Например, класс объектов, поддерживающих равенство, определяется следующим образом:

\src{snippet10}
Это определение утверждает, что тип \code{a} принадлежит классу \code{Eq}, если он поддерживает оператор \code{(==)}, который принимает два аргумента типа \code{a} и возвращает \code{Bool}. Если вы хотите сказать Haskell, что конкретный тип является \code{Eq}, вы должны объявить его \newterm{экземпляром} этого класса и предоставить реализацию \code{(==)}. Например, учитывая определение 2D \code{Point} (тип-произведение двух \code{Float}):

\src{snippet11}
вы можете определить равенство точек:

\src{snippet12}
Здесь я использовал оператор \code{(==)} (тот, который я определяю) в инфиксной позиции между двумя образцами \code{(Pt x y)} и \code{(Pt x' y')}. Тело функции следует после единственного знака равенства. Как только \code{Point} объявлен экземпляром \code{Eq}, вы можете напрямую сравнивать точки на равенство. Заметьте, что, в отличие от C++ или Java, вам не нужно указывать класс \code{Eq} (или интерфейс) при определении \code{Point} — вы можете сделать это позже в клиентском коде. Классы типов также являются единственным механизмом Haskell для перегрузки функций (и операторов). Нам это понадобится для перегрузки \code{fmap} для разных функторов. Однако есть одно осложнение: функтор определяется не как тип, а как отображение типов, конструктор типа. Нам нужен класс типов, который является не семейством типов, как в случае с \code{Eq}, а семейством конструкторов типов. К счастью, класс типов Haskell работает как с конструкторами типов, так и с типами. Так что вот определение класса \code{Functor}:

\src{snippet13}
Оно требует, чтобы \code{f} был \code{Functor}, если существует функция \code{fmap} с указанной сигнатурой типов. Строчная \code{f} — это переменная типа, похожая на переменные типа \code{a} и \code{b}. Однако компилятор способен вывести, что она представляет конструктор типа, а не тип, посмотрев на её использование: действие на другие типы, как в \code{f a} и \code{f b}. Соответственно, при объявлении экземпляра \code{Functor} вы должны указать конструктор типа, как в случае с \code{Maybe}:

\src{snippet14}
Кстати, класс \code{Functor}, а также определения его экземпляров для множества простых типов данных, включая \code{Maybe}, являются частью стандартной библиотеки Prelude.

\subsection{Функтор в C++}

Можем ли мы попробовать тот же подход в C++? Конструктор типа соответствует шаблонному классу, like \code{optional}, так что по аналогии мы параметризуем \code{fmap} \newterm{шаблонным шаблонным параметром} \code{F}. Вот синтаксис для этого:

\begin{snip}{cpp}
template<template<class> F, class A, class B>
F<B> fmap(std::function<B(A)>, F<A>);
\end{snip}
Мы хотели бы иметь возможность специализировать этот шаблон для разных функторов. К сожалению, в C++ есть запрет на частичную специализацию шаблонов функций. Вы не можете написать:

\begin{snip}{cpp}
template<class A, class B>
optional<B> fmap<optional>(std::function<B(A)> f, optional<A> opt)
\end{snip}
Вместо этого мы вынуждены полагаться на перегрузку функций, что возвращает нас к исходному определению неукарренного \code{fmap}:

\begin{snip}{cpp}
template<class A, class B>
optional<B> fmap(std::function<B(A)> f, optional<A> opt) {
    if (!opt.isValid())
        return optional<B>{};
    else
        return optional<B>{ f(opt.val()) };
}
\end{snip}
Это определение работает, но только потому, что второй аргумент \code{fmap} выбирает перегрузку. Оно полностью игнорирует более общее определение \code{fmap}.

\subsection{Функтор List}

Чтобы получить некоторую интуицию о роли функторов в программировании, нам нужно посмотреть больше примеров. Любой тип, параметризованный другим типом, является кандидатом в функторы. Обобщённые контейнеры параметризованы типом элементов, которые они хранят, так что давайте посмотрим на очень простой контейнер, список:

\src{snippet15}
У нас есть конструктор типа \code{List}, который является отображением из любого типа \code{a} в тип \code{List a}. Чтобы показать, что \code{List} является функтором, мы должны определить поднятие функций: Для функции \code{a -> b} определить функцию \code{List a -> List b}:

\src{snippet16}
Функция, действующая на \code{List a}, должна рассматривать два случая, соответствующих двум конструкторам списка. Случай \code{Nil} тривиален — просто вернуть \code{Nil} — с пустым списком нельзя сделать много чего. Случай \code{Cons} немного хитрее, потому что включает рекурсию. Так что давайте сделаем шаг назад и подумаем, что мы пытаемся сделать. У нас есть список из \code{a}, функция \code{f}, которая превращает \code{a} в \code{b}, и мы хотим сгенерировать список из \code{b}. Очевидная вещь — использовать \code{f} для превращения каждого элемента списка из \code{a} в \code{b}. Как мы делаем это на практике, учитывая, что (непустой) список определяется как \code{Cons} головы и хвоста? Мы применяем \code{f} к голове и применяем поднятый (\code{fmap}нутый) \code{f} к хвосту. Это рекурсивное определение, потому что мы определяем поднятый \code{f} через поднятый \code{f}:

\src{snippet17}
Заметьте, что в правой части \code{fmap f} применяется к списку, который короче списка, для которого мы его определяем — он применяется к его хвосту. Мы рекурсируем к более и более коротким спискам, так что мы обязательно достигнем пустого списка, или \code{Nil}. Но как мы решили ранее, \code{fmap f}, действующий на \code{Nil}, возвращает \code{Nil}, таким образом завершая рекурсию. Чтобы получить окончательный результат, мы объединяем новую голову \code{(f x)} с новым хвостом \code{(fmap f t)} с помощью конструктора \code{Cons}. Собирая всё вместе, вот объявление экземпляра для функтора списка:

\src{snippet18}
Если вам удобнее с C++, рассмотрите случай \code{std::vector}, который можно считать наиболее обобщённым контейнером C++. Реализация \code{fmap} для \code{std::vector} — это просто тонкая обёртка над \code{std::transform}:

\begin{snip}{cpp}
template<class A, class B>
std::vector<B> fmap(std::function<B(A)> f, std::vector<A> v) {
    std::vector<B> w;
    std::transform( std::begin(v)
                  , std::end(v)
                  , std::back_inserter(w)
                  , f);
    return w;
}
\end{snip}
Мы можем использовать её, например, чтобы возвести в квадрат элементы последовательности чисел:

\begin{snip}{cpp}
std::vector<int> v{ 1, 2, 3, 4 };
auto w = fmap([](int i) { return i*i; }, v);
std::copy( std::begin(w)
         , std::end(w)
         , std::ostream_iterator(std::cout, ", "));
\end{snip}
Большинство контейнеров C++ являются функторами в силу реализации итераторов, которые могут быть переданы в \code{std::transform}, более примитивному собрату \code{fmap}. К сожалению, простота функтора теряется под обычным хламом итераторов и временных объектов (см. реализацию \code{fmap} выше). Я с радостью говорю, что новая предлагаемая библиотека диапазонов C++ делает функториальную природу диапазонов гораздо более выраженной.

\subsection{Функтор Reader}

Теперь, когда у вас, возможно, развилась некоторая интуиция — например, функторы как своего рода контейнеры — позвольте мне показать вам пример, который на первый взгляд выглядит совсем иначе. Рассмотрим отображение типа \code{a} в тип функции, возвращающей \code{a}. Мы ещё не говорили глубоко о функциональных типах — полное категориальное рассмотрение впереди — но у нас есть некоторое понимание их как программистов. В Haskell функциональный тип конструируется с использованием конструктора типа \code{(->)}, который принимает два типа: тип аргумента и тип результата. Вы уже видели его в инфиксной форме, \code{a -> b}, но он может так же хорошо использоваться в префиксной форме, когда заключён в скобки:

\src{snippet19}
Так же, как с обычными функциями, типовые функции более чем одного аргумента могут быть частично применены. Так что когда мы предоставляем всего один аргумент типа стрелке, она всё ещё ожидает другой. Вот почему:

\src{snippet20}
является конструктором типа. Ему нужен ещё один тип \code{b}, чтобы произвести полный тип \code{a -> b}. В данном виде он определяет целое семейство конструкторов типов, параметризованных \code{a}. Давайте посмотрим, является ли это также семейством функторов. Работа с двумя параметрами типов может быть немного запутанной, так что давайте сделаем некоторое переименование. Назовём тип аргумента \code{r} и тип результата \code{a}, в соответствии с нашими предыдущими определениями функторов. Так что наш конструктор типа берёт любой тип \code{a} и отображает его в тип \code{r -> a}. Чтобы показать, что это функтор, мы хотим поднять функцию \code{a -> b} в функцию, которая принимает \code{r -> a} и возвращает \code{r -> b}. Это типы, которые образованы с помощью конструктора типа \code{(->) r}, действующего на \code{a} и \code{b} соответственно. Вот сигнатура типа \code{fmap}, применённого к этому случаю:

\src{snippet21}
Мы должны решить следующую головоломку: имея функцию \code{f :: a -> b} и функцию \code{g :: r -> a}, создать функцию \code{r -> b}. Есть только один способ скомпоновать две функции, и результат — именно то, что нам нужно. Так что вот реализация нашего \code{fmap}:

\src{snippet22}
Это просто работает! Если вам нравится краткая нотация, это определение может быть далее сокращено, заметив, что композиция может быть переписана в префиксной форме:

\src{snippet23}
и аргументы могут быть опущены, чтобы получить прямое равенство двух функций:

\src{snippet24}
Эта комбинация конструктора типа \code{(->) r} с приведённой выше реализацией \code{fmap} называется функтором reader.

\section{Функторы как контейнеры}

Мы видели несколько примеров функторов в языках программирования, которые определяют контейнеры общего назначения, или по крайней мере объекты, которые содержат некоторое значение типа, которым они параметризованы. Функтор reader кажется исключением, потому что мы не думаем о функциях как о данных. Но мы видели, что чистые функции могут быть мемоизированы, и выполнение функции может быть превращено в поиск по таблице. Таблицы — это данные. Обратно, из-за ленивости Haskell традиционный контейнер, like список, может фактически быть реализован как функция. Рассмотрим, например, бесконечный список натуральных чисел, который может быть компактно определён как:

\src{snippet25}
В первой строке пара квадратных скобок — это встроенный конструктор типа Haskell для списков. Во второй строке квадратные скобки используются для создания литерала списка. Очевидно, бесконечный список like этот не может быть сохранён в памяти. Компилятор реализует его как функцию, которая генерирует \code{Integer} по требованию. Haskell эффективно размывает различие между данными и кодом. Список может считаться функцией, а функция может считаться таблицей, которая отображает аргументы в результаты. Последнее может даже быть практичным, если область определения функции конечна и не слишком велика. Однако было бы непрактично реализовывать \code{strlen} как поиск по таблице, потому что есть бесконечно много разных строк. Как программисты, мы не любим бесконечностей, но в теории категорий вы учитесь поглощать бесконечности на завтрак. Будь то множество всех строк или коллекция всех возможных состояний Вселенной, прошлых, настоящих и будущих — мы можем справиться с этим! Так что я люблю думать о функторном объекте (объекте типа, порождённого эндофунктором) как о содержащем значение или значения типа, которым он параметризован, даже если эти значения физически не присутствуют там. Один пример функтора — это C++ \code{std::future}, который может в некоторый момент содержать значение, но нет гарантии, что будет; и если вы хотите получить к нему доступ, вы можете заблокироваться, ожидая завершения выполнения другим потоком. Другой пример — Haskell \code{IO} объект, который может содержать пользовательский ввод или будущие версии нашей Вселенной с «Hello World!», отображённым на мониторе. Согласно этой интерпретации, функторный объект — это нечто, что может содержать значение или значения типа, которым он параметризован. Или он может содержать рецепт для генерации этих значений. Мы совсем не озабочены возможностью доступа к значениям — это полностью опционально и вне scope функтора. Всё, что нас интересует, — это возможность манипулировать этими значениями с помощью функций. Если значения доступны, то мы должны быть able видеть результаты этой манипуляции. Если нет, то всё, что нас заботит, — это то, что манипуляции композируются правильно и что манипуляция с тождественной функцией ничего не меняет. Просто чтобы показать вам, насколько нам неважна возможность доступа к значениям внутри функторного объекта, вот конструктор типа, который полностью игнорирует свой аргумент \code{a}:

\src{snippet26}
Конструктор типа \code{Const} принимает два типа, \code{c} и \code{a}. Так же, как мы делали с конструктором стрелки, мы собираемся частично применить его, чтобы создать функтор. Конструктор данных (также called \code{Const}) принимает всего одно значение типа \code{c}. Оно не зависит от \code{a}. Тип \code{fmap} для этого конструктора типа:

\src{snippet27}
Поскольку функтор игнорирует свой аргумент типа, реализация \code{fmap} свободна игнорировать свой аргумент-функцию — функции не на что действовать:

\src{snippet28}
Это может быть немного понятнее в C++ (я никогда не думал, что произнесу эти слова!), где есть более сильное различие между аргументами типов — которые являются времени компиляции — и значениями, которые являются времени выполнения:

\begin{snip}{cpp}
template<class C, class A>
struct Const {
    Const(C v) : _v(v) {}
    C _v;
};
\end{snip}
C++ реализация \code{fmap} также игнорирует аргумент-функцию и, по существу, переприводит тип аргумента \code{Const} без изменения его значения:

\begin{snip}{cpp}
template<class C, class A, class B>
Const<C, B> fmap(std::function<B(A)> f, Const<C, A> c) {
    return Const<C, B>{c._v};
}
\end{snip}
Несмотря на свою странность, функтор \code{Const} играет важную роль во многих конструкциях. В теории категорий это специальный случай функтора $\Delta_c$, о котором я упоминал ранее — случай эндофунктора чёрной дыры. Мы увидим больше его в будущем.

\section{Композиция функторов}

Нетрудно убедить себя, что функторы между категориями композируются, так же как функции между множествами композируются. Композиция двух функторов, когда действует на объекты, — это просто композиция их соответствующих отображений объектов; и аналогично при действии на морфизмы. После прохождения через два функтора тождественные морфизмы оказываются тождественными морфизмами, а композиции морфизмов заканчиваются как композиции морфизмов. Тут действительно не много чего. В частности, легко композировать эндофункторы. Вспомните функцию \code{maybeTail}? Я перепишу её, используя встроенную реализацию списков в Haskell:

\src{snippet29}
(Конструктор пустого списка, который мы называли \code{Nil}, заменён на пустую пару квадратных скобок \code{{[}{]}}. Конструктор \code{Cons} заменён на инфиксный оператор \code{:} (двоеточие).) Результат \code{maybeTail} имеет тип, который является композицией двух функторов, \code{Maybe} и \code{{[}{]}}, действующих на \code{a}. Каждый из этих функторов снабжён своей собственной версией \code{fmap}, но что, если мы хотим применить некоторую функцию \code{f} к содержимому композита: \code{Maybe} списка? Мы должны пробиться через два слоя функторов. Мы можем использовать \code{fmap}, чтобы пробиться через внешний \code{Maybe}. Но мы не можем просто послать \code{f} внутрь \code{Maybe}, потому что \code{f} не работает со списками. Мы должны послать \code{(fmap f)}, чтобы действовать на внутренний список. Например, давайте посмотрим, как мы можем возвести в квадрат элементы \code{Maybe} списка целых чисел:

\src{snippet30}
Компилятор, проанализировав типы, поймёт, что для внешнего \code{fmap} он должен использовать реализацию из экземпляра \code{Maybe}, а для внутреннего — реализацию функтора списка. Может быть не сразу очевидно, что приведённый код может быть переписан как:

\src{snippet31}
Но помните, что \code{fmap} может рассматриваться как функция всего одного аргумента:

\src{snippet32}
В нашем случае второй \code{fmap} в \code{(fmap . fmap)} принимает как свой аргумент:

\src{snippet33}
и возвращает функцию типа:

\src{snippet34}
Первый \code{fmap} затем берёт эту функцию и возвращает функцию:

\src{snippet35}
Наконец, эта функция применяется к \code{mis}. Так что композиция двух функторов — это функтор, чей \code{fmap} является композицией соответствующих \code{fmap}. Возвращаясь к теории категорий: довольно очевидно, что композиция функторов ассоциативна (отображение объектов ассоциативно, и отображение морфизмов ассоциативно). И также есть тривиальный тождественный функтор в каждой категории: он отображает каждый объект в себя и каждый морфизм в себя. Так что функторы имеют все те же свойства, что и морфизмы в некоторой категории. Но что это за категория? Это должна быть категория, в которой объекты — это категории, а морфизмы — функторы. Это категория категорий. Но категория \emph{всех} категорий должна была бы включать себя, и мы попали бы в те же парадоксы, которые сделали множество всех множеств невозможным. Однако существует категория всех \emph{малых} категорий, называемая $\Cat$ (которая большая, так что не может быть членом себя). Малая категория — это та, в которой объекты образуют множество, в противоположность чему-то большему, чем множество. Заметьте, в теории категорий даже бесконечное несчётное множество считается «малым». Я thought упомянуть эти вещи, потому что нахожу удивительным, что мы можем узнавать те же структуры, повторяющиеся на многих уровнях абстракции. Мы увидим позже, что функторы также образуют категории.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Можем ли мы превратить конструктор типа \code{Maybe} в функтор, определив:

        \begin{snip}{haskell}
fmap _ _ = Nothing
\end{snip}

        который игнорирует оба своих аргумента? (Подсказка: Проверьте законы функторов.)
  \item
        Докажите законы функторов для функтора reader. Подсказка: это действительно просто.
  \item
        Реализуйте функтор reader на вашем втором любимом языке (первый, конечно, Haskell).
  \item
        Докажите законы функторов для функтора списка. Предположите, что законы верны для хвостовой части списка, к которой вы его применяете (другими словами, используйте \emph{индукцию}).
\end{enumerate}