% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{Б}{ольшинство конструкций в} теории категорий --- это обобщения результатов
из других более специфических областей математики. Вещи типа произведений,
копроизведений, моноидов, экспоненциалов и т.д. были известны задолго до
теории категорий. Они могли быть известны под разными именами в
разных ветвях математики. Декартово произведение в теории множеств,
пересечение в теории порядка, конъюнкция в логике --- все они специфические
примеры абстрактной идеи категорного произведения.

Лемма Ёнеды выделяется в этом отношении как широкое утверждение
о категориях в общем с малым или вообще без прецедента в других
ветвях математики. Некоторые говорят, что её ближайший аналог --- теорема
Кэли в теории групп (каждая группа изоморфна группе перестановок
некоторого множества).

Обстановка для леммы Ёнеды --- это произвольная категория $\cat{C}$
вместе с функтором $F$ из $\cat{C}$ в $\Set$. Мы
видели в предыдущей секции, что некоторые функторы со значениями в $\Set$
представимы, то есть изоморфны hom-функтору. Лемма Ёнеды
говорит нам, что все функторы со значениями в $\Set$ могут быть получены из
hom-функторов через естественные преобразования, и она явно
перечисляет все такие преобразования.

Когда я говорил о естественных преобразованиях, я упоминал, что
условие естественности может быть довольно ограничивающим. Когда вы определяете
компоненту естественного преобразования в одном объекте, естественность может быть
достаточно сильной, чтобы ``транспортировать'' эту компоненту к другому объекту, который
соединён с ним через морфизм. Чем больше стрелок между объектами в
исходной и целевой категориях, тем больше ограничений у вас
есть для транспортировки компонент естественных преобразований.
$\Set$ случается быть очень богатой стрелками категорией.

Лемма Ёнеды говорит нам, что естественное преобразование между
hom-функтором и любым другим функтором $F$ полностью определяется
спецификацией значения его единственной компоненты в только одной точке! Остальная часть
естественного преобразования просто следует из условий естественности.

Так что давайте рассмотрим условие естественности между двумя функторами,
вовлечёнными в лемму Ёнеды. Первый функтор --- это hom-функтор. Он
отображает любой объект $x$ в $\cat{C}$ в множество морфизмов
$\cat{C}(a, x)$ --- для $a$, фиксированного объекта в $\cat{C}$. Мы также
видели, что он отображает любой морфизм $f$ из $x \to y$ в $\cat{C}(a, f)$.

Второй функтор --- произвольный функтор со значениями в $\Set$,
$F$.

Давайте назовём естественное преобразование между этими двумя функторами
$\alpha$. Поскольку мы действуем в $\Set$, компоненты
естественного преобразования, такие как $\alpha_x$ или $\alpha_y$, --- это просто
обычные функции между множествами:
\begin{gather*}
  \alpha_x \Colon \cat{C}(a, x) \to F x \\
  \alpha_y \Colon \cat{C}(a, y) \to F y
\end{gather*}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/yoneda1.png}
\end{figure}

\noindent
И поскольку это просто функции, мы можем смотреть на их значения в
конкретных точках. Но что такое точка в множестве $\cat{C}(a, x)$? Вот
ключевое наблюдение: каждая точка в множестве $\cat{C}(a, x)$ --- это также
морфизм $h$ из $a$ в $x$.

Так что квадрат естественности для $\alpha$:
\[\alpha_y \circ \cat{C}(a, f) = F f \circ \alpha_x\]
становится, поточечно, при действии на $h$:
\[\alpha_y (\cat{C}(a, f) h) = (F f) (\alpha_x h)\]
Вы можете вспомнить из предыдущей секции, что действие
hom-функтора $\cat{C}(a,-)$ на морфизм $f$ было определено как
предкомпозиция:
\[\cat{C}(a, f) h = f \circ h\]
что приводит к:
\[\alpha_y (f \circ h) = (F f) (\alpha_x h)\]
Насколько сильно это условие, можно увидеть, специализировав его к
случаю $x = a$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/yoneda2.png}
\end{figure}

\noindent
В этом случае $h$ становится морфизмом из $a$ в
$a$. Мы знаем, что есть как минимум один такой морфизм,
$h = \id_a$. Давайте подставим его:
\[\alpha_y f = (F f) (\alpha_a \id_a)\]
Обратите внимание, что только что произошло: левая сторона --- это действие
$\alpha_y$ на произвольный элемент $f$ из $\cat{C}(a, y)$. И
оно полностью определяется единственным значением $\alpha_a$ в
$\id_a$. Мы можем выбрать любое такое значение, и оно сгенерирует естественное
преобразование. Поскольку значения $\alpha_a$ находятся в множестве
$F a$, любая точка в $F a$ определит некоторое $\alpha$.

Наоборот, для данного любого естественного преобразования $\alpha$ из
$\cat{C}(a, -)$ в $F$ вы можете вычислить его в $\id_a$, чтобы
получить точку в $F a$.

Мы только что доказали лемму Ёнеды:

\begin{quote}
  Существует взаимно однозначное соответствие между естественными преобразованиями
  из $\cat{C}(a, -)$ в $F$ и элементами $F a$.
\end{quote}
другими словами,
\[\mathit{Nat}(\cat{C}(a, -), F) \cong F a\]
Или, если мы используем нотацию $[\cat{C}, \Set]$ для категории
функторов между $\cat{C}$ и $\Set$, множество естественных
преобразований --- это просто hom-множество в этой категории, и мы можем написать:
\[[\cat{C}, \Set](\cat{C}(a, -), F) \cong F a\]
Я объясню позже, как это соответствие на самом деле естественный
изоморфизм.

Теперь давайте попытаемся получить некоторую интуицию об этом результате. Самая удивительная
вещь в том, что всё естественное преобразование кристаллизуется из только
одного центра нуклеации: значения, которое мы назначаем ему в $\id_a$.
Оно распространяется из этой точки, следуя условию естественности. Оно заливает
образ $\cat{C}$ в $\Set$. Так что давайте сначала рассмотрим, каков
образ $\cat{C}$ под $\cat{C}(a, -)$.

Давайте начнём с образа самого $a$. Под hom-функтором
$\cat{C}(a, -)$, $a$ отображается в множество $\cat{C}(a, a)$.
Под функтором $F$, с другой стороны, он отображается в множество
$F a$. Компонента естественного преобразования $\alpha_a$
--- это некоторая функция из $\cat{C}(a, a)$ в $F a$. Давайте сфокусируемся на
только одной точке в множестве $\cat{C}(a, a)$, точке, соответствующей
морфизму $\id_a$. Чтобы подчеркнуть факт, что это просто точка
в множестве, давайте назовём её $p$. Компонента $\alpha_a$ должна отобразить
$p$ в некоторую точку $q$ в $F a$. Я покажу вам, что
любой выбор $q$ приводит к уникальному естественному преобразованию.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/yoneda3.png}
\end{figure}

\noindent
Первое утверждение в том, что выбор одной точки $q$ уникально
определяет остальную часть функции $\alpha_a$. Действительно, давайте выберем любую
другую точку, $p'$ в $\cat{C}(a, a)$, соответствующую
некоторому морфизму $g$ из $a$ в $a$. И вот где
магия леммы Ёнеды происходит: $g$ может рассматриваться как
точка $p'$ в множестве $\cat{C}(a, a)$. В то же время
он выбирает две \emph{функции} между множествами. Действительно, под
hom-функтором морфизм $g$ отображается в функцию
$\cat{C}(a, g)$; а под $F$ он отображается в $F g$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/yoneda4.png}
\end{figure}

\noindent
Теперь давайте рассмотрим действие $\cat{C}(a, g)$ на наше исходное
$p$, которое, как вы помните, соответствует $\id_a$. Оно
определяется как предкомпозиция, $g \circ \id_a$, которая равна $g$,
что соответствует нашей точке $p'$. Так что морфизм
$g$ отображается в функцию, которая, действуя на $p$,
производит $p'$, которое есть $g$. Мы замкнули
круг!

Теперь рассмотрите действие $F g$ на $q$. Это некоторое
$q'$, точка в $F a$. Чтобы завершить квадрат естественности,
$p'$ должно быть отображено в $q'$ под
$\alpha_a$. Мы выбрали произвольное $p'$ (произвольное
$g$) и вывели его отображение под $\alpha_a$. Функция
$\alpha_a$ таким образом полностью определена.

Второе утверждение в том, что $\alpha_x$ уникально определён для любого
объекта $x$ в $\cat{C}$, который соединён с $a$.
Рассуждение аналогичное, за исключением того, что теперь у нас есть ещё два множества,
$\cat{C}(a, x)$ и $F x$, и морфизм $g$ из
$a$ в $x$ отображается, под hom-функтором, в:
\[\cat{C}(a, g) \Colon \cat{C}(a, a) \to \cat{C}(a, x)\]
а под $F$ в:
\[F g \Colon F a \to F x\]
Опять, $\cat{C}(a, g)$, действующий на наше $p$, задаётся
предкомпозицией: $g \circ \id_a$, что соответствует точке
$p'$ в $\cat{C}(a, x)$. Естественность определяет значение
$\alpha_x$, действующего на $p'$, как:
\[q' = (F g) q\]
Поскольку $p'$ было произвольным, вся функция $\alpha_x$
таким образом определена.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/yoneda5.png}
\end{figure}

\noindent
Что, если есть объекты в $\cat{C}$, которые не имеют соединения с
$a$? Все они отображаются под $\cat{C}(a, -)$ в одно множество
--- пустое множество. Вспомните, что пустое множество --- это начальный объект в
категории множеств. Это означает, что существует уникальная функция из этого
множества в любое другое множество. Мы назвали эту функцию \code{absurd}. Так что здесь
снова у нас нет выбора для компоненты естественного
преобразования: это может быть только \code{absurd}.

Один способ понимания леммы Ёнеды --- осознать, что естественные
преобразования между функторами со значениями в $\Set$ --- это просто семейства
функций, а функции в общем случае с потерями. Функция может
схлопывать информацию, и она может покрывать только части своего кодомена.
Единственные функции, которые не с потерями, --- это те, которые обратимы ---
изоморфизмы. Отсюда следует, что лучшие структуро-сохраняющие
функторы со значениями в $\Set$ --- это представимые. Они либо
hom-функторы, либо функторы, которые естественно изоморфны
hom-функторам. Любой другой функтор $F$ получается из
hom-функтора через преобразование с потерями. Такое преобразование может
не только терять информацию, но оно также может покрывать только малую часть
образа функтора $F$ в $\Set$.

\section{Ёнеда в Haskell}

Мы уже встречали hom-функтор в Haskell под видом
функтора reader:

\src{snippet01}
Reader отображает морфизмы (здесь функции) предкомпозицией:

\src{snippet02}
Лемма Ёнеды говорит нам, что функтор reader может быть естественно
отображён в любой другой функтор.

Естественное преобразование --- это полиморфная функция. Так что для данного функтора
\code{F} у нас есть отображение в него из функтора reader:

\src{snippet03}
Как обычно, \code{forall} опционален, но мне нравится писать его явно,
чтобы подчеркнуть параметрический полиморфизм естественных преобразований.

Лемма Ёнеды говорит нам, что эти естественные преобразования находятся во
взаимно однозначном соответствии с элементами \code{F a}:

\begin{snipv}
forall x . (a -> x) -> F x \ensuremath{\cong} F a
\end{snipv}
Правая сторона этого тождества --- то, что мы обычно считаем
структурой данных. Помните интерпретацию функторов как обобщённых
контейнеров? \code{F a} --- это контейнер \code{a}. Но левая
сторона --- это полиморфная функция, которая принимает функцию в качестве
аргумента. Лемма Ёнеды говорит нам, что два представления
эквивалентны --- они содержат одну и ту же информацию.

Другой способ сказать это: дайте мне полиморфную функцию типа:

\src{snippet04}
и я произведу контейнер \code{a}. Трюк тот, который мы использовали
в доказательстве леммы Ёнеды: мы вызываем эту функцию с \code{id},
чтобы получить элемент \code{F a}:

\src{snippet05}
Обратное также верно: для данного значения типа \code{F a}:

\src{snippet06}
можно определить полиморфную функцию:

\src{snippet07}
правильного типа. Вы можете легко ходить туда и обратно между двумя
представлениями.

Преимущество наличия множественных представлений в том, что одно может быть
легче композировать, чем другое, или что одно может быть более эффективным в
некоторых применениях, чем другое.

Простейшая иллюстрация этого принципа --- преобразование кода,
которое часто используется в конструкции компиляторов: стиль передачи продолжений
или \acronym{CPS}. Это простейшее применение леммы Ёнеды к
тождественному функтору. Замена \code{F} тождеством производит:

\begin{snipv}
forall r . (a -> r) -> r \ensuremath{\cong} a
\end{snipv}
Интерпретация этой формулы в том, что любой тип \code{a} может быть
заменён функцией, которая принимает ``обработчик'' для \code{a}.
Обработчик --- это функция, принимающая \code{a} и выполняющая остальную часть
вычисления --- продолжение. (Тип \code{r} обычно
инкапсулирует какой-то код статуса.)

Этот стиль программирования очень распространён в UI, в асинхронных
системах и в конкурентном программировании. Недостаток \acronym{CPS} в том, что он
включает инверсию контроля. Код разделён между производителями и
потребителями (обработчиками) и не легко композируем. Любой, кто делал
какое-либо количество нетривиального веб-программирования, знаком с кошмаром
кода-спагетти из взаимодействующих состояние-полных обработчиков. Как мы увидим
позже, разумное использование функторов и монад может восстановить некоторые
композиционные свойства \acronym{CPS}.

\section{Ко-Ёнеда}

Как обычно, мы получаем бонусную конструкцию, инвертируя направление
стрелок. Лемма Ёнеды может быть применена к противоположной категории
$\cat{C}^\mathit{op}$, чтобы дать нам отображение между контравариантными
функторами.

Эквивалентно, мы можем вывести ко-лемму Ёнеды, фиксируя целевой
объект наших hom-функторов вместо источника. Мы получаем
контравариантный hom-функтор из $\cat{C}$ в $\Set$:
$\cat{C}(-, a)$. Контравариантная версия леммы Ёнеды
устанавливает взаимно однозначное соответствие между естественными преобразованиями
из этого функтора в любой другой контравариантный функтор $F$ и
элементами множества $F a$:
\[\mathit{Nat}(\cat{C}(-, a), F) \cong F a\]
Вот версия Haskell ко-леммы Ёнеды:

\begin{snipv}
forall x . (x -> a) -> F x \ensuremath{\cong} F a
\end{snipv}
Обратите внимание, что в некоторой литературе именно контравариантная версия
называется леммой Ёнеды.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Покажите, что две функции \code{phi} и \code{psi}, которые образуют
        изоморфизм Ёнеды в Haskell, являются обратными друг другу.

        \begin{snip}{haskell}
phi :: (forall x . (a -> x) -> F x) -> F a
phi alpha = alpha id

psi :: F a -> (forall x . (a -> x) -> F x)
psi fa h = fmap h fa
\end{snip}
  \item
        Дискретная категория --- это та, которая имеет объекты, но никаких морфизмов, кроме
        тождественных морфизмов. Как работает лемма Ёнеды для функторов
        из такой категории?
  \item
        Список юнитов \code{{[}(){]}} не содержит никакой другой информации, кроме
        своей длины. Так что, как тип данных, он может рассматриваться как кодировка
        целых чисел. Пустой список кодирует ноль, синглетон \code{{[}(){]}} (значение,
        не тип) кодирует один, и так далее. Сконструируйте другое
        представление этого типа данных, используя лемму Ёнеды для функтора
        списка.
\end{enumerate}

\section{Библиография}

\begin{enumerate}
  \tightlist
  \item
        \urlref{https://www.youtube.com/watch?v=TLMxHB19khE}{Catsters} видео.
\end{enumerate}
