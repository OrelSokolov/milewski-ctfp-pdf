% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{М}{ы видели ранее}, что когда мы фиксируем объект $a$ в
категории $\cat{C}$, отображение $\cat{C}(a, -)$ --- это (ковариантный)
функтор из $\cat{C}$ в $\Set$.
\[x \to \cat{C}(a, x)\]
(Кодомен --- $\Set$, потому что hom-множество $\cat{C}(a, x)$ ---
\emph{множество}.) Мы называем это отображение hom-функтором --- мы ранее
определили его действие на морфизмы также.

Теперь давайте варьировать $a$ в этом отображении. Мы получим новое отображение, которое
назначает hom-\emph{функтор} $\cat{C}(a, -)$ любому $a$.
\[a \to \cat{C}(a, -)\]
Это отображение объектов из категории $\cat{C}$ в функторы, которые являются
\emph{объектами} в категории функторов (см. секцию о категориях
функторов в
\hyperref[natural-transformations]{Естественных
  преобразованиях}). Давайте используем нотацию $[\cat{C}, \Set]$ для
категории функторов из $\cat{C}$ в $\Set$. Вы также можете вспомнить, что
hom-функторы --- это прототипические
\hyperref[representable-functors]{представимые
  функторы}.

Каждый раз, когда у нас есть отображение объектов между двумя категориями,
естественно спросить, является ли такое отображение также функтором. Другими словами,
можем ли мы поднять морфизм из одной категории в морфизм в
другой категории. Морфизм в $\cat{C}$ --- это просто элемент
$\cat{C}(a, b)$, но морфизм в категории функторов
$[\cat{C}, \Set]$ --- это естественное преобразование. Так что мы ищем
отображение морфизмов в естественные преобразования.

Давайте посмотрим, можем ли мы найти естественное преобразование, соответствующее
морфизму $f \Colon a \to b$. Сначала посмотрим, во что
$a$ и $b$ отображаются. Они отображаются в два
функтора: $\cat{C}(a, -)$ и $\cat{C}(b, -)$. Нам нужно естественное
преобразование между этими двумя функторами.

И вот трюк: мы используем лемму Ёнеды:
\[[\cat{C}, \Set](\cat{C}(a, -), F) \cong F a\]
и заменяем обобщённый $F$ на hom-функтор
$\cat{C}(b, -)$. Мы получаем:
\[[\cat{C}, \Set](\cat{C}(a, -), \cat{C}(b, -)) \cong \cat{C}(b, a)\]
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{images/yoneda-embedding.jpg}
\end{figure}

\noindent
Это в точности естественное преобразование между двумя hom-функторами,
которое мы искали, но с небольшим поворотом: у нас есть отображение между
естественным преобразованием и морфизмом --- элементом
$\cat{C}(b, a)$ --- который идёт в ``неправильном'' направлении. Но это
нормально; это только означает, что функтор, на который мы смотрим, контравариантен.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\textwidth]{images/yoneda-embedding-2.jpg}
\end{figure}

\noindent
На самом деле мы получили даже больше, чем рассчитывали. Отображение из
$\cat{C}$ в $[\cat{C}, \Set]$ --- это не только контравариантный функтор
--- это \emph{полностью точный} функтор. Полнота и точность ---
свойства функторов, которые описывают, как они отображают hom-множества.

\emph{Точный} функтор --- \newterm{инъективен} на hom-множествах, означая, что
он отображает различные морфизмы в различные морфизмы. Другими словами, он
их не объединяет.

\emph{Полный} функтор --- \newterm{сюръективен} на hom-множествах, означая, что он
отображает одно hom-множество \emph{на} другое hom-множество, полностью покрывая
последнее.

Полностью точный функтор $F$ --- это \newterm{биекция} на hom-множествах
--- взаимно однозначное соответствие всех элементов обоих множеств. Для каждой пары
объектов $a$ и $b$ в исходной категории $\cat{C}$
существует биекция между $\cat{C}(a, b)$ и
$\cat{D}(F a, F b)$, где $\cat{D}$ --- целевая категория
$F$ (в нашем случае категория функторов, $[\cat{C}, \Set]$).
Обратите внимание, что это не означает, что $F$ --- биекция на
\emph{объектах}. Могут быть объекты в $\cat{D}$, которые не находятся в
образе $F$, и мы не можем сказать ничего о hom-множествах для этих
объектов.

\section{Вложение}

(Контравариантный) функтор, который мы только что описали, функтор, который
отображает объекты в $\cat{C}$ в функторы в $[\cat{C}, \Set]$:
\[a \to \cat{C}(a, -)\]
определяет \newterm{вложение Ёнеды}. Он \emph{встраивает} категорию
$\cat{C}$ (строго говоря, категорию $\cat{C}^\mathit{op}$,
из-за контравариантности) внутрь категории функторов
$[\cat{C}, \Set]$. Он не только отображает объекты в $\cat{C}$ в
функторы, но также точно сохраняет все связи между ними.

Это очень полезный результат, потому что математики знают много о
категории функторов, особенно о функторах, чей кодомен ---
$\Set$. Мы можем получить много понимания о произвольной категории
$\cat{C}$, встраивая её в категорию функторов.

Конечно, есть двойственная версия вложения Ёнеды, иногда
называемая ко-вложением Ёнеды. Заметьте, что мы могли бы начать с
фиксации целевого объекта (а не исходного объекта) каждого
hom-множества, $\cat{C}(-, a)$. Это дало бы нам контравариантный
hom-функтор. Контравариантные функторы из $\cat{C}$ в $\Set$ ---
наши знакомые предпучки (см., например,
\hyperref[limits-and-colimits]{Пределы
  и копределы}). Ко-вложение Ёнеды определяет вложение
категории $\cat{C}$ в категорию предпучков. Его действие на морфизмы
задаётся:
\[[\cat{C}^\mathit{op}, \Set](\cat{C}(-, a), \cat{C}(-, b)) \cong \cat{C}(a, b)\]
Опять, математики знают много о категории предпучков, так что
возможность встроить произвольную категорию в неё --- это большой выигрыш.

\section{Применение к Haskell}

В Haskell вложение Ёнеды может быть представлено как изоморфизм
между естественными преобразованиями среди функторов reader с одной стороны
и функциями (идущими в противоположном направлении) с другой стороны:

\begin{snipv}
forall x. (a -> x) -> (b -> x) \ensuremath{\cong} b -> a
\end{snipv}
(Помните, функтор reader эквивалентен
\code{((->) a)}.)

Левая сторона этого тождества --- полиморфная функция, которая,
для данной функции из \code{a} в \code{x} и значения типа
\code{b}, может произвести значение типа \code{x} (я раскарриваю ---
убираю скобки вокруг --- функцию
\code{b -> x}). Единственный способ, которым это может быть сделано для всех
\code{x}, --- если наша функция знает, как конвертировать \code{b} в
\code{a}. Она должна тайно иметь доступ к функции
\code{b -> a}.

Для данного такого конвертера, \code{btoa}, можно определить левую сторону,
назовём её \code{fromY}, как:

\src{snippet01}
Наоборот, для данной функции \code{fromY} мы можем восстановить конвертер,
вызвав \code{fromY} с тождеством:

\src{snippet02}
Это устанавливает биекцию между функциями типа
\code{fromY} и \code{btoa}.

Альтернативный способ взглянуть на этот изоморфизм --- что это \acronym{CPS}
кодировка функции из \code{b} в \code{a}. Аргумент
\code{a -> x} --- продолжение (обработчик). Результат
--- функция из \code{b} в \code{x}, которая, когда вызвана со
значением типа \code{b}, выполнит продолжение, предкомпозированное с
кодируемой функцией.

Вложение Ёнеды также объясняет некоторые альтернативные
представления структур данных в Haskell. В частности, оно
предоставляет \urlref{https://bartoszmilewski.com/2015/07/13/from-lenses-to-yoneda-embedding/}
{очень полезное представление}
линз из библиотеки \code{Control.Lens}.

\section{Пример с предпорядком}

Этот пример был предложен Робертом Харпером. Это применение
вложения Ёнеды к категории, определённой предпорядком. Предпорядок --- это
множество с отношением упорядочения между его элементами, которое традиционно
записывается как $\leqslant$ (меньше или равно). ``Пре'' в
предпорядке там, потому что мы требуем только, чтобы отношение было
транзитивным и рефлексивным, но не обязательно антисимметричным (так что
возможно иметь циклы).

Множество с отношением предпорядка порождает категорию. Объекты
--- это элементы этого множества. Морфизм из объекта $a$ в
$b$ либо не существует, если объекты не могут быть сравнены или если
неверно, что $a \leqslant b$; или существует, если
$a \leqslant b$, и он указывает из $a$ в
$b$. Никогда не бывает более одного морфизма из одного объекта в
другой. Следовательно, любое hom-множество в такой категории либо пустое множество,
либо одноэлементное множество. Такая категория называется \emph{тонкой}.

Легко убедить себя, что эта конструкция действительно категория:
стрелки композиционны, потому что если
$a \leqslant b$ и $b \leqslant c$, то
$a \leqslant c$; и композиция ассоциативна. У нас также
есть тождественные стрелки, потому что каждый элемент (меньше или) равен
себе (рефлексивность лежащего в основе отношения).

Теперь мы можем применить ко-вложение Ёнеды к категории предпорядка. В
частности, нас интересует его действие на морфизмы:
\[[\cat{C}, \Set](\cat{C}(-, a), \cat{C}(-, b)) \cong \cat{C}(a, b)\]
Hom-множество на правой стороне непусто тогда и только тогда, когда
$a \leqslant b$ --- в каком случае это одноэлементное множество.
Следовательно, если $a \leqslant b$, существует единственное
естественное преобразование слева. Иначе нет естественного
преобразования.

Так что такое естественное преобразование между hom-функторами в предпорядке?
Оно должно быть семейством функций между множествами $\cat{C}(-, a)$ и
$\cat{C}(-, b)$. В предпорядке каждое из этих множеств может быть либо пустым,
либо синглетоном. Давайте посмотрим, какие функции есть в нашем
распоряжении.

Есть функция из пустого множества в себя (тождество, действующее на
пустом множестве), функция \code{absurd} из пустого множества в
одноэлементное множество (она ничего не делает, поскольку ей нужно быть определённой только для
элементов пустого множества, которых нет), и функция из
синглетона в себя (тождество, действующее на одноэлементном множестве).
Единственная комбинация, которая запрещена, --- это отображение из синглетона в
пустое множество (каким было бы значение такой функции при действии на
единственный элемент?).

Так что наше естественное преобразование никогда не соединит одноэлементное hom-множество с
пустым hom-множеством. Другими словами, если $x \leqslant a$
(одноэлементное hom-множество $\cat{C}(x, a)$), то $\cat{C}(x, b)$ не может быть
пустым. Непустое $\cat{C}(x, b)$ означает, что $x$ меньше или
равно $b$. Так что существование рассматриваемого естественного преобразования
требует, чтобы для каждого $x$, если
$x \leqslant a$, то $x \leqslant b$.
\[\text{для всех } x, x \leqslant a \Rightarrow x \leqslant b\]
С другой стороны, ко-Ёнеда говорит нам, что существование этого естественного
преобразования эквивалентно тому, что $\cat{C}(a, b)$ непусто, или
$a \leqslant b$. Вместе мы получаем:
\[a \leqslant b \text{ тогда и только тогда, когда для всех } x, x \leqslant a \Rightarrow x \leqslant b\]
Мы могли бы прийти к этому результату напрямую. Интуиция в том, что если
$a \leqslant b$, то все элементы, которые ниже $a$,
также должны быть ниже $b$. Наоборот, когда вы подставляете
$a$ вместо $x$ на правой стороне, следует, что
$a \leqslant b$. Но вы должны признать, что приход к этому
результату через вложение Ёнеды намного более захватывающий.

\section{Естественность}

Лемма Ёнеды устанавливает изоморфизм между множеством естественных
преобразований и объектом в $\Set$. Естественные преобразования ---
это морфизмы в категории функторов $[\cat{C}, \Set]$. Множество
естественных преобразований между любыми двумя функторами --- это hom-множество в этой
категории. Лемма Ёнеды --- это изоморфизм:
\[[\cat{C}, \Set](\cat{C}(a, -), F) \cong F a\]
Этот изоморфизм оказывается естественным как в $F$, так и в
$a$. Другими словами, он естественен в $(F, a)$, паре,
взятой из категории произведения  $[\cat{C}, \Set] \times \cat{C}$. Обратите внимание,
что теперь мы рассматриваем $F$ как \newterm{объект} в категории
функторов.

Давайте подумаем на мгновение, что это означает. Естественный изоморфизм --- это
обратимое \emph{естественное преобразование} между двумя функторами. И
действительно, правая сторона нашего изоморфизма --- функтор. Это
функтор из $[\cat{C}, \Set] \times \cat{C}$ в $\Set$. Его действие на
пару $(F, a)$ --- это множество --- результат вычисления
функтора $F$ в объекте $a$. Это называется
функтором вычисления.

Левая сторона также функтор, который принимает $(F, a)$ в
множество естественных преобразований $[\cat{C}, \Set](\cat{C}(a, -), F)$.

Чтобы показать, что это действительно функторы, мы также должны определить их
действие на морфизмы. Но что такое морфизм между парой
$(F, a)$ и $(G, b)$? Это пара морфизмов,
$(\Phi, f)$; первый --- морфизм между функторами ---
естественное преобразование --- второй --- обычный морфизм в
$\cat{C}$.

Функтор вычисления принимает эту пару $(\Phi, f)$ и отображает её в
функцию между двумя множествами, $F a$ и $G b$. Мы можем
легко сконструировать такую функцию из компоненты $\Phi$ в
$a$ (которая отображает $F a$ в $G a$) и морфизма
$f$, поднятого $G$:
\[(G f) \circ \Phi_a\]
Обратите внимание, что из-за естественности $\Phi$ это то же самое, что:
\[\Phi_b \circ (F f)\]
Я не буду доказывать естественность всего изоморфизма --- после того,
как вы установили, каковы функторы, доказательство довольно
механическое. Оно следует из факта, что наш изоморфизм построен
из функторов и естественных преобразований. Просто нет способа, чтобы оно
пошло не так.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Выразите ко-вложение Ёнеды в Haskell.
  \item
        Покажите, что биекция, которую мы установили между \code{fromY} и
        \code{btoa}, --- это изоморфизм (два отображения --- обратные
        друг другу).
  \item
        Разработайте вложение Ёнеды для моноида. Какой функтор соответствует
        единственному объекту моноида? Какие естественные преобразования соответствуют
        морфизмам моноида?
  \item
        Каково применение \emph{ковариантного} вложения Ёнеды к
        предпорядкам? (Вопрос предложен Гершомом Базерманом.)
  \item
        Вложение Ёнеды может быть использовано для встраивания произвольной категории функторов
        $[\cat{C}, \cat{D}]$ в категорию функторов
        $[[\cat{C}, \cat{D}], \Set]$. Выясните, как оно работает на морфизмах
        (которые в этом случае являются естественными преобразованиями).
\end{enumerate}
