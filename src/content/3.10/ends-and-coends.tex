% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{Е}{сть много интуиций}, которые мы можем приложить к морфизмам в категории,
но мы все можем согласиться, что если есть морфизм из объекта
$a$ в объект $b$, то два объекта каким-то образом
``связаны.'' Морфизм --- в каком-то смысле, доказательство этого отношения. Это
чётко видно в любой категории предпорядка, где морфизм \emph{является}
отношением. В общем случае может быть много ``доказательств'' одного и того же отношения
между двумя объектами. Эти доказательства образуют множество, которое мы называем hom-множеством.
Когда мы варьируем объекты, мы получаем отображение из пар объектов в множества
``доказательств.'' Это отображение функториально --- контравариантно в первом
аргументе и ковариантно во втором. Мы можем смотреть на него как на установление
глобального отношения между объектами в категории. Это отношение
описывается hom-функтором:
\[\cat{C}(-, =) \Colon \cat{C}^\mathit{op}\times{}\cat{C} \to \Set\]
В общем случае любой функтор типа этого может быть интерпретирован как установление
отношения между объектами в категории. Отношение может также включать две
разные категории $\cat{C}$ и $\cat{D}$. Функтор, который описывает
такое отношение, имеет следующую сигнатуру и называется профунктором:
\[p \Colon \cat{D}^\mathit{op}\times{}\cat{C} \to \Set\]
Математики говорят, что это профунктор из $\cat{C}$ в $\cat{D}$
(обратите внимание на инверсию) и используют зачёркнутую стрелку как символ для него:
\[\cat{C} \nrightarrow \cat{D}\]
Вы можете думать о профункторе как о \newterm{доказательно-релевантном отношении}
между объектами $\cat{C}$ и объектами $\cat{D}$, где элементы
множества символизируют доказательства отношения. Когда $p\ a\ b$
пусто, нет отношения между $a$ и $b$. Имейте
в виду, что отношения не должны быть симметричными.

Другая полезная интуиция --- обобщение идеи, что
эндофунктор --- контейнер. Значение профунктора типа
$p\ a\ b$ могло бы тогда рассматриваться как контейнер $b$,
которые проиндексированы элементами типа $a$. В частности, элемент
hom-профунктора --- функция из $a$ в $b$.

В Haskell профунктор определяется как конструктор типа с двумя аргументами
\code{p}, оснащённый методом, называемым \code{dimap}, который поднимает
пару функций, первая идёт в ``неправильном'' направлении:

\src{snippet01}
Функториальность профунктора говорит нам, что если у нас есть доказательство,
что \code{a} связано с \code{b}, то мы получаем доказательство, что
\code{c} связано с \code{d}, пока есть морфизм из
\code{c} в \code{a} и другой из \code{b} в \code{d}. Или
мы можем думать о первой функции как переводящей новые ключи в старые
ключи, а о второй функции как модифицирующей содержимое
контейнера.

Для профункторов, действующих внутри одной категории, мы можем извлечь довольно много
информации из диагональных элементов типа $p\ a\ a$. Мы
можем доказать, что $b$ связано с $c$, пока у нас есть
пара морфизмов $b \to a$ и
$a \to c$. Ещё лучше, мы можем использовать единственный морфизм, чтобы
достичь недиагональных значений. Например, если у нас есть морфизм
$f \Colon a \to b$, мы можем поднять пару
$\langle f, \idarrow[b] \rangle$, чтобы пойти из $p\ b\ b$ в
$p\ a\ b$:

\src{snippet02}
Или мы можем поднять пару $\langle \idarrow[a], f \rangle$, чтобы пойти
из $p\ a\ a$ в $p\ a\ b$:

\src{snippet03}

\section{Динатуральные преобразования}

Поскольку профункторы --- функторы, мы можем определить естественные преобразования
между ними стандартным способом. Во многих случаях, однако, достаточно
определить отображение между диагональными элементами двух профункторов. Такое
преобразование называется динатуральным преобразованием, при условии, что оно
удовлетворяет коммутирующим условиям, которые отражают два способа, которыми мы можем
соединить диагональные элементы с недиагональными. Динатуральное
преобразование между двумя профункторами $p$ и $q$, которые
являются членами категории функторов ${[}\cat{C}^\mathit{op}\times{}\cat{C}, \Set{]}$, --- это
семейство морфизмов:
\[\alpha_a \Colon p\ a\ a \to q\ a\ a\]
для которого следующая диаграмма коммутирует для любого $f \Colon a \to b$:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/end.jpg}
\end{figure}

\noindent
Обратите внимание, что это строго слабее, чем условие естественности. Если
$\alpha$ были естественным преобразованием в
${[}\cat{C}^\mathit{op}\times{}\cat{C}, \Set{]}$, вышеуказанная диаграмма могла бы быть сконструирована
из двух квадратов естественности и одного условия функториальности (профунктор
$q$ сохраняющий композицию):

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/end-1.jpg}
\end{figure}

\noindent
Обратите внимание, что компонента естественного преобразования $\alpha$ в
${[}\cat{C}^\mathit{op}\times{}\cat{C}, \Set{]}$ индексируется парой объектов
$\alpha_{a b}$. Динатуральное преобразование, с другой стороны,
индексируется одним объектом, поскольку оно только отображает диагональные элементы
соответствующих профункторов.

\section{Концы}

Теперь мы готовы продвинуться от ``алгебры'' к тому, что можно было бы считать
``исчислением'' теории категорий. Исчисление концов (и коконцов)
заимствует идеи и даже некоторую нотацию из традиционного исчисления. В
частности, коконец может пониматься как бесконечная сумма или
интеграл, тогда как конец похож на бесконечное произведение. Есть
даже что-то, напоминающее дельта-функцию Дирака.

Конец --- обобщение предела, с функтором, заменённым
профунктором. Вместо конуса у нас есть клин. Основание клина
образовано диагональными элементами профунктора $p$. Вершина
клина --- объект (здесь множество, поскольку мы рассматриваем
профункторы со значениями в $\Set$), а стороны --- семейство
функций, отображающих вершину в множества в основании. Вы можете думать об
этом семействе как об одной полиморфной функции --- функции, которая
полиморфна в своём типе возврата:
\[\alpha \Colon \forall a\ .\ \mathit{apex} \to p\ a\ a\]
В отличие от конусов, внутри клина у нас нет никаких функций, которые бы
соединяли вершины основания. Однако, как мы видели ранее, для данного любого
морфизма $f \Colon a \to b$ в $\cat{C}$ мы можем соединить и
$p\ a\ a$, и $p\ b\ b$ с общим множеством
$p\ a\ b$. Поэтому мы настаиваем, чтобы следующая диаграмма
коммутировала:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/end-2.jpg}
\end{figure}

\noindent
Это называется \newterm{условием клина}. Оно может быть записано как:
\[p\ \idarrow[a]\ f \circ \alpha_a = p\ f\ \idarrow[b] \circ \alpha_b\]
Или, используя нотацию Haskell:

\src{snippet04}
Теперь мы можем продолжить с универсальной конструкцией и определить конец
$p$ как универсальный клин --- множество $e$ вместе с
семейством функций $\pi$ таким, что для любого другого клина с
вершиной $e'$ и семейством $\alpha$ существует уникальная функция
$h \Colon e' \to e$, которая заставляет все треугольники коммутировать:
\[\pi_a \circ h = \alpha_a\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/end-21.jpg}
\end{figure}

\noindent
Символ для конца --- знак интеграла, с ``интегрируемой
переменной'' в позиции индекса:
\[\int_c p\ c\ c\]
Компоненты $\pi$ называются проекционными отображениями для конца:
\[\pi_a \Colon \int_c p\ c\ c \to p\ a\ a\]
Заметьте, что если $\cat{C}$ --- дискретная категория (никаких морфизмов, кроме
тождеств), конец --- просто глобальное произведение всех диагональных входов
$p$ по всей категории $\cat{C}$. Позже я покажу вам,
что в более общем случае есть отношение между концом
и этим произведением через эквалайзер.

В Haskell формула конца переводится напрямую в универсальный
квантификатор:

\src{snippet05}
Строго говоря, это просто произведение всех диагональных элементов
$p$, но условие клина удовлетворено автоматически из-за
\urlref{https://bartoszmilewski.com/2017/04/11/profunctor-parametricity/}{параметричности}. Для любой функции
$f \Colon a \to b$ условие клина читается:

\src{snippet06}
или с аннотациями типов:

\begin{snipv}
dimap f id\textsubscript{b} . pi\textsubscript{b} = dimap id\textsubscript{a} f . pi\textsubscript{a}
\end{snipv}
где обе стороны уравнения имеют тип:

\src{snippet07}
а \code{pi} --- полиморфная проекция:

\src{snippet08}
Здесь вывод типов автоматически выбирает правильную компоненту
\code{e}.

Так же, как мы смогли выразить весь набор условий коммутации
для конуса как одно естественное преобразование, аналогично мы можем сгруппировать все
условия клина в одно динатуральное преобразование. Для этого нам нужно
обобщение постоянного функтора $\Delta_c$ на постоянный
профунктор, который отображает все пары объектов в единственный объект $c$,
а все пары морфизмов в тождественный морфизм для этого объекта.
Клин --- динатуральное преобразование из этого функтора в профунктор
$p$. Действительно, шестиугольник динатуральности сжимается до ромба
клина, когда мы осознаём, что $\Delta_c$ поднимает все морфизмы в одну
тождественную функцию.

Концы также могут быть определены для целевых категорий, отличных от $\Set$,
но здесь мы будем рассматривать только профункторы со значениями в $\Set$ и их
концы.

\section{Концы как эквалайзеры}

Условие коммутации в определении конца может быть записано,
используя эквалайзер. Сначала давайте определим две функции (я использую нотацию
Haskell, потому что математическая нотация кажется менее дружественной к пользователю
в этом случае). Эти функции соответствуют двум сходящимся ветвям
условия клина:

\src{snippet09}[b]
Обе функции отображают диагональные элементы профунктора \code{p} в
полиморфные функции типа:

\src{snippet10}
Эти функции имеют разные типы. Однако мы можем унифицировать их типы,
если сформируем один большой тип произведения, собирая вместе все диагональные
элементы \code{p}:

\src{snippet11}
Функции \code{lambda} и \code{rho} индуцируют два отображения из
этого типа произведения:

\src{snippet12}
Конец \code{p} --- эквалайзер этих двух функций. Помните,
что эквалайзер выбирает наибольшее подмножество, на котором две функции
равны. В этом случае он выбирает подмножество произведения всех диагональных
элементов, для которых диаграммы клина коммутируют.

\section{Естественные преобразования как концы}

Самый важный пример конца --- множество естественных
преобразований. Естественное преобразование между двумя функторами
$F$ и $G$ --- семейство морфизмов, выбранных из hom-множеств
формы $\cat{C}(F a, G a)$. Если бы не условие естественности,
множество естественных преобразований было бы просто произведением
всех этих hom-множеств. На самом деле, в Haskell оно и есть:

\src{snippet13}
Причина, по которой это работает в Haskell, в том, что естественность следует из
параметричности. За пределами Haskell, однако, не все диагональные сечения
по таким hom-множествам дадут естественные преобразования. Но заметьте, что
отображение:
\[\langle a, b \rangle \to \cat{C}(F a, G b)\]
--- профунктор, так что имеет смысл изучить его конец. Это условие
клина:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/end1.jpg}
\end{figure}

\noindent
Давайте просто выберем один элемент из множества $\int_c \cat{C}(F c, G c)$.
Две проекции отобразят этот элемент в две компоненты
конкретного преобразования, назовём их:
\begin{align*}
  \tau_a & \Colon F a \to G a \\
  \tau_b & \Colon F b \to G b
\end{align*}
В левой ветви мы поднимаем пару морфизмов
$\langle \idarrow[a], G f \rangle$, используя hom-функтор. Вы
можете вспомнить, что такой подъём реализуется как одновременная пред- и
пост-композиция. При действии на $\tau_a$ поднятая пара даёт нам:
\[G f \circ \tau_a \circ \idarrow[a]\]
Другая ветвь диаграммы даёт нам:
\[\idarrow[b] \circ \tau_b \circ F f\]
Их равенство, требуемое условием клина, --- не что иное, как
условие естественности для $\tau$.

\section{Коконцы}
Как ожидалось, двойственное концу называется коконцом. Он конструируется
из двойственного клину, называемого коклином (произносится ко-клин, не
корова-клин).

\begin{figure}[H]
  \centering
  \includegraphics[width=0.25\textwidth]{images/end-31.jpg}
  \caption{Угловатая корова?}
\end{figure}

\noindent
Символ для коконца --- знак интеграла с ``интегрируемой
переменной'' в позиции надстрочного индекса:
\[\int^c p\ c\ c\]
Так же, как конец связан с произведением, коконец связан с
копроизведением, или суммой (в этом отношении он напоминает интеграл, который
является пределом суммы). Вместо того, чтобы иметь проекции, у нас есть инъекции,
идущие из диагональных элементов профунктора вниз к коконцу. Если бы
не условия коклина, мы могли бы сказать, что коконец
профунктора $p$ --- либо $p\ a\ a$, либо
$p\ b\ b$, либо $p\ c\ c$, и так далее. Или мы могли бы сказать, что
существует такое $a$, для которого коконец --- просто множество
$p\ a\ a$. Универсальный квантификатор, который мы использовали в
определении конца, превращается в экзистенциальный квантификатор для
коконца.

Вот почему в псевдо-Haskell мы бы определили коконец как:

\begin{snip}{text}
exists a. p a a
\end{snip}
Стандартный способ кодирования экзистенциальных квантификаторов в Haskell ---
использовать универсально квантифицированные конструкторы данных. Мы можем таким образом определить:

\src{snippet14}
Логика за этим в том, что должно быть возможно сконструировать коконец,
используя значение любого из семейства типов $p\ a\ a$, не важно,
какое $a$ мы выбрали.

Так же, как конец может быть определён, используя эквалайзер, коконец может быть
описан, используя \newterm{коэквалайзер}. Все условия коклина могут быть
суммированы взятием одного гигантского копроизведения $p\ a\ b$ для всех
возможных функций $b \to a$. В Haskell это было бы
выражено как экзистенциальный тип:

\src{snippet15}
Есть два способа вычисления этого типа суммы, подняв функцию,
используя \code{dimap} и применив её к профунктору $p$:

\src{snippet16}
где \code{DiagSum} --- сумма диагональных элементов $p$:

\src{snippet17}
Коэквалайзер этих двух функций --- коконец. Коэквалайзер
получается из \code{DiagSum p} идентификацией значений, которые
получаются применением \code{lambda} или \code{rho} к одному и тому же
аргументу. Здесь аргумент --- пара, состоящая из функции
$b \to a$ и элемента $p\ a\ b$.
Применение \code{lambda} и \code{rho} производит два потенциально
разных значения типа \code{DiagSum p}. В коконце эти
два значения идентифицированы, заставляя условие коклина автоматически
удовлетворяться.

Процесс идентификации связанных элементов в множестве формально
известен как взятие частного. Чтобы определить частное, нам нужно
\newterm{отношение эквивалентности} $\sim$, отношение, которое
рефлексивно, симметрично и транзитивно:
\begin{align*}
   & a \sim a                                                         \\
   & \text{если}\ a \sim b\ \text{то}\ b \sim a                       \\
   & \text{если}\ a \sim b\ \text{и}\ b \sim c\ \text{то}\ a \sim c
\end{align*}
Такое отношение разделяет множество на классы эквивалентности. Каждый класс
состоит из элементов, которые связаны друг с другом. Мы формируем частное
множество, выбирая одного представителя из каждого класса. Классический пример ---
определение рациональных чисел как пар целых чисел со следующим
отношением эквивалентности:
\[(a, b) \sim (c, d)\ \text{тогда и только тогда}\ a * d = b * c\]
Легко проверить, что это отношение эквивалентности. Пара
$(a, b)$ интерпретируется как дробь $\frac{a}{b}$, и
дроби, чьи числитель и знаменатель имеют общий делитель, идентифицированы. Рациональное число
--- класс эквивалентности таких дробей.

Вы можете вспомнить из нашего раннего обсуждения пределов и копределов, что
hom-функтор непрерывен, то есть он сохраняет пределы. Двойственно, контравариантный
hom-функтор превращает копределы в пределы. Эти свойства
могут быть обобщены на концы и коконцы, которые являются обобщением
пределов и копределов, соответственно. В частности, мы получаем очень полезное
тождество для конвертации коконцов в концы:
\[\Set(\int^x p\ x\ x, c) \cong \int_x \Set(p\ x\ x, c)\]
Давайте посмотрим на него в псевдо-Haskell:

\begin{snipv}
(exists x. p x x) -> c \ensuremath{\cong} forall x. p x x -> c
\end{snipv}
Оно говорит нам, что функция, которая принимает экзистенциальный тип, эквивалентна
полиморфной функции. Это имеет полный смысл, потому что такая
функция должна быть подготовлена обработать любой из типов, который может быть
закодирован в экзистенциальном типе. Это тот же принцип, который говорит нам,
что функция, которая принимает тип суммы, должна быть реализована как клауза
case, с кортежем обработчиков, по одному для каждого типа, присутствующего в
сумме. Здесь тип суммы заменён коконцом, а семейство обработчиков
становится концом, или полиморфной функцией.

\section{Ниндзя-лемма Ёнеды}

Множество естественных преобразований, которое появляется в лемме Ёнеды, может
быть закодировано, используя конец, приводя к следующей формулировке:
\[\int_z \Set(\cat{C}(a, z), F z) \cong F a\]
Есть также двойственная формула:
\[\int^z \cat{C}(z, a)\times{}F z \cong F a\]
Это тождество сильно напоминает формулу для дельта-функции
Дирака (функция $\delta(a - z)$, или, скорее, распределение, которое
имеет бесконечный пик в $a = z$). Здесь hom-функтор играет
роль дельта-функции.

Вместе эти два тождества иногда называются ниндзя-леммой Ёнеды.

Чтобы доказать вторую формулу, мы будем использовать следствие
вложения Ёнеды, которое утверждает, что два объекта изоморфны тогда и только тогда, когда
их hom-функторы изоморфны. Другими словами, $a \cong b$ тогда и
только тогда, когда существует естественное преобразование типа:
\[[\cat{C}, \Set](\cat{C}(a, -), \cat{C}(b, =))\]
которое является изоморфизмом.

Мы начинаем с вставки левой стороны тождества, которое мы хотим
доказать, внутрь hom-функтора, который идёт в некоторый произвольный объект
$c$:
\[\Set(\int^z \cat{C}(z, a)\times{}F z, c)\]
Используя аргумент непрерывности, мы можем заменить коконец концом:
\[\int_z \Set(\cat{C}(z, a)\times{}F z, c)\]
Теперь мы можем использовать сопряжение между произведением и
экспоненциалом:
\[\int_z \Set(\cat{C}(z, a), c^{(F z)})\]
Мы можем ``выполнить интегрирование'', используя лемму Ёнеды, чтобы получить:
\[c^{(F a)}\]
(Обратите внимание, что мы использовали контравариантную версию леммы Ёнеды,
поскольку функтор $c^{(F z)}$ контравариантен в $z$.)
Этот экспоненциальный объект изоморфен hom-множеству:
\[\Set(F a, c)\]
Наконец, мы используем вложение Ёнеды, чтобы прийти к
изоморфизму:
\[\int^z \cat{C}(z, a)\times{}F z \cong F a\]

\section{Композиция профункторов}

Давайте исследуем далее идею, что профунктор описывает отношение
--- более точно, доказательно-релевантное отношение, означающее, что множество
$p\ a\ b$ представляет множество доказательств, что $a$ связано
с $b$. Если у нас есть два отношения $p$ и $q$, мы можем
попытаться скомпозировать их. Мы скажем, что $a$ связано с $b$
через композицию $q$ после $p$, если существует
промежуточный объект $c$ такой, что оба $q\ b\ c$ и
$p\ c\ a$ непусты. Доказательства этого нового отношения --- все
пары доказательств индивидуальных отношений. Следовательно, с
пониманием, что экзистенциальный квантификатор соответствует коконцу,
а декартово произведение двух множеств соответствует ``парам
доказательств'', мы можем определить композицию профункторов, используя следующую
формулу:
\[(q \circ p)\ a\ b = \int^c p\ c\ a\times{}q\ b\ c\]
Вот эквивалентное определение Haskell из
\code{Data.Profunctor.Composition} после некоторого переименования:

\src{snippet18}
Это использует синтаксис обобщённого алгебраического типа данных, или \acronym{GADT}, в котором
свободная типовая переменная (здесь \code{c}) автоматически экзистенциально
квантифицируется. (Раскаррированный) конструктор данных \code{Procompose}
таким образом эквивалентен:

\begin{snip}{text}
exists c. (q a c, p c b)
\end{snip}
Единица так определённой композиции --- hom-функтор --- это
немедленно следует из ниндзя-леммы Ёнеды. Имеет смысл,
следовательно, задать вопрос, есть ли категория, в которой
профункторы служат морфизмами. Ответ положительный, с оговоркой,
что оба закона ассоциативности и тождества для композиции профункторов
выполняются только с точностью до естественного изоморфизма. Такая категория, где законы
верны с точностью до изоморфизма, называется бикатегорией (которая более общая,
чем $\cat{2}$-категория). Так что у нас есть бикатегория $\cat{Prof}$, в которой
объекты --- категории, морфизмы --- профункторы, а морфизмы между
морфизмами (т.е., двуклетки) --- естественные преобразования. На самом деле можно
пойти даже дальше, потому что кроме профункторов у нас также есть обычные
функторы как морфизмы между категориями. Категория, которая имеет два типа
морфизмов, называется двойной категорией.

Профункторы играют важную роль в библиотеке линз Haskell и в
библиотеке стрелок.
