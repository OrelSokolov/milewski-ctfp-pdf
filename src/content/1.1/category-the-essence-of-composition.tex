% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{К}{атегория} --- это смехотворно простая концепция.
Категория состоит из \newterm{объектов} и \newterm{стрелок}, которые идут между ними. Вот
почему категории так легко представить графически. Объект можно
нарисовать как круг или точку, а стрелку\ldots{} как стрелку. (Просто
для разнообразия я иногда буду рисовать объекты как поросят, а стрелки как
фейерверки.) Но суть категории --- это \emph{композиция}. Или, если хотите,
суть композиции --- это категория. Стрелки композируются, так что
если у вас есть стрелка из объекта $A$ в объект $B$, и ещё одна стрелка из
объекта $B$ в объект $C$, то должна существовать стрелка --- их композиция
--- которая идёт из $A$ в $C$.

\begin{figure}
  \centering
  \includegraphics[width=0.8\textwidth]{images/img_1330.jpg}
  \caption{В категории, если есть стрелка из $A$ в $B$ и стрелка из $B$ в $C$,
    то должна также существовать прямая стрелка из $A$ в $C$, которая является их композицией. Эта диаграмма не является полной
    категорией, потому что в ней отсутствуют тождественные морфизмы (см. далее).}
\end{figure}

\section{Стрелки как функции}

Это уже слишком много абстрактной чепухи? Не отчаивайтесь. Давайте поговорим
о конкретике. Думайте о стрелках, которые также называются \newterm{морфизмами}, как о
функциях. У вас есть функция $f$, которая принимает аргумент типа $A$ и
возвращает $B$. У вас есть другая функция $g$, которая принимает $B$ и возвращает $C$.
Вы можете скомпозировать их, передав результат $f$ в $g$. Вы только что
определили новую функцию, которая принимает $A$ и возвращает $C$.

В математике такая композиция обозначается маленьким кружком между
функциями: $g \circ f$. Обратите внимание на порядок композиции справа налево. Для некоторых
людей это сбивает с толку. Вы можете быть знакомы с нотацией конвейера в
Unix, как в:

\begin{snip}{text}
lsof | grep Chrome
\end{snip}
или шеврон \code{>>} в F\#, которые оба
идут слева направо. Но в математике и в Haskell функции
композируются справа налево. Помогает, если вы читаете $g \circ f$ как ``g \emph{после} f.''

Давайте сделаем это ещё более явным, написав немного кода на C. У нас есть одна
функция \code{f}, которая принимает аргумент типа \code{A} и
возвращает значение типа \code{B}:

\begin{snip}{text}
B f(A a);
\end{snip}
и другая:

\begin{snip}{text}
C g(B b);
\end{snip}
Их композиция:

\begin{snip}{text}
C g_after_f(A a)
{
    return g(f(a));
}
\end{snip}
Здесь, опять же, вы видите композицию справа налево: \code{g(f(a))}; на этот
раз в C.

Хотел бы я сказать вам, что в стандартной библиотеке C++ есть шаблон,
который принимает две функции и возвращает их композицию, но
его нет. Так что давайте попробуем немного Haskell для разнообразия. Вот
объявление функции из A в B:

\src{snippet01}
Аналогично:

\src{snippet02}
Их композиция:

\src{snippet03}
Как только вы увидите, насколько просты вещи в Haskell, неспособность выразить
прямолинейные функциональные концепции в C++ немного смущает. На самом
деле, Haskell позволит вам использовать символы Unicode, поэтому вы можете написать
композицию как:
% don't 'mathify' this block
\begin{snip}{text}
g ◦ f
\end{snip}

Вы даже можете использовать Unicode двойные двоеточия и стрелки:
% don't 'mathify' this block
\begin{snipv}
f \ensuremath{\Colon} A → B
\end{snipv}
Итак, вот первый урок Haskell: двойное двоеточие означает ``имеет тип
\ldots{}'' Тип функции создаётся вставкой стрелки между
двумя типами. Вы композируете две функции, вставляя точку между ними
(или круг Unicode).

\section{Свойства композиции}

Есть два чрезвычайно важных свойства, которым должна удовлетворять композиция в любой
категории.

\begin{enumerate}
  \item
        Композиция ассоциативна. Если у вас есть три морфизма, $f$, $g$ и $h$,
        которые можно скомпозировать (то есть их объекты совпадают друг с другом), вам
        не нужны скобки для их композиции. В математической нотации это
        выражается как:
        \[h \circ (g \circ f) = (h \circ g) \circ f = h \circ g \circ f\]
        В (псевдо) Haskell:

        \src{snippet04}[b]
        (Я сказал ``псевдо'', потому что равенство не определено для функций.)

        Ассоциативность довольно очевидна при работе с функциями, но может
        быть не так очевидна в других категориях.

  \item
        Для каждого объекта $A$ существует стрелка, которая является единицей композиции.
        Эта стрелка замыкается из объекта на себя. Быть единицей композиции
        означает, что при композиции с любой стрелкой, которая либо начинается в $A$, либо заканчивается
        в $A$, соответственно, она возвращает ту же стрелку. Единичная стрелка для
        объекта A называется $\idarrow[A]$ (\newterm{тождество} на $A$). В математической
        нотации, если $f$ идёт из $A$ в $B$, то
        \[f \circ \idarrow[A] = f\]
        и
        \[\idarrow[B] \circ f = f\]
\end{enumerate}
При работе с функциями тождественная стрелка реализуется как
тождественная функция, которая просто возвращает свой аргумент.
Реализация одинакова для каждого типа, что означает, что эта функция
универсально полиморфна. В C++ мы могли бы определить её как шаблон:

\begin{snip}{cpp}
template<class T> T id(T x) { return x; }
\end{snip}
Конечно, в C++ ничто не настолько просто, потому что вы должны учитывать
не только то, что вы передаёте, но и как (то есть по значению, по
ссылке, по константной ссылке, перемещением и так далее).

В Haskell тождественная функция является частью стандартной библиотеки
(называемой Prelude). Вот её объявление и определение:

\src{snippet05}
Как видите, полиморфные функции в Haskell --- это кусок пирога. В
объявлении вы просто заменяете тип на типовую переменную. Вот
хитрость: имена конкретных типов всегда начинаются с заглавной буквы,
имена типовых переменных начинаются со строчной буквы. Так что здесь
\code{a} обозначает все типы.

Определения функций в Haskell состоят из имени функции,
за которым следуют формальные параметры --- здесь только один, \code{x}. Тело
функции следует за знаком равенства. Эта лаконичность часто шокирует
новичков, но вы быстро увидите, что это имеет полный смысл. Определение функции
и вызов функции --- это хлеб с маслом функционального
программирования, поэтому их синтаксис сведён к минимуму. Не только нет
скобок вокруг списка аргументов, но и нет запятых
между аргументами (вы увидите это позже, когда мы определим функции с
несколькими аргументами).

Тело функции всегда является выражением --- в функциях нет
операторов. Результат функции --- это это выражение ---
здесь просто \code{x}.

Это завершает наш второй урок Haskell.

Условия тождественности можно записать (опять же, в псевдо-Haskell) как:

\src{snippet06}
Вы можете задаться вопросом: зачем кому-то беспокоиться о
тождественной функции --- функции, которая ничего не делает? Тогда опять же, зачем
нам беспокоиться о числе ноль? Ноль --- это символ ничего. Древние
римляне имели систему счисления без нуля, и они смогли построить
отличные дороги и акведуки, некоторые из которых сохранились до наших дней.

Нейтральные значения, такие как ноль или $\id$, чрезвычайно полезны при
работе с символьными переменными. Вот почему римляне не очень хорошо знали
алгебру, тогда как арабы и персы, которые были знакомы с
концепцией нуля, знали. Так что тождественная функция становится очень полезной как
аргумент или возвращаемое значение функции высшего порядка. Функции высшего порядка
--- это то, что делает возможным символьные манипуляции с функциями.
Они являются алгеброй функций.

Подводя итог: категория состоит из объектов и стрелок (морфизмов).
Стрелки могут быть скомпозированы, и композиция ассоциативна. Каждый объект
имеет тождественную стрелку, которая служит единицей при композиции.

\section{Композиция --- суть программирования}

Функциональные программисты имеют особый способ подхода к проблемам. Они
начинают с вопросов очень в дзен-стиле. Например, при проектировании
интерактивной программы они бы спросили: что такое взаимодействие? При
реализации игры жизни Конвея они, вероятно, размышляли бы о
смысле жизни. В этом духе я собираюсь спросить: что такое программирование?
На самом базовом уровне программирование --- это о том, чтобы говорить компьютеру, что
делать. ``Возьми содержимое адреса памяти x и добавь его к
содержимому регистра EAX.'' Но даже когда мы программируем на ассемблере,
инструкции, которые мы даём компьютеру, являются выражением чего-то
более значимого. Мы решаем нетривиальную проблему (если бы она была
тривиальной, нам не нужна была бы помощь компьютера). И как мы решаем
проблемы? Мы разлагаем большие проблемы на меньшие проблемы. Если
меньшие проблемы всё ещё слишком велики, мы разлагаем их дальше, и так
далее. Наконец, мы пишем код, который решает все маленькие проблемы. А затем
приходит суть программирования: мы композируем эти части кода, чтобы
создать решения для больших проблем. Декомпозиция не имела бы смысла,
если бы мы не могли собрать части обратно.

Этот процесс иерархической декомпозиции и рекомпозиции не
навязан нам компьютерами. Он отражает ограничения человеческого
разума. Наш мозг может справиться только с небольшим количеством концепций одновременно.
Одна из самых цитируемых работ в психологии,
\urlref{http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two}{Магическое
  число семь плюс-минус два}, постулировала, что мы можем держать только
$7 \pm 2$ ``кусков'' информации в наших умах. Детали нашего
понимания человеческой краткосрочной памяти могут меняться, но мы
знаем наверняка, что она ограничена. Суть в том, что мы не способны
справиться с супом из объектов или спагетти из кода. Нам нужна
структура не потому, что хорошо структурированные программы приятно смотреть,
а потому, что иначе наш мозг не может их эффективно обработать. Мы
часто описываем какой-то кусок кода как элегантный или красивый, но то, что мы
на самом деле имеем в виду, это то, что его легко обработать нашим ограниченным человеческим разумом.
Элегантный код создаёт куски правильного размера и в
правильном количестве для нашей умственной пищеварительной системы, чтобы ассимилировать
их.

Так какие же правильные куски для композиции программ? Их
площадь поверхности должна расти медленнее, чем их объём. (Мне нравится эта
аналогия из-за интуиции, что площадь поверхности геометрического
объекта растёт с квадратом его размера --- медленнее, чем объём,
который растёт с кубом его размера.) Площадь поверхности --- это
информация, которая нам нужна для композиции кусков. Объём --- это
информация, которая нам нужна для их реализации. Идея в том, что, как только
кусок реализован, мы можем забыть о деталях его
реализации и сосредоточиться на том, как он взаимодействует с другими кусками. В
объектно-ориентированном программировании поверхность --- это объявление класса
объекта или его абстрактный интерфейс. В функциональном программировании это
объявление функции. (Я немного упрощаю, но это
суть.)

Теория категорий экстремальна в том смысле, что она активно отговаривает нас
от заглядывания внутрь объектов. Объект в теории категорий --- это
абстрактная туманная сущность. Всё, что вы когда-либо можете узнать о нём, это как он
относится к другим объектам --- как он соединяется с ними стрелками. Так
интернет-поисковые системы ранжируют веб-сайты, анализируя входящие и
исходящие ссылки (за исключением случаев, когда они жульничают). В объектно-ориентированном программировании
идеализированный объект виден только через его абстрактный интерфейс (чистая
поверхность, без объёма), с методами, играющими роль стрелок. В момент,
когда вам нужно копаться в реализации объекта, чтобы
понять, как скомпозировать его с другими объектами, вы потеряли
преимущества вашей парадигмы программирования.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Реализуйте, насколько сможете, тождественную функцию в вашем любимом
        языке (или втором любимом, если ваш любимый язык ---
        Haskell).
  \item
        Реализуйте функцию композиции в вашем любимом языке. Она принимает
        две функции в качестве аргументов и возвращает функцию, которая является их
        композицией.
  \item
        Напишите программу, которая пытается проверить, что ваша функция композиции
        уважает тождество.
  \item
        Является ли всемирная паутина категорией в каком-либо смысле? Являются ли ссылки морфизмами?
  \item
        Является ли Facebook категорией, с людьми как объектами и дружбами как
        морфизмами?
  \item
        Когда ориентированный граф является категорией?
\end{enumerate}
