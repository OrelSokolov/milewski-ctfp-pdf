% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{Т}{еперь, когда вы знаете}, что такое функтор, и видели несколько примеров, давайте
посмотрим, как мы можем строить более крупные функторы из меньших. В частности,
интересно посмотреть, какие конструкторы типов (которые соответствуют
отображениям между объектами в категории) могут быть расширены до функторов
(которые включают отображения между морфизмами).

\section{Бифункторы}

Поскольку функторы --- это морфизмы в $\Cat$ (категории категорий),
многие интуиции о морфизмах --- и функциях в частности ---
применимы к функторам также. Например, так же, как вы можете иметь
функцию двух аргументов, вы можете иметь функтор двух аргументов, или
\newterm{бифунктор}. На объектах бифунктор отображает каждую пару объектов,
один из категории $\cat{C}$, а другой из категории $\cat{D}$, в объект в категории
$\cat{E}$. Заметьте, что это просто говорит, что это отображение из
\newterm{декартова произведения} категорий $\cat{C}\times{}\cat{D}$ в $\cat{E}$.

\begin{figure}[H]
  \centering\includegraphics[width=0.3\textwidth]{images/bifunctor.jpg}
\end{figure}

\noindent
Это довольно прямолинейно. Но функториальность означает, что бифунктор
должен отображать морфизмы также. На этот раз, однако, он должен отображать пару
морфизмов, один из $\cat{C}$ и один из $\cat{D}$, в морфизм в $\cat{E}$.

Опять же, пара морфизмов --- это просто единственный морфизм в произведении
категорий $\cat{C}\times{}\cat{D}$. Мы определяем морфизм в декартовом произведении категорий
как пару морфизмов, которая идёт из одной пары объектов в другую
пару объектов. Эти пары морфизмов могут быть скомпозированы очевидным
способом:
\[(f, g) \circ (f', g') = (f \circ f', g \circ g')\]
Композиция ассоциативна, и у неё есть тождество --- пара
тождественных морфизмов $(\id, \id)$. Так что декартово произведение категорий
действительно является категорией.

Более простой способ думать о бифункторах --- рассматривать их как функторы в
каждом аргументе отдельно. Поэтому вместо того, чтобы транслировать функториальные законы ---
ассоциативность и сохранение тождества --- от функторов к бифункторам,
было бы достаточно проверить их отдельно для каждого аргумента. Однако, в общем случае,
отдельная функториальность недостаточна для доказательства совместной функториальности. Категории, в которых
совместная функториальность не выполняется, называются \newterm{премоноидальными}.

Давайте определим бифунктор в Haskell. В этом случае все три категории
одинаковы: категория типов Haskell. Бифунктор --- это конструктор типа,
который принимает два аргумента типа. Вот определение класса типов
\code{Bifunctor}, взятое прямо из библиотеки
\code{Control.Bifunctor}:

\src{snippet01}

\begin{figure}[H]
  \centering\includegraphics[width=0.3\textwidth]{images/bimap.jpg}
  \caption{bimap}
\end{figure}

Типовая переменная \code{f} представляет бифунктор. Вы можете увидеть, что
во всех сигнатурах типов она всегда применяется к двум аргументам типа.
Первая сигнатура типа определяет \code{bimap}: отображение двух функций
одновременно. Результат --- это поднятая функция,
\code{(f a b -> f c d)}, действующая на типы,
сгенерированные конструктором типов бифунктора. Есть реализация по умолчанию
для \code{bimap} в терминах \code{first} и
\code{second}. (Как упоминалось ранее, это не всегда работает, потому что
два отображения могут не коммутировать, то есть \code{first g . second h} может не
быть таким же, как \code{second h . first g}.)


\noindent
Две другие сигнатуры типов, \code{first} и \code{second}, ---
это два \code{fmap}а, свидетельствующие о функториальности \code{f} в
первом и втором аргументе, соответственно.

\begin{figure}[H]
  \centering
  \begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics[width=0.65\textwidth]{images/first.jpg} % first figure itself
    \caption{first}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics[width=0.6\textwidth]{images/second.jpg} % second figure itself
    \caption{second}
  \end{minipage}
\end{figure}

\noindent
Определение класса типов предоставляет реализации по умолчанию для обоих
в терминах \code{bimap}.

При объявлении экземпляра \code{Bifunctor} у вас есть выбор:
либо реализовать \code{bimap} и принять значения по умолчанию для
\code{first} и \code{second}, либо реализовать оба \code{first}
и \code{second} и принять значение по умолчанию для \code{bimap} (конечно,
вы можете реализовать все три, но тогда вы должны убедиться,
что они связаны друг с другом таким образом).

\section{Бифункторы произведения и копроизведения}

Важный пример бифунктора --- это категорное произведение ---
произведение двух объектов, которое определяется \hyperref[products-and-coproducts]{универсальной
  конструкцией}. Если произведение существует для любой пары объектов,
отображение из этих объектов в произведение бифункториально. Это верно
в общем случае, и в Haskell в частности. Вот экземпляр \code{Bifunctor}
для конструктора пары --- простейшего типа произведения:

\src{snippet02}[b]
Выбора немного: \code{bimap} просто применяет первую
функцию к первому компоненту, а вторую функцию ко второму
компоненту пары. Код практически пишется сам, учитывая
типы:

\src{snippet03}
Действие бифунктора здесь состоит в том, чтобы делать пары типов, например:

\begin{snip}{haskell}
(,) a b = (a, b)
\end{snip}
По двойственности, копроизведение, если оно определено для каждой пары объектов в
категории, также является бифунктором. В Haskell это проиллюстрировано тем, что
конструктор типа \code{Either} является экземпляром
\code{Bifunctor}:

\src{snippet04}[b]
Этот код также пишется сам.

Теперь, помните, когда мы говорили о моноидальных категориях? Моноидальная
категория определяет бинарный оператор, действующий на объекты, вместе с
единичным объектом. Я упоминал, что $\Set$ --- это моноидальная категория по
отношению к декартову произведению, с одноэлементным множеством как единицей. И это
также моноидальная категория по отношению к дизъюнктному объединению, с пустым
множеством как единицей. Что я не упоминал, так это то, что одно из требований
для моноидальной категории состоит в том, что бинарный оператор должен быть бифунктором. Это
очень важное требование --- мы хотим, чтобы моноидальное произведение было
совместимо со структурой категории, которая определяется
морфизмами. Теперь мы на один шаг ближе к полному определению
моноидальной категории (нам всё ещё нужно узнать о естественности, прежде чем мы
сможем добраться туда).

\section{Функториальные алгебраические типы данных}

Мы видели несколько примеров параметризованных типов данных, которые оказались
функторами --- мы смогли определить \code{fmap} для них.
Сложные типы данных конструируются из более простых типов данных. В
частности, алгебраические типы данных (\acronym{ADT}) создаются с использованием сумм и
произведений. Мы только что видели, что суммы и произведения функториальны. Мы
также знаем, что функторы композируются. Так что если мы можем показать, что основные
строительные блоки \acronym{ADT} функториальны, мы будем знать, что параметризованные
\acronym{ADT} тоже функториальны.

Так каковы строительные блоки параметризованных алгебраических типов данных?
Во-первых, есть элементы, которые не имеют зависимости от параметра типа
функтора, как \code{Nothing} в \code{Maybe}, или \code{Nil}
в \code{List}. Они эквивалентны функтору \code{Const}.
Помните, функтор \code{Const} игнорирует свой параметр типа (действительно,
\emph{второй} параметр типа, который представляет для нас интерес,
первый хранится постоянным).

Затем есть элементы, которые просто инкапсулируют сам параметр типа,
как \code{Just} в \code{Maybe}. Они эквивалентны
тождественному функтору. Я упоминал тождественный функтор ранее, как
тождественный морфизм в \emph{Cat}, но не дал его определение в
Haskell. Вот оно:

\src{snippet05}

\src{snippet06}
Вы можете думать об \code{Identity} как о простейшем возможном контейнере,
который всегда хранит только одно (неизменяемое) значение типа \code{a}.

Всё остальное в алгебраических структурах данных конструируется из этих
двух примитивов с использованием произведений и сумм.

С этим новым знанием давайте по-новому взглянем на конструктор типа \code{Maybe}:

\src{snippet07}
Это сумма двух типов, и теперь мы знаем, что сумма функториальна.
Первая часть, \code{Nothing}, может быть представлена как \code{Const ()},
действующий на \code{a} (первый параметр типа \code{Const} установлен
в unit --- позже мы увидим более интересные применения \code{Const}).
Вторая часть --- это просто другое имя для тождественного функтора. Мы
могли бы определить \code{Maybe}, с точностью до изоморфизма, как:

\src{snippet08}
Итак, \code{Maybe} --- это композиция бифунктора \code{Either}
с двумя функторами, \code{Const ()} и \code{Identity}.
(\code{Const} --- это действительно бифунктор, но здесь мы всегда используем его
частично применённым.)

Мы уже видели, что композиция функторов --- это функтор --- мы
можем легко убедить себя, что то же самое верно для бифункторов. Всё,
что нам нужно, это выяснить, как композиция бифунктора с двумя
функторами работает на морфизмах. Для данных двух морфизмов мы просто поднимаем один
с одним функтором, а другой с другим функтором. Затем мы поднимаем
результирующую пару поднятых морфизмов с бифунктором.

Мы можем выразить эту композицию в Haskell. Давайте определим тип данных,
который параметризован бифунктором \code{bf} (это типовая переменная,
которая является конструктором типа, принимающим два типа в качестве аргументов), двумя
функторами \code{fu} и \code{gu} (конструкторы типов, принимающие по одной
переменной типа каждый), и двумя обычными типами \code{a} и \code{b}.
Мы применяем \code{fu} к \code{a} и \code{gu} к \code{b}, а затем
применяем \code{bf} к получившимся двум типам:

\src{snippet09}
Это композиция на объектах, или типах. Обратите внимание, как в Haskell мы
применяем конструкторы типов к типам, точно так же, как мы применяем функции к
аргументам. Синтаксис одинаков.

Если вы немного потерялись, попробуйте применить \code{BiComp} к
\code{Either}, \code{Const ()}, \code{Identity}, \code{a} и
\code{b}, в этом порядке. Вы восстановите нашу голую версию
\code{Maybe b} (\code{a} игнорируется).

Новый тип данных \code{BiComp} --- это бифунктор в \code{a} и
\code{b}, но только если \code{bf} сам является \code{Bifunctor}, а
\code{fu} и \code{gu} являются \code{Functor}ами. Компилятор должен
знать, что будет доступно определение \code{bimap} для
\code{bf}, и определения \code{fmap} для \code{fu} и
\code{gu}. В Haskell это выражается как предусловие в
объявлении экземпляра: набор ограничений класса, за которым следует двойная
стрелка:

\src{snippet10}[b]
Реализация \code{bimap} для \code{BiComp} дана в
терминах \code{bimap} для \code{bf} и двух \code{fmap} для
\code{fu} и \code{gu}. Компилятор автоматически выводит все
типы и выбирает правильные перегруженные функции, когда бы ни
использовался \code{BiComp}.

\code{x} в определении \code{bimap} имеет тип:

\src{snippet11}
что довольно словоохотливо. Внешний \code{bimap} пробивается через
внешний слой \code{bf}, а два \code{fmap}а копают под
\code{fu} и \code{gu}, соответственно. Если типы \code{f1}
и \code{f2} ---

\src{snippet12}
то конечный результат имеет тип
\code{bf (fu a') (gu b')}:

\src{snippet13}[b]
Если вам нравятся пазлы, эти виды манипуляций с типами могут
предоставить часы развлечений.

Итак, оказывается, что нам не нужно было доказывать, что \code{Maybe} --- это
функтор --- этот факт следует из способа, которым он был сконструирован как сумма
двух функториальных примитивов.

Проницательный читатель может задать вопрос: если выведение
экземпляра \code{Functor} для алгебраических типов данных настолько механично,
не может ли это быть автоматизировано и выполнено компилятором? Действительно, может, и
так оно и есть. Вам нужно включить конкретное расширение Haskell, включив
эту строку в начале вашего исходного файла:

\begin{snip}{haskell}
{-# LANGUAGE DeriveFunctor #-}
\end{snip}
и затем добавить \code{deriving Functor} к вашей структуре данных:

\begin{snip}{haskell}
data Maybe a = Nothing | Just a deriving Functor
\end{snip}
и соответствующий \code{fmap} будет реализован для вас.

Регулярность алгебраических структур данных делает возможным вывод
экземпляров не только \code{Functor}, но и нескольких других классов типов,
включая класс типов \code{Eq}, который я упоминал ранее. Также есть
опция научить компилятор выводить экземпляры ваших
собственных классов типов, но это немного более продвинуто. Идея, однако, та же
самая: вы предоставляете поведение для основных строительных блоков и сумм
и произведений, и позволяете компилятору выяснить остальное.

\section{Функторы в C++}

Если вы программист на C++, вы, очевидно, сами по себе в плане
реализации функторов. Однако вы должны быть способны распознать
некоторые типы алгебраических структур данных в C++. Если такая структура данных
сделана в виде обобщённого шаблона, вы должны быть способны быстро реализовать
\code{fmap} для неё.

Давайте посмотрим на структуру данных дерева, которую мы бы определили в
Haskell как рекурсивный тип суммы:

\src{snippet14}
Как я упоминал ранее, один способ реализации типов суммы в C++ ---
через иерархии классов. Было бы естественно в объектно-ориентированном
языке реализовать \code{fmap} как виртуальную функцию базового
класса \code{Functor}, а затем переопределить её во всех подклассах.
К сожалению, это невозможно, потому что \code{fmap} --- это шаблон,
параметризованный не только типом объекта, на который он действует (указатель
\code{this}), но и типом возврата функции,
которая к нему применена. Виртуальные функции не могут быть шаблонизированы в
C++. Мы реализуем \code{fmap} как обобщённую свободную функцию, и мы
заменим сопоставление с образцом на \code{dynamic\_cast}.

Базовый класс должен определять хотя бы одну виртуальную функцию, чтобы
поддерживать динамическое приведение, поэтому мы сделаем деструктор виртуальным (что является
хорошей идеей в любом случае):

\begin{snip}{cpp}
template<class T>
struct Tree {
    virtual ~Tree() {}
};
\end{snip}
\code{Leaf} --- это просто функтор \code{Identity} в маскировке:

\begin{snip}{cpp}
template<class T>
struct Leaf : public Tree<T> {
    T _label;
    Leaf(T l) : _label(l) {}
};
\end{snip}
\code{Node} --- это тип произведения:

\begin{snip}{cpp}
template<class T>
struct Node : public Tree<T> {
    Tree<T> * _left;
    Tree<T> * _right;
    Node(Tree<T> * l, Tree<T> * r) : _left(l), _right(r) {}
};
\end{snip}
При реализации \code{fmap} мы используем динамическую диспетчеризацию
по типу \code{Tree}. Случай \code{Leaf} применяет версию
\code{fmap} из \code{Identity}, а случай \code{Node}
рассматривается как бифунктор, скомпозированный с двумя копиями
функтора \code{Tree}. Как программист на C++, вы, вероятно, не привыкли
анализировать код в этих терминах, но это хорошее упражнение в категорном
мышлении.

\begin{snip}{cpp}
template<class A, class B>
Tree<B> * fmap(std::function<B(A)> f, Tree<A> * t) {
    Leaf<A> * pl = dynamic_cast <Leaf<A>*>(t);
    if (pl)
        return new Leaf<B>(f (pl->_label));
    Node<A> * pn = dynamic_cast<Node<A>*>(t);
    if (pn)
        return new Node<B>( fmap<A>(f, pn->_left)
                          , fmap<A>(f, pn->_right));
    return nullptr;
}
\end{snip}
Для простоты я решил игнорировать вопросы управления памятью и ресурсами,
но в производственном коде вы, вероятно, использовали бы умные указатели
(уникальные или общие, в зависимости от вашей политики).

Сравните это с реализацией Haskell для \code{fmap}:

\src{snippet15}
Эта реализация также может быть автоматически выведена компилятором.

\section{Функтор Writer}

Я обещал, что вернусь к \hyperref[kleisli-categories]{категории Клейсли},
которую я описал ранее. Морфизмы в этой категории были
представлены как ``приукрашенные'' функции, возвращающие структуру данных \code{Writer}.

\src{snippet16}
Я сказал, что приукрашивание как-то связано с эндофункторами. И
действительно, конструктор типа \code{Writer} функториален по
\code{a}. Нам даже не нужно реализовывать \code{fmap} для него,
потому что это просто простой тип произведения.

Но какая связь между категорией Клейсли и функтором --- в
общем случае? Категория Клейсли, будучи категорией, определяет композицию и
тождество. Позвольте мне напомнить вам, что композиция задаётся оператором рыбы:

\src{snippet17}
а тождественный морфизм --- функцией, называемой \code{return}:

\src{snippet18}
Оказывается, что если вы посмотрите на типы этих двух функций достаточно
долго (и я имею в виду, \emph{долго} достаточно), вы можете найти способ объединить
их, чтобы произвести функцию с правильной сигнатурой типа, служащую как
\code{fmap}. Вот так:

\src{snippet19}
Здесь оператор рыбы объединяет две функции: одна из них ---
знакомый \code{id}, а другая --- лямбда, которая применяет
\code{return} к результату действия \code{f} на аргумент лямбды.
Самая сложная часть для понимания --- это, вероятно, использование
\code{id}. Разве аргумент оператора рыбы не должен быть
функцией, которая принимает ``нормальный'' тип и возвращает приукрашенный тип?
Ну, не совсем. Никто не говорит, что \code{a} в
\code{a -> Writer b} должен быть ``нормальным'' типом. Это
типовая переменная, поэтому она может быть чем угодно, в частности, может быть приукрашенным
типом, как \code{Writer b}.

Так что \code{id} примет \code{Writer a} и превратит его в
\code{Writer a}. Оператор рыбы выловит значение
\code{a} и передаст его как \code{x} в лямбду. Там \code{f}
превратит его в \code{b}, а \code{return} приукрасит его,
делая его \code{Writer b}. Собирая всё вместе, мы получаем
функцию, которая принимает \code{Writer a} и возвращает \code{Writer b},
именно то, что \code{fmap} должен производить.

Обратите внимание, что этот аргумент очень общий: вы можете заменить
\code{Writer} на любой конструктор типа. Пока он поддерживает оператор рыбы
и \code{return}, вы можете определить \code{fmap} также. Итак,
приукрашивание в категории Клейсли всегда является функтором. (Однако не
каждый функтор порождает категорию Клейсли.)

Вы можете задаться вопросом, тот ли самый \code{fmap}, который мы только что определили,
\code{fmap}, который компилятор вывел бы для нас с
\code{deriving Functor}. Интересно, что да. Это благодаря
способу, которым Haskell реализует полиморфные функции. Это называется
\newterm{параметрический полиморфизм}, и это источник так называемых
\newterm{теорем бесплатно}. Одна из этих теорем говорит, что если существует
реализация \code{fmap} для данного конструктора типа, которая
сохраняет тождество, то она должна быть уникальной.

\section{Ковариантные и контравариантные функторы}

Теперь, когда мы рассмотрели функтор writer, давайте вернёмся к функтору reader.
Он был основан на частично применённом конструкторе типа функции-стрелки:

\src{snippet20}
Мы можем переписать его как синоним типа:

\src{snippet21}
для которого экземпляр \code{Functor}, как мы видели ранее, читается:

\src{snippet22}
Но так же, как конструктор типа пары или конструктор типа \code{Either},
конструктор типа функции принимает два аргумента типа.
Пара и \code{Either} были функториальны в обоих аргументах --- они были
бифункторами. Является ли конструктор функции тоже бифунктором?

Давайте попытаемся сделать его функториальным в первом аргументе. Мы начнём с
синонима типа --- он как \code{Reader}, но с
аргументами перевёрнутыми:

\src{snippet23}
На этот раз мы фиксируем тип возврата, \code{r}, и варьируем тип аргумента,
\code{a}. Давайте посмотрим, можем ли мы как-то согласовать типы, чтобы
реализовать \code{fmap}, который имел бы следующую сигнатуру
типа:

\src{snippet24}
С всего двумя функциями, принимающими \code{a} и возвращающими, соответственно,
\code{b} и \code{r}, просто нет способа построить функцию,
принимающую \code{b} и возвращающую \code{r}! Было бы иначе, если бы мы
могли как-то инвертировать первую функцию, так что она принимала \code{b} и
возвращала \code{a} вместо этого. Мы не можем инвертировать произвольную функцию, но
мы можем пойти в противоположную категорию.

Краткий повтор: для каждой категории $\cat{C}$ существует двойственная категория
$\cat{C}^\mathit{op}$. Это категория с теми же объектами, что и
$\cat{C}$, но со всеми стрелками, обращёнными вспять.

Рассмотрим функтор, который идёт между $\cat{C}^\mathit{op}$ и
некоторой другой категорией $\cat{D}$:
\[F \Colon \cat{C}^\mathit{op} \to \cat{D}\]
Такой функтор отображает морфизм $f^\mathit{op} \Colon a \to b$ в
$\cat{C}^\mathit{op}$ в морфизм $F f^\mathit{op} \Colon F a \to F b$ в $\cat{D}$. Но морфизм
$f^\mathit{op}$ тайно соответствует некоторому морфизму
$f \Colon b \to a$ в исходной категории $\cat{C}$. Обратите внимание на
инверсию.

Теперь $F$ --- это обычный функтор, но есть другое отображение, которое мы можем
определить на основе $F$, которое не является функтором --- давайте назовём его
$G$. Это отображение из $\cat{C}$ в $\cat{D}$. Оно отображает объекты так же,
как $F$, но когда дело доходит до отображения морфизмов, оно
обращает их. Оно принимает морфизм $f \Colon b \to a$ в $\cat{C}$, отображает
его сначала в противоположный морфизм $f^\mathit{op} \Colon a \to b$,
а затем использует функтор $F$ на нём, чтобы получить $F f^\mathit{op} \Colon F a \to F b$.

Учитывая, что $F a$ --- то же самое, что $G a$, и $F b$ ---
то же самое, что $G b$, всё путешествие может быть описано как: $G f \Colon (b \to a) \to (G a \to G b)$
Это ``функтор с изюминкой.'' Отображение категорий, которое инвертирует
направление морфизмов таким образом, называется
\emph{контравариантным функтором}. Обратите внимание, что контравариантный функтор ---
это просто обычный функтор из противоположной категории. Обычные функторы,
кстати --- те, которые мы изучали до сих пор --- называются
\emph{ковариантными} функторами.

\begin{figure}[H]
  \centering
  \includegraphics[width=40mm]{images/contravariant.jpg}
\end{figure}

\noindent
Вот класс типов, определяющий контравариантный функтор (действительно, контравариантный
\emph{эндо}функтор) в Haskell:

\src{snippet25}
Наш конструктор типа \code{Op} является его экземпляром:

\src{snippet26}
Обратите внимание, что функция \code{f} вставляет себя \emph{перед} (то
есть справа от) содержимого \code{Op} --- функции
\code{g}.

Определение \code{contramap} для \code{Op} может быть сделано ещё
более лаконичным, если вы заметите, что это просто оператор композиции функций
с аргументами, перевёрнутыми. Есть специальная функция для переворачивания
аргументов, называемая \code{flip}:

\src{snippet27}
С ней мы получаем:

\src{snippet28}

\section{Профункторы}

Мы видели, что оператор функции-стрелки контравариантен в своём
первом аргументе и ковариантен во втором. Есть ли имя для такого
зверя? Оказывается, что если целевая категория --- $\Set$, такой
зверь называется \newterm{профунктор}. Поскольку контравариантный функтор
эквивалентен ковариантному функтору из противоположной категории,
профунктор определяется как:
\[\cat{C}^\mathit{op} \times \cat{D} \to \Set\]
Поскольку, в первом приближении, типы Haskell --- это множества, мы применяем имя
\code{Profunctor} к конструктору типа \code{p} с двумя аргументами,
который контра-функториален в первом аргументе и функториален во
втором. Вот соответствующий класс типов, взятый из
библиотеки \code{Data.Profunctor}:

\src{snippet29}[b]
Все три функции поставляются с реализациями по умолчанию. Так же, как с
\code{Bifunctor}, при объявлении экземпляра \code{Profunctor}
у вас есть выбор: либо реализовать \code{dimap} и принять
значения по умолчанию для \code{lmap} и \code{rmap}, либо реализовать оба
\code{lmap} и \code{rmap} и принять значение по умолчанию для
\code{dimap}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/dimap.jpg}
  \caption{dimap}
\end{figure}

\noindent
Теперь мы можем утверждать, что оператор функции-стрелки --- это экземпляр
\code{Profunctor}:

\src{snippet30}[b]
Профункторы имеют своё применение в библиотеке линз Haskell. Мы
увидим их снова, когда будем говорить о концах и коконцах.

\section{Hom-функтор}

Приведённые выше примеры являются отражением более общего утверждения, что
отображение, которое принимает пару объектов $a$ и $b$ и
назначает ей множество морфизмов между ними, hom-множество
$\cat{C}(a, b)$, --- это функтор. Это функтор из произведения
категорий $\cat{C}^\mathit{op}\times{}\cat{C}$ в категорию множеств, $\Set$.

Давайте определим его действие на морфизмы. Морфизм в
$\cat{C}^\mathit{op}\times{}\cat{C}$ --- это пара морфизмов из $\cat{C}$:
\begin{gather*}
  f \Colon a' \to a \\
  g \Colon b \to b'
\end{gather*}
Подъём этой пары должен быть морфизмом (функцией) из множества
$\cat{C}(a, b)$ в множество $\cat{C}(a', b')$. Просто выберите
любой элемент $h$ из $\cat{C}(a, b)$ (это морфизм из
$a$ в $b$) и назначьте ему:
\[g \circ h \circ f\]
который является элементом $\cat{C}(a', b')$.

Как вы можете видеть, hom-функтор --- это частный случай профунктора.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Покажите, что тип данных:

        \begin{snip}{haskell}
data Pair a b = Pair a b
\end{snip}

        является бифунктором. Для дополнительного кредита реализуйте все три метода
        \code{Bifunctor} и используйте уравнительное рассуждение, чтобы показать, что эти
        определения совместимы с реализациями по умолчанию, когда
        они могут быть применены.
  \item
        Покажите изоморфизм между стандартным определением \code{Maybe}
        и этим десахаризованным определением:

        \begin{snip}{haskell}
type Maybe' a = Either (Const () a) (Identity a)
\end{snip}

        Подсказка: Определите два отображения между двумя реализациями. Для
        дополнительного кредита покажите, что они являются обратными друг другу, используя
        уравнительное рассуждение.
  \item
        Давайте попробуем другую структуру данных. Я называю её \code{PreList}, потому что
        это предшественник \code{List}. Она заменяет рекурсию параметром типа
        \code{b}.

        \begin{snip}{haskell}
data PreList a b = Nil | Cons a b
\end{snip}

        Вы можете восстановить наше более раннее определение \code{List},
        рекурсивно применяя \code{PreList} к самому себе (мы увидим, как это
        делается, когда будем говорить о неподвижных точках).

        Покажите, что \code{PreList} --- это экземпляр \code{Bifunctor}.
  \item
        Покажите, что следующие типы данных определяют бифункторы в \code{a} и
        \code{b}:

        \begin{snip}{haskell}
data K2 c a b = K2 c

data Fst a b = Fst a

data Snd a b = Snd b
\end{snip}

        Для дополнительного кредита проверьте ваши решения против статьи Конора Макбрайда
        \urlref{http://strictlypositive.org/CJ.pdf}{Clowns to the Left of
          me, Jokers to the Right}.
  \item
        Определите бифунктор на языке, отличном от Haskell. Реализуйте
        \code{bimap} для обобщённой пары на этом языке.
  \item
        Должен ли \code{std::map} рассматриваться как бифунктор или профунктор в
        двух аргументах шаблона \code{Key} и \code{T}? Как бы вы
        переделали этот тип данных, чтобы сделать его таковым?
\end{enumerate}
