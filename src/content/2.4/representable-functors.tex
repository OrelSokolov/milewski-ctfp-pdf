% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{П}{ришло время} нам немного поговорить о множествах.
Математики имеют отношения любви-ненависти с теорией множеств. Это
ассемблер математики --- по крайней мере, так было. Теория
категорий пытается отойти от теории множеств в какой-то степени. Например,
известный факт, что множество всех множеств не существует, но категория
всех множеств, $\Set$, существует. Так что это хорошо. С другой стороны, мы предполагаем, что
морфизмы между любыми двумя объектами в категории образуют множество. Мы даже
назвали его hom-множеством. Чтобы быть справедливым, есть ветвь теории категорий,
где морфизмы не образуют множества. Вместо этого они являются объектами в другой
категории. Эти категории, которые используют hom-объекты, а не hom-множества,
называются \newterm{обогащёнными} категориями. В том, что следует, однако, мы будем
придерживаться категорий с добрыми старомодными hom-множествами.

Множество --- это ближайшая вещь к безликой капле, которую вы можете получить вне
категорных объектов. Множество имеет элементы, но вы не можете сказать много об
этих элементах. Если у вас конечное множество, вы можете посчитать элементы.
Вы можете как бы посчитать элементы бесконечного множества, используя кардинальные
числа. Множество натуральных чисел, например, меньше, чем
множество вещественных чисел, даже если оба бесконечны. Но, может быть,
удивительно, множество рациональных чисел того же размера, что и множество
натуральных чисел.

Кроме этого, вся информация о множествах может быть закодирована в
функциях между ними --- особенно обратимых, называемых
изоморфизмами. Для всех практических целей изоморфные множества
идентичны. Прежде чем я призову гнев фундаментальных математиков, позвольте
мне объяснить, что различие между равенством и изоморфизмом имеет
фундаментальное значение. На самом деле это одна из главных забот
последней ветви математики, гомотопической теории типов (HoTT). Я
упоминаю HoTT, потому что это чистая математическая теория, которая берёт
вдохновение из вычислений, и один из её главных сторонников, Владимир
Воеводский, имел крупное прозрение, изучая доказатель теорем Coq.
Взаимодействие между математикой и программированием идёт в обоих направлениях.

Важный урок о множествах в том, что нормально сравнивать множества
непохожих элементов. Например, мы можем сказать, что данное множество естественных
преобразований изоморфно некоторому множеству морфизмов, потому что множество ---
это просто множество. Изоморфизм в этом случае просто означает, что для каждого естественного
преобразования из одного множества существует уникальный морфизм из другого
множества и наоборот. Они могут быть спарены друг с другом. Вы не можете
сравнивать яблоки с апельсинами, если они объекты из разных
категорий, но вы можете сравнивать множества яблок с множествами апельсинов.
Часто преобразование категорной проблемы в теоретико-множественную проблему
даёт нам необходимое понимание или даже позволяет нам доказать ценные теоремы.

\section{Hom-функтор}

Каждая категория поставляется с каноническим семейством отображений в
$\Set$. Эти отображения на самом деле функторы, поэтому они сохраняют
структуру категории. Давайте построим одно такое отображение.

Давайте зафиксируем один объект $a$ в $\cat{C}$ и выберем другой объект
$x$ также в $\cat{C}$. Hom-множество $\cat{C}(a, x)$ --- это множество,
объект в $\Set$. Когда мы варьируем $x$, сохраняя $a$
фиксированным, $\cat{C}(a, x)$ также будет варьироваться в $\Set$. Таким образом, у нас есть
отображение из $x$ в $\Set$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/hom-set.jpg}
\end{figure}

\noindent
Если мы хотим подчеркнуть факт, что мы рассматриваем hom-множество как
отображение в его втором аргументе, мы используем нотацию $\cat{C}(a, -)$
с тире, служащим как заполнитель для аргумента.

Это отображение объектов легко расширяется на отображение морфизмов.
Давайте возьмём морфизм $f$ в $\cat{C}$ между двумя произвольными
объектами $x$ и $y$. Объект $x$ отображается в
множество $\cat{C}(a, x)$, а объект $y$ отображается в
$\cat{C}(a, y)$ под отображением, которое мы только что определили. Если это
отображение должно быть функтором, $f$ должен быть отображён в функцию
между двумя множествами: $\cat{C}(a, x) \to \cat{C}(a, y)$

Давайте определим эту функцию поточечно, то есть для каждого аргумента
отдельно. Для аргумента мы должны выбрать произвольный элемент
$\cat{C}(a, x)$ --- давайте назовём его $h$. Морфизмы
композиционны, если они совпадают конец к концу. Так случается, что цель
$h$ совпадает с источником $f$, так что их композиция:
\[f \circ h \Colon a \to y\]
--- это морфизм, идущий из $a$ в $y$. Следовательно, он
член $\cat{C}(a, y)$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/hom-functor.jpg}
\end{figure}

\noindent
Мы только что нашли нашу функцию из $\cat{C}(a, x)$ в
$\cat{C}(a, y)$, которая может служить образом $f$. Если нет
опасности путаницы, мы запишем эту поднятую функцию как: $\cat{C}(a, f)$,
а её действие на морфизм $h$ как:
\[\cat{C}(a, f) h = f \circ h\]
Поскольку эта конструкция работает в любой категории, она также должна работать в
категории типов Haskell. В Haskell hom-функтор лучше известен
как функтор \code{Reader}:

\src{snippet01}

\src{snippet02}
Теперь давайте рассмотрим, что происходит, если вместо фиксации источника
hom-множества мы фиксируем цель. Другими словами, мы задаём вопрос, является ли
отображение $\cat{C}(-, a)$ также функтором. Да, но вместо того, чтобы быть ковариантным, оно
контравариантно. Это потому, что тот же вид совпадения морфизмов конец
к концу приводит к посткомпозиции с $f$; а не к
предкомпозиции, как было в случае с $\cat{C}(a, -)$.

Мы уже видели этот контравариантный функтор в Haskell. Мы назвали его
\code{Op}:

\src{snippet03}

\src{snippet04}
Наконец, если мы позволим обоим объектам варьироваться, мы получим профунктор
$\cat{C}(-, =)$, который контравариантен в первом аргументе и
ковариантен во втором (чтобы подчеркнуть факт, что два аргумента
могут варьироваться независимо, мы используем двойное тире как второй заполнитель).
Мы видели этот профунктор раньше, когда говорили о функториальности:

\src{snippet05}
Важный урок в том, что это наблюдение выполняется в любой категории:
отображение объектов в hom-множества функториально. Поскольку контравариантность
эквивалентна отображению из противоположной категории, мы можем утверждать этот
факт лаконично как:
\[C(-, =) \Colon \cat{C}^\mathit{op} \times \cat{C} \to \Set\]

\section{Представимые функторы}

Мы видели, что для каждого выбора объекта $a$ в $\cat{C}$
мы получаем функтор из $\cat{C}$ в $\Set$. Этот вид
структуро-сохраняющего отображения в $\Set$ часто называется
\newterm{представлением}. Мы представляем объекты и морфизмы
$\cat{C}$ как множества и функции в $\Set$.

Функтор $\cat{C}(a, -)$ сам иногда называется представимым.
Более обобщённо, любой функтор $F$, который естественно изоморфен
hom-функтору для некоторого выбора $a$, называется
\newterm{представимым}. Такой функтор обязательно должен быть
со значениями в $\Set$, поскольку $\cat{C}(a, -)$ таков.

Я сказал раньше, что мы часто думаем об изоморфных множествах как об идентичных. Более
обобщённо, мы думаем об изоморфных \emph{объектах} в категории как об
идентичных. Это потому, что объекты не имеют структуры, кроме их
отношения к другим объектам (и себе) через морфизмы.

Например, мы ранее говорили о категории моноидов,
$\cat{Mon}$, которая была изначально смоделирована множествами. Но мы были осторожны,
чтобы выбрать как морфизмы только те функции, которые сохраняли моноидальную
структуру этих множеств. Так что если два объекта в $\cat{Mon}$
изоморфны, что означает, что между ними есть обратимый морфизм, они
имеют точно такую же структуру. Если бы мы заглянули в множества и функции,
на которых они основаны, мы бы увидели, что единичный элемент одного моноида
был отображён в единичный элемент другого, и что произведение двух
элементов было отображено в произведение их отображений.

То же рассуждение может быть применено к функторам. Функторы между двумя
категориями образуют категорию, в которой естественные преобразования играют
роль морфизмов. Так что два функтора изоморфны и могут рассматриваться как
идентичные, если между ними есть обратимое естественное преобразование.

Давайте проанализируем определение представимого функтора с этой
перспективы. Для того чтобы $F$ был представимым, мы требуем: должен
быть объект $a$ в $\cat{C}$; одно естественное преобразование $\alpha$ из
$\cat{C}(a, -)$ в $F$; другое естественное преобразование, $\beta$, в
противоположном направлении; и чтобы их композиция была тождественным
естественным преобразованием.

Давайте посмотрим на компоненту $\alpha$ в некотором объекте $x$. Это
функция в $\Set$:
\[\alpha_x \Colon \cat{C}(a, x) \to F x\]
Условие естественности для этого преобразования говорит нам, что для любого
морфизма $f$ из $x$ в $y$ следующая диаграмма
коммутирует:
\[F f \circ \alpha_x = \alpha_y \circ \cat{C}(a, f)\]
В Haskell мы бы заменили естественные преобразования полиморфными
функциями:

\src{snippet06}
с опциональным квантификатором \code{forall}. Условие естественности

\src{snippet07}
автоматически удовлетворено из-за параметричности (это одна из тех
теорем бесплатно, которые я упоминал ранее), с пониманием, что
\code{fmap} слева определён функтором $F$, тогда как
тот справа определён функтором reader. Поскольку
\code{fmap} для reader --- это просто предкомпозиция функций, мы можем быть ещё
более явными. Действуя на $h$, элемент $\cat{C}(a, x)$,
условие естественности упрощается до:

\src{snippet08}
Другое преобразование, \code{beta}, идёт в противоположном направлении:

\src{snippet09}
Оно должно уважать условия естественности, и оно должно быть обратным \code{alpha}:

\begin{snip}{text}
alpha . beta = id = beta . alpha
\end{snip}
Мы увидим позже, что естественное преобразование из $\cat{C}(a, -)$
в любой функтор со значениями в $\Set$ всегда существует, пока $F a$
непусто (лемма Ёнеды), но оно не обязательно обратимо.

Позвольте мне дать вам пример в Haskell с функтором списка и
\code{Int} как \code{a}. Вот естественное преобразование, которое делает
работу:

\src{snippet10}
Я произвольно выбрал число 12 и создал одноэлементный список
с ним. Затем я могу \code{fmap}ить функцию \code{h} над этим списком
и получить список типа, возвращаемого \code{h}. (На самом деле
есть столько таких преобразований, сколько есть списков целых чисел.)

Условие естественности эквивалентно композиционности
\code{map} (списочной версии \code{fmap}):

\src{snippet11}
Но если бы мы попытались найти обратное преобразование, нам пришлось бы идти
из списка произвольного типа \code{x} в функцию, возвращающую
\code{x}:

\src{snippet12}
Вы могли бы подумать об извлечении \code{x} из списка, например, используя
\code{head}, но это не сработает для пустого списка. Заметьте, что нет
выбора для типа \code{a} (вместо \code{Int}), который
сработал бы здесь. Так что функтор списка не представим.

Помните, когда мы говорили о Haskell (эндо-) функторах, похожих на
контейнеры? В том же духе мы можем думать о представимых функторах
как о контейнерах для хранения мемоизированных результатов вызовов функций (члены
hom-множеств в Haskell --- это просто функции). Представляющий
объект, тип $a$ в $\cat{C}(a, -)$, рассматривается как
тип ключа, с которым мы можем получить доступ к табулированным значениям функции.
Преобразование, которое мы назвали \code{alpha}, называется \code{tabulate}, а его
обратное, \code{beta}, называется \code{index}. Вот (немного упрощённое)
определение класса \code{Representable}:

\src{snippet13}
Обратите внимание, что представляющий тип, наш $a$, который называется
\code{Rep f} здесь, является частью определения
\code{Representable}. Звёздочка просто означает, что \code{Rep f} --- это
тип (в отличие от конструктора типа или других более экзотических видов).

Бесконечные списки, или потоки, которые не могут быть пустыми, представимы.

\src{snippet14}
Вы можете думать о них как о мемоизированных значениях функции, принимающей
\code{Integer} как аргумент. (Строго говоря, я должен был использовать
неотрицательные натуральные числа, но я не хотел усложнять код.)

Чтобы \code{tabulate} такую функцию, вы создаёте бесконечный поток
значений. Конечно, это возможно только потому, что Haskell ленив.
Значения вычисляются по требованию. Вы получаете доступ к мемоизированным значениям, используя
\code{index}:

\src{snippet15}
Интересно, что вы можете реализовать единую схему мемоизации для
покрытия целого семейства функций с произвольными типами возврата.

Представимость для контравариантных функторов аналогично определяется, за исключением
того, что мы сохраняем второй аргумент $\cat{C}(-, a)$ фиксированным. Или,
эквивалентно, мы можем рассматривать функторы из $\cat{C}^\mathit{op}$
в $\Set$, потому что $\cat{C}^\mathit{op}(a, -)$ --- то же самое, что
$\cat{C}(-, a)$.

Есть интересный поворот к представимости. Помните, что
hom-множества могут внутренне рассматриваться как экспоненциальные объекты в декартово
замкнутых категориях. Hom-множество $\cat{C}(a, x)$ эквивалентно
$x^a$, и для представимого функтора $F$ мы можем написать: $-^a = F$.

Давайте возьмём логарифм обеих сторон, просто ради удовольствия: $a = \mathbf{log}F$

Конечно, это чисто формальное преобразование, но если вы знаете некоторые
свойства логарифмов, это довольно полезно. В частности,
оказывается, что функторы, которые основаны на типах произведения, могут быть
представлены типами суммы, и что функторы типа суммы, в общем случае, не
представимы (пример: функтор списка).

Наконец, заметьте, что представимый функтор даёт нам две разные
реализации одной и той же вещи --- одна функция, одна структура
данных. Они имеют точно такое же содержимое --- те же значения
извлекаются с использованием тех же ключей. Это тот смысл ``одинаковости'', о котором я
говорил. Два естественно изоморфных функтора идентичны, насколько
их содержимое вовлечено. С другой стороны, два представления
часто реализуются по-разному и могут иметь разные характеристики производительности.
Мемоизация используется как улучшение производительности и
может привести к существенно сниженному времени выполнения. Возможность генерировать
разные представления одного и того же лежащего в основе вычисления очень
ценна на практике. Так что, удивительно, даже если она не заботится
о производительности вообще, теория категорий предоставляет множество возможностей для
исследования альтернативных реализаций, которые имеют практическую ценность.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Покажите, что hom-функторы отображают тождественные морфизмы в \emph{C} в
        соответствующие тождественные функции в $\Set$.
  \item
        Покажите, что \code{Maybe} не представим.
  \item
        Является ли функтор \code{Reader} представимым?
  \item
        Используя представление \code{Stream}, мемоизируйте функцию, которая возводит в квадрат
        свой аргумент.
  \item
        Покажите, что \code{tabulate} и \code{index} для \code{Stream}
        действительно являются обратными друг другу. (Подсказка: используйте индукцию.)
  \item
        Функтор:

        \begin{snip}{haskell}
Pair a = Pair a a
\end{snip}
        представим. Можете ли вы угадать тип, который его представляет? Реализуйте
        \code{tabulate} и \code{index}.
\end{enumerate}

\section{Библиография}

\begin{enumerate}
  \tightlist
  \item
        Видео Catsters о
        \urlref{https://www.youtube.com/watch?v=4QgjKUzyrhM}{представимых
          функторах}.
\end{enumerate}
