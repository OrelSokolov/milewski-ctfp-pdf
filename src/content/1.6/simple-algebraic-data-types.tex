
% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{М}{ы уже видели два основных} способа комбинирования типов: с помощью продукта и копродукта. Оказывается, что много данных структур в повседневном программировании можно построить, используя только эти два механизма. Это имеет важные практические последствия. Многие свойства данных структур являются композируемыми. Например, если вы знаете, как сравнивать значения базовых типов на равенство, и знаете, как обобщить эти сравнения для продуктовых и копродуктовых типов, вы можете автоматизировать вывод операторов равенства для составных типов. В Haskell можно автоматически выводить равенство, сравнение, преобразование в и из строк и многое другое для большей части составных типов.

Давайте подробнее рассмотрим продукт и сумма типов, как они проявляются в программировании.

\section{Произведение типов}

Каноническая реализация произведения двух типов в языке программирования — это пара. В Haskell пара является первичным типом-конструктором; в C++ это относительно сложный шаблон, определённый в стандартной библиотеке.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/pair.jpg}
\end{figure}

\noindent
Пары не являются строго коммутативными: пара \code{(Int, Bool)} не может быть заменена на пару \code{(Bool, Int)}, даже если они несут одинаковую информацию. Однако они коммутативны до изоморфизма — изоморфизм задаётся функцией \code{swap} (которая является своей собственной обратной функцией):

\src{snippet01}
Вы можете рассматривать две пары как просто использование другого формата для хранения одной и той же информации. Это похоже на big endian vs. little endian.

Вы можете объединить произвольное количество типов в продукт, вкладывая пары в пары, но есть более простой способ: вложенные пары эквивалентны кортежам. Это следствие того, что разные способы вложения пар изоморфны. Если вы хотите объединить три типа в продукт, \code{a}, \code{b} и \code{c}, в этом порядке, вы можете сделать это двумя способами:

\src{snippet02}

или
\src{snippet03}
Эти типы различны — вы не можете передать один в функцию, которая ожидает другой — но их элементы находятся в взаимно однозначном соответствии. Существует функция, которая отображает один в другой:

\src{snippet04}
и эта функция обратима:

\src{snippet05}
поэтому это изоморфизм. Это просто разные способы упаковки одной и той же информации.

Вы можете интерпретировать создание типа-продукта как бинарную операцию над типами. С этой точки зрения приведённый выше изоморфизм выглядит очень похоже на закон ассоциативности, который мы видели в моноидах:
\[(a * b) * c = a * (b * c)\]
За исключением того, что в случае моноида два способа композиции продуктов были равны, здесь они равны только «до изоморфизма».

Если мы можем мириться с изоморфизмами и не настаиваем на строгом равенстве, мы можем пойти ещё дальше и показать, что тип-единица, \code{()}, является единицей продукта таким же образом, как 1 является единицей умножения. Действительно, парирование значения какого-либо типа \code{a} с единицей не добавляет никакой информации. Тип:

\src{snippet06}
изоморфен \code{a}. Вот изоморфизм:

\src{snippet07}

\src{snippet08}
Эти наблюдения можно формализовать, сказав, что $\Set$ (категория множеств) является \newterm{моноидальной категорией}. Это категория, которая также является моноидом, в том смысле, что вы можете умножать объекты (здесь, брать их декартово произведение). Я расскажу больше о моноидальных категориях и дам полное определение в будущем.

Существует более общий способ определения типов-продуктов в Haskell — особенно, как мы увидим скоро, когда они комбинируются со суммами типов. Он использует именованные конструкторы с множеством аргументов. Например, пара может быть определена альтернативно как:

\src{snippet09}
Здесь \code{Pair a b} — это имя типа, параметризованного двумя другими типами, \code{a} и \code{b}; и \code{P} — это имя данных-конструктора. Вы определяете тип пары, передавая два типа в конструктор-тип \code{Pair}. Вы создаёте значение пары, передавая два значения соответствующих типов в конструктор \code{P}. Например, определим значение \code{stmt} как пару \code{String} и \code{Bool}:

\src{snippet10}
Первая строка — это сигнатура типа. Она использует конструктор-тип \code{Pair}, с \code{String} и \code{Bool}, заменяющими \code{a} и \code{b} в общем определении \code{Pair}. Вторая строка определяет фактическое значение, передавая конкретную строку и конкретный булево значение в конструктор данных \code{P}. Конструкторы-типы используются для построения типов; конструкторы-данные — для построения значений.

Поскольку пространства имён для конструкторов-типов и данных в Haskell разделены, вы часто видите одно и то же имя, используемое для обоих, как в:

\src{snippet11}
И если вы постараетесь достаточно сильно, вы можете даже рассмотреть встроенный тип пар как вариант этого вида объявления, где имя \code{Pair} заменяется бинарным оператором \code{(,)}. Фактически вы можете использовать \code{(,)} как любую другую именованную конструктор и создавать пары с помощью префиксной нотации:

\src{snippet12}
Аналогично, вы можете использовать \code{(,,)} для создания троек и так далее.

Вместо использования общих пар или кортежей, вы также можете определить конкретные именованные типы-продукты, как в:

\src{snippet13}
это просто продукт \code{String} и \code{Bool}, но он имеет собственное имя и конструктор. Преимущество этого стиля объявления заключается в том, что вы можете определить много типов, которые имеют одинаковое содержание, но разное значение и функциональность, и которые не могут заменять друг друга.

Программирование с использованием кортежей и конструкторов с несколькими аргументами может быть запутанным и склонным к ошибкам — отслеживание того, какой компонент представляет что. Часто предпочтительнее давать имена компонентам. Тип-продукт с именованными полями называется \newterm{записью} (record) в Haskell, и \code{struct} в C.

\section{Записи}

Давайте рассмотрим простой пример. Мы хотим описать химические элементы, объединяя две строки, имя и символ; и целое число, атомный номер; в один объект данных. Мы можем использовать кортеж \code{(String, String, Int)} и помнить, что компонент представляет, что. Мы извлекали бы компоненты с помощью сопоставления с образцом, как в этой функции, которая проверяет, является ли символ элемента префиксом его имени (как \textbf{He} является префиксом \textbf{Helium}):

\src{snippet14}
Этот код склонен к ошибкам, и его трудно читать и поддерживать. Гораздо лучше определить запись:

\src{snippet15}
Два представления изоморфны, как подтверждают эти две функции преобразования, которые являются обратными друг другу:

\src{snippet16}

\src{snippet17}
Обратите внимание, что имена полей записи также служат функциями для доступа к этим полям. Например, \code{atomicNumber e} извлекает поле \code{atomicNumber} из \code{e}. Мы используем \code{atomicNumber} как функцию типа:

\src{snippet18}
С использованием синтаксиса записи для \code{Element}, наша функция \code{startsWithSymbol} становится более читаемой:

\src{snippet19}
Мы даже могли бы использовать трюк Haskell, превращающий функцию \code{isPrefixOf} в инфиксный оператор, окружив его обратными кавычками, и сделать её почти как предложение:

\src{snippet20}
Скобки можно опустить в этом случае, потому что инфиксный оператор имеет меньший приоритет, чем вызов функции.

\section{Сумма типов}

Так же, как произведение в категории множеств порождает типы-продукты, копроизведение порождает типы-суммы. Каноническая реализация типа-суммы в Haskell:

\src{snippet21}
И как пары, \code{Either}s коммутативны (до изоморфизма), могут быть вложены, и порядок вложения несущественен (до изоморфизма). Таким образом, мы можем, например, определить сумму, эквивалентную тройке:

\src{snippet22}
и так далее.

Оказывается, что $\Set$ также является (симметричной) моноидальной категорией относительно копроизведения. Роль бинарной операции играет несвязное сумма, а роль единичного элемента — начальный объект. В терминах типов у нас есть \code{Either} как моноидальный оператор и \code{Void}, необитаемый тип, как его нейтральный элемент. Вы можете рассматривать \code{Either} как плюс, а \code{Void} как ноль. Действительно, добавление \code{Void} к типу-сумме не меняет его содержание. Например:

\src{snippet23}
изоморфен \code{a}. Это потому, что нет способа создать версию \code{Right} этого типа — нет значения типа \code{Void}. Единственные обитатели \code{Either a Void} создаются с помощью конструктора \code{Left} и просто инкапсулируют значение типа \code{a}. Таким образом, символически, $a + 0 = a$.

Сумма типов довольно распространена в Haskell, но их аналоги в C++, объединения или варианты, гораздо менее распространены. Есть несколько причин для этого.

Во-первых, самые простые сумма-типы — это перечисления и реализуются с помощью \code{enum} в C++. Эквивалент сумма-типа Haskell:

\src{snippet24}
это C++:

\begin{snip}{cpp}
enum { Red, Green, Blue };
\end{snip}
Даже более простой сумма-тип:

\src{snippet25}
это примитивный \code{bool} в C++.

Простые сумма-типы, кодирующие наличие или отсутствие значения, реализуются в C++ различными хитростями и «невозможными» значениями, такими как пустые строки, отрицательные числа, нулевые указатели и т.д. Этот вид опциональности, если он предназначен, выражается в Haskell с помощью типа \code{Maybe}:

\src{snippet26}
Тип \code{Maybe} — это сумма двух типов. Вы можете увидеть это, если разделите два конструктора на отдельные типы. Первый будет выглядеть так:

\src{snippet27}
Это перечисление с одним значением, называемым \code{Nothing}. Другими словами, это одиночный, который эквивалентен типу \code{()}. Вторая часть:

\src{snippet28}
это просто инкапсуляция типа \code{a}. Мы могли бы закодировать \code{Maybe} как:

\src{snippet29}
Более сложные сумма-типы часто подделываются в C++ с использованием указателей. Указатель может быть либо нулевым, либо указывать на значение определённого типа. Например, тип списка Haskell, который может быть определён как (рекурсивный) сумма-тип:

\src{snippet30}
можно перевести в C++ с использованием трюка с нулевым указателем для реализации пустого списка:

\begin{snip}{cpp}
template<class A>
class List {
    Node<A> * _head;
public:
    List() : _head(nullptr) {} // Nil
    List(A a, List<A> l)       // Cons
      : _head(new Node<A>(a, l))
    {}
};
\end{snip}
Обратите внимание, что два конструктора Haskell \code{Nil} и \code{Cons} переводятся в два перегруженных конструктора \code{List} с аналогичными аргументами (ни одного для \code{Nil}; и значение и список для \code{Cons}). Класс \code{List} не нуждается в метке для различения двух компонентов сумма-типа. Вместо этого он использует специальное значение \code{nullptr} для \code{\_head}, чтобы закодировать \code{Nil}.

Основное различие между типами Haskell и C++ заключается в том, что структуры данных Haskell неизменяемы. Если вы создадите объект с использованием одного определённого конструктора, объект будет всегда помнить, какой конструктор был использован и какие аргументы были переданы. Таким образом, объект \code{Maybe}, созданный как \code{Just "energy"}, никогда не станет \code{Nothing}. Аналогично, пустой список будет всегда пустым, а список из трёх элементов всегда будет иметь те же три элемента.

Именно эта неизменяемость делает создание обратимым. Зная объект, вы всегда можете разобрать его на части, использованные в его создании. Это разбор осуществляется с помощью сопоставления с образцом и повторно использует конструкторы как образцы. Аргументы конструктора, если они есть, заменяются переменными (или другими образцами).

Тип данных \code{List} имеет два конструктора, поэтому разбор произвольного \code{List} использует два образца, соответствующих этим конструкторам. Один соответствует пустому списку \code{Nil}, другой — списку, построенному с помощью \code{Cons}. Например, вот определение простой функции на \code{List}:

\src{snippet31}
Первая часть определения \code{maybeTail} использует конструктор \code{Nil} как образец и возвращает \code{Nothing}. Вторая часть использует конструктор \code{Cons} как образец. Она заменяет первый аргумент конструктора дикой картой, потому что мы не заинтересованы в нём. Второй аргумент \code{Cons} привязывается к переменной \code{t} (я буду называть эти вещи переменными, даже если строго говоря, они никогда не меняются: после привязки к выражению, переменная никогда не меняется). Возвращаемое значение — \code{Just t}. Теперь, в зависимости от того, как был создан ваш \code{List}, он будет соответствовать одному из предложений. Если он был создан с использованием \code{Cons}, то два аргумента, переданные ему, будут извлечены (и первый отброшен).

Даже более сложные сумма-типы реализуются в C++ с использованием полиморфных классовых иерархий. Семейство классов с общим предком может быть понято как один вариантный тип, в котором таблица виртуальных функций служит скрытой меткой. Что в Haskell делается сопоставлением с образцом и вызовом специализированного кода, в C++ достигается с помощью диспетчеризации вызова виртуальной функции на основе указателя таблицы виртуальных функций.

Вы редко видите \code{union} используемым как сумма-тип в C++ из-за серьёзных ограничений на то, что может быть помещено в объединение. Даже нельзя поместить \code{std::string} в объединение, потому что у него есть конструктор копирования.

\section{Алгебра типов}

Рассмотренные отдельно, типы-продукты и типы-суммы могут быть использованы для определения различных полезных структур данных, но настоящая сила проявляется при их комбинировании. Опять мы обращаемся к силе композиции.

Подведём итог того, что мы до сих пор узнали. Мы увидели две коммутативные моноидальные структуры, лежащие в основе системы типов: у нас есть типы-суммы с \code{Void} как нейтральным элементом, и типы-продукты с единичным типом, \code{()}, как нейтральным элементом. Мы хотим рассматривать их как аналоги сложения и умножения. В этой аналогии \code{Void} соответствовал бы нулю, а единица, \code{()}, — единице.

Давайте посмотрим, насколько далеко мы можем продлить эту аналогию. Например, дает ли умножение на ноль ноль? Иными словами, является ли тип-продукт с одной компонентой \code{Void} изоморфным \code{Void}? Например, возможно ли создать пару, скажем, \code{Int} и \code{Void}?

Для создания пары вам нужны два значения. Хотя вы легко можете придумать целое число, нет значения типа \code{Void}. Поэтому, для любого типа \code{a}, тип \code{(a, Void)} необитаем — не имеет значений — и, следовательно, эквивалентен \code{Void}. Другими словами, $a \times 0 = 0$.

Ещё одно, связывающее сложение и умножение, это свойство дистрибутивности:
$$a \times (b + c) = a \times b + a \times c$$
Действует ли это также для типов-продуктов и типов-сумм? Да, действует — до изоморфизмов, как обычно. Левая часть соответствует типу:

\src{snippet32}
а правая часть соответствует типу:

\src{snippet33}
Вот функция, которая преобразует их в одном направлении:

\src{snippet34}
а вот функция, которая идёт в обратном направлении:

\src{snippet35}
Клауза \code{case of} используется для сопоставления с образцом внутри функций. Каждый образец следует за стрелкой и выражением, которое оценивается, когда образец совпадает. Например, если вы вызовете \code{prodToSum} со значением:

\src{snippet36}
\code{e} в \code{case e of} будет равен \code{Left "Hi!"}. Он будет совпадать с образцом \code{Left y}, подставляя \code{"Hi!"} вместо \code{y}. Поскольку \code{x} уже был совпадён с \code{2}, результат клаузы \code{case of} и всей функции будет \code{Left (2, "Hi!")}, как ожидалось.

Я не буду доказывать, что эти две функции являются обратными друг другу, но если подумать, они должны быть! Они просто тривиально переупаковывают содержимое двух структур данных. Это та же самая информация, только другой формат.

Математики имеют название для двух таких переплетённых моноидов: это называется \newterm{полурingом}. Это не полный \newterm{ring}, потому что мы не можем определить вычитание типов. Поэтому полурing иногда называют \newterm{rig}, что является игрушкой на «ring без \emph{n}» (отрицательного). Но, несмотря на это, мы можем получить много пользы, переводя утверждения о, скажем, натуральных числах, которые образуют rig, в утверждения о типах. Вот таблица перевода с интересными пунктами:

\begin{longtable}[]{@{}ll@{}}
  \toprule
  Числа      & Типы\tabularnewline
  \midrule
  \endhead
  $0$          & \code{Void}\tabularnewline
  $1$          & \code{()}\tabularnewline
  $a + b$      & \code{data Either a b = Left a | Right b}\tabularnewline
  $a \times b$ & \code{(a, b)} или \code{data Pair a b = Pair a b}\tabularnewline
  $2 = 1 + 1$  & \code{data Bool = True | False}\tabularnewline
  $1 + a$      & \code{data Maybe a = Nothing | Just a}\tabularnewline
  \bottomrule
\end{longtable}

\noindent
Тип списка очень интересен, потому что он определяется как решение уравнения. Тип, который мы определяем, появляется с обеих сторон уравнения:

\src{snippet37}
Если мы выполним наши обычные подстановки, и также заменим \code{List a} на \code{x}, мы получим уравнение:

\begin{Verbatim}
  x = 1 + a * x
\end{Verbatim}
Мы не можем решить его с помощью традиционных алгебраических методов, потому что не можем вычитать или делить типы. Но мы можем попробовать серию подстановок, где мы продолжаем заменять \code{x} на правой стороне на \code{(1 + a*x)}, и использовать свойство дистрибутивности. Это приводит к следующей серии:

\begin{Verbatim}
  x = 1 + a*x
  x = 1 + a*(1 + a*x) = 1 + a + a*a*x
  x = 1 + a + a*a*(1 + a*x) = 1 + a + a*a + a*a*a*x
  ...
  x = 1 + a + a*a + a*a*a + a*a*a*a...
\end{Verbatim}
Мы заканчиваемся с бесконечной суммой продуктов (кортежей), которая может быть интерпретирована как: Список — это либо пустой, \code{1}; либо одиночный, \code{a}; либо пара, \code{a*a}; либо тройка, \code{a*a*a}; и так далее. Ну, это именно то, что такое список — строка из \code{a}s!

Спискам есть ещё многое, и мы вернёмся к ним и другим рекурсивным структурам данных после того, как узнаем о функторах и фиксированных точках.

Решение уравнений с символическими переменными — это алгебра! Это то, что даёт этим типам их имя: алгебраические типы данных.

Наконец, я должен упомянуть одну очень важную интерпретацию алгебры типов. Обратите внимание, что продукт двух типов \code{a} и \code{b} должен содержать и значение типа \code{a} и значение типа \code{b}, что означает, что оба типа должны быть обитаемы. Сумма двух типов, с другой стороны, содержит либо значение типа \code{a}, либо значение типа \code{b}, поэтому достаточно, чтобы один из них был обитаем. Логическое \emph{и} и \emph{или} также образуют полурing, и его также можно отобразить в теорию типов:

\begin{longtable}[]{@{}ll@{}}
  \toprule
  Логика                & Типы\tabularnewline
  \midrule
  \endhead
  $\mathit{false}$     & \code{Void}\tabularnewline
  $\mathit{true}$      & \code{()}\tabularnewline
  $a \mathbin{||} b$   & \code{data Either a b = Left a | Right b}\tabularnewline
  $a \mathbin{\&\&} b$ & \code{(a, b)}\tabularnewline
  \bottomrule
\end{longtable}

\noindent
Эта аналогия глубже и является основой изоморфизма Кёрри-Хоуара между логикой и теорией типов. Мы вернёмся к этому, когда поговорим о типах функций.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Показать изоморфизм между \code{Maybe a} и
        \code{Either () a}.
  \item
        Вот сумма-тип, определённый в Haskell:

        \begin{snip}{haskell}
data Shape = Circle Float
           | Rect Float Float
\end{snip}
        Когда мы хотим определить функцию, например, \code{area}, которая действует на \code{Shape}, мы делаем это с помощью сопоставления с образцом на двух конструкторах:

        \begin{snip}{haskell}
area :: Shape -> Float
area (Circle r) = pi * r * r
area (Rect d h) = d * h
\end{snip}
        Реализуйте \code{Shape} в C++ или Java как интерфейс и создайте два класса: \code{Circle} и \code{Rect}. Реализуйте \code{area} как виртуальную функцию.
  \item
        Продолжая предыдущий пример: Мы можем легко добавить новую функцию \code{circ}, которая вычисляет длину окружности \code{Shape}. Мы можем сделать это без изменения определения \code{Shape}:

        \begin{snip}{haskell}
circ :: Shape -> Float
circ (Circle r) = 2.0 * pi * r
circ (Rect d h) = 2.0 * (d + h)
\end{snip}
        Добавьте \code{circ} в вашу реализацию на C++ или Java. Какие части исходного кода пришлось изменить?
  \item
        Продолжая дальше: Добавьте новый тип фигуры, \code{Square}, в \code{Shape} и сделайте все необходимые обновления. Какой код пришлось изменить в Haskell по сравнению с C++ или Java? (Даже если вы не программист на Haskell, изменения должны быть довольно очевидны.)
  \item
        Показать, что $a + a = 2 \times a$ выполняется для типов (до изоморфизма). Помните, что $2$ соответствует \code{Bool}, согласно нашей таблице перевода.
\end{enumerate}