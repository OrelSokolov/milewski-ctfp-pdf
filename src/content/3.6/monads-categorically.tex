% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{Е}{сли вы упомянете монады} программисту, вы, вероятно, закончите разговором
об эффектах. Математику монады о алгебрах. Мы поговорим
об алгебрах позже --- они играют важную роль в программировании ---
но сначала я хотел бы дать вам немного интуиции об их отношении
к монадам. Пока это немного размахивающий руками аргумент, но потерпите
меня.

Алгебра о создании, манипулировании и вычислении выражений.
Выражения строятся с использованием операторов. Рассмотрите это простое выражение:
\[x^2 + 2 x + 1\]
Это выражение сформировано с использованием переменных типа $x$ и констант
типа $1$ или $2$, связанных вместе операторами типа плюс или умножить. Как
программисты, мы часто думаем о выражениях как о деревьях.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/exptree.png}
\end{figure}

\noindent
Деревья --- контейнеры, так что, более обобщённо, выражение --- это контейнер
для хранения переменных. В теории категорий мы представляем контейнеры как
эндофункторы. Если мы назначим тип $a$ переменной
$x$, наше выражение будет иметь тип $m\ a$, где
$m$ --- эндофунктор, который строит деревья выражений. (Нетривиальные
ветвящиеся выражения обычно создаются с использованием рекурсивно определённых
эндофункторов.)

Какая самая частая операция, которая может быть выполнена на выражении?
Это подстановка: замена переменных выражениями. Например,
в нашем примере мы могли бы заменить $X$ на $y - 1$, чтобы
получить:
\[(y - 1)^2 + 2 (y - 1) + 1\]
Вот что произошло: мы взяли выражение типа $m\ a$ и
применили преобразование типа $a \to m\ b$
($b$ представляет тип $y$). Результат ---
выражение типа $m\ b$. Позвольте мне произнести это:
\[m\ a \to (a \to m\ b) \to m\ b\]
Да, это сигнатура монадического bind.

Это была немного мотивация. Теперь давайте перейдём к математике монады.
Математики используют другую нотацию, чем программисты. Они предпочитают
использовать букву $T$ для эндофунктора и греческие буквы: $\mu$ для
\code{join} и $\eta$ для \code{return}. И \code{join}, и
\code{return} --- полиморфные функции, так что мы можем догадаться, что они
соответствуют естественным преобразованиям.

Поэтому в теории категорий монада определяется как эндофунктор
$T$, оснащённый парой естественных преобразований $\mu$ и $\eta$.

$\mu$ --- естественное преобразование из квадрата функтора $T^2$
обратно в $T$. Квадрат --- просто функтор, скомпозированный с
собой, $T \circ T$ (мы можем делать этот вид возведения в квадрат только для
эндофункторов).
\[\mu \Colon T^2 \to T\]
Компонента этого естественного преобразования в объекте $a$ ---
это морфизм:
\[\mu_a \Colon T (T a) \to T a\]
который в $\Hask$ переводится напрямую в наше определение
\code{join}.

$\eta$ --- естественное преобразование между тождественным функтором $I$
и $T$:
\[\eta \Colon I \to T\]
Учитывая, что действие $I$ на объект $a$ ---
просто $a$, компонента $\eta$ задаётся морфизмом:
\[\eta_a \Colon a \to T a\]
который переводится напрямую в наше определение \code{return}.

Эти естественные преобразования должны удовлетворять некоторым дополнительным законам. Один способ
взглянуть на это в том, что эти законы позволяют нам определить категорию Клейсли для
эндофунктора $T$. Помните, что стрелка Клейсли между
$a$ и $b$ определяется как морфизм
$a \to T b$. Композиция двух таких стрелок
(я запишу её как круг с индексом $T$) может быть
реализована с использованием $\mu$:
\[g \circ_T f = \mu_c \circ (T g) \circ f\]
где
\begin{gather*}
  f \Colon a \to T b \\
  g \Colon b \to T c
\end{gather*}
Здесь $T$, будучи функтором, может быть применён к морфизму
$g$. Может быть легче узнать эту формулу в нотации Haskell:

\src{snippet01}
или в компонентах:

\src{snippet02}
В терминах алгебраической интерпретации мы просто композируем две
последовательные подстановки.

Чтобы стрелки Клейсли образовали категорию, мы хотим, чтобы их композиция была
ассоциативной, а $\eta_a$ была тождественной стрелкой Клейсли в
$a$. Это требование может быть переведено в монадические законы для $\mu$ и
$\eta$. Но есть другой способ вывода этих законов, который заставляет их выглядеть
больше похожими на законы моноида. На самом деле $\mu$ часто называется
\emph{умножением}, а $\eta$ --- \emph{единицей}.

Грубо говоря, закон ассоциативности утверждает, что два способа
редуцирования куба $T$, $T^3$, вниз к $T$ должны
дать тот же результат. Два закона единицы (левый и правый) утверждают, что когда
$\eta$ применяется к $T$ и затем редуцируется $\mu$, мы
получаем обратно $T$.

Вещи немного хитры, потому что мы композируем естественные
преобразования и функторы. Так что немного освежения знаний по горизонтальной
композиции в порядке. Например, $T^3$ может рассматриваться как
композиция $T$ после $T^2$. Мы можем применить к ней
горизонтальную композицию двух естественных преобразований:
\[I_T \circ \mu\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/assoc1.png}
\end{figure}

\noindent
и получить $T \circ T$; которое может быть далее редуцировано к $T$
применением $\mu$. $I_T$ --- тождественное естественное преобразование
из $T$ в $T$. Вы часто увидите нотацию для этого
типа горизонтальной композиции $I_T \circ \mu$ сокращённую до
$T \circ \mu$. Эта нотация однозначна, потому что нет смысла
композировать функтор с естественным преобразованием, следовательно, $T$
должно означать $I_T$ в этом контексте.

\noindent
Мы также можем нарисовать диаграмму в категории (эндо-) функторов ${[}\cat{C}, \cat{C}{]}$:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/assoc2.png}
\end{figure}

\noindent
Альтернативно, мы можем рассматривать $T^3$ как композицию
$T^2 \circ T$ и применить $\mu \circ T$ к ней. Результат также
$T \circ T$, который, опять, может быть редуцирован к $T$, используя $\mu$. Мы
требуем, чтобы два пути производили тот же результат.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/assoc.png}
\end{figure}

\noindent
Аналогично, мы можем применить горизонтальную композицию $\eta \circ T$ к
композиции тождественного функтора $I$ после $T$, чтобы
получить $T^2$, который затем может быть редуцирован, используя $\mu$.
Результат должен быть таким же, как если бы мы применили тождественное естественное
преобразование напрямую к \code{T}. И, по аналогии, то же должно
быть верно для $T \circ \eta$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/unitlawcomp-1.png}
\end{figure}

\noindent
Вы можете убедить себя, что эти законы гарантируют, что композиция
стрелок Клейсли действительно удовлетворяет законам категории.

Сходства между монадой и моноидом поразительны. У нас есть
умножение $\mu$, единица $\eta$, ассоциативность и законы единицы. Но наше
определение моноида слишком узко, чтобы описать монаду как моноид. Так что
давайте обобщим понятие моноида.

\section{Моноидальные категории}

Давайте вернёмся к обычному определению моноида. Это множество
с бинарной операцией и специальным элементом, называемым единицей. В Haskell
это может быть выражено как класс типов:

\src{snippet03}
Бинарная операция \code{mappend} должна быть ассоциативной и унитарной
(т.е., умножение на единицу \code{mempty} --- это no-op).

Обратите внимание, что в Haskell определение \code{mappend} каррировано.
Оно может быть интерпретировано как отображение каждого элемента \code{m} в
функцию:

\src{snippet04}
Именно эта интерпретация порождает определение моноида
как одно-объектной категории, где эндоморфизмы
\code{(m -> m)} представляют элементы моноида.
Но поскольку каррирование встроено в Haskell, мы также могли бы
начать с другого определения умножения:

\src{snippet05}
Здесь декартово произведение \code{(m, m)} становится источником пар
для умножения.

Это определение предлагает другой путь к обобщению: замену
декартова произведения категорным произведением. Мы могли бы начать с
категории, где произведения определены глобально, выбрать объект \code{m}
там и определить умножение как морфизм:
\[\mu \Colon m\times{}m \to m\]
Однако у нас есть одна проблема: в произвольной категории мы не можем заглянуть
внутрь объекта, так что как мы выбираем единичный элемент? Есть трюк
для этого. Помните, как выбор элемента эквивалентен функции из
одноэлементного множества? В Haskell мы могли бы заменить определение
\code{mempty} функцией:

\src{snippet06}
Синглетон --- терминальный объект в $\Set$, так что естественно
обобщить это определение на любую категорию, которая имеет терминальный объект
$t$:
\[\eta \Colon t \to m\]
Это позволяет нам выбрать единичный ``элемент'' без необходимости говорить об
элементах.

В отличие от нашего предыдущего определения моноида как одно-объектной
категории, моноидальные законы здесь не автоматически удовлетворены --- мы должны
наложить их. Но чтобы формулировать их, мы должны установить
моноидальную структуру самого лежащего в основе категорного произведения. Давайте
вспомним, как моноидальная структура работает в Haskell сначала.

Мы начинаем с ассоциативности. В Haskell соответствующий уравнительный
закон:

\src{snippet07}
Прежде чем мы сможем обобщить его на другие категории, мы должны переписать его
как равенство функций (морфизмов). Мы должны абстрагировать его
от его действия на индивидуальные переменные --- другими словами, мы должны
использовать бесточечную нотацию. Зная, что декартово произведение ---
бифунктор, мы можем написать левую сторону как:

\src{snippet08}
а правую сторону как:

\src{snippet09}
Это почти то, что мы хотим. К сожалению, декартово произведение не
строго ассоциативно --- \code{(x, (y, z))} не то же самое, что
\code{((x, y), z)} --- так что мы не можем просто написать бесточечно:

\src{snippet10}
С другой стороны, два вложения пар изоморфны. Есть
обратимая функция, называемая ассоциатором, которая конвертирует между ними:

\src{snippet11}
С помощью ассоциатора мы можем написать бесточечный
закон ассоциативности для \code{mu}:

\src{snippet12}
Мы можем применить похожий трюк к законам единицы, которые в новой нотации
принимают форму:

\src{snippet13}
Они могут быть переписаны как:

\src{snippet14}
Изоморфизмы \code{lambda} и \code{rho} называются левым
и правым унитором, соответственно. Они свидетельствуют о факте, что единица
\code{()} --- тождество декартова произведения с точностью до изоморфизма:

\src{snippet15}

\src{snippet16}
Бесточечные версии законов единицы следовательно:

\src{snippet17}
Мы сформулировали бесточечные моноидальные законы для \code{mu} и
\code{eta}, используя факт, что само лежащее в основе декартово произведение
действует как моноидальное умножение в категории типов. Имейте в
виду, однако, что законы ассоциативности и единицы для декартова
произведения верны только с точностью до изоморфизма.

Оказывается, что эти законы могут быть обобщены на любую категорию с
произведениями и терминальным объектом. Категорные произведения действительно
ассоциативны с точностью до изоморфизма, а терминальный объект --- единица, также
с точностью до изоморфизма. Ассоциатор и два унитора ---
естественные изоморфизмы. Законы могут быть представлены коммутирующими диаграммами.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/assocmon.png}
\end{figure}

\noindent
Обратите внимание, что существенно, что произведение --- бифунктор,
потому что нам нужно поднять пары морфизмов, чтобы формировать произведения типа
$\mu \otimes \id$ или $\eta \otimes \id$. Эти диаграммы --- просто
прямолинейное обобщение наших предыдущих результатов для категорных
произведений.

Мы могли бы остановиться здесь и сказать, что мы можем определить моноид поверх любой
категории с категорными произведениями и терминальным объектом. Пока мы
можем выбрать объект $m$ и два морфизма $\mu$ и $\eta$, которые удовлетворяют
моноидальным законам, у нас есть моноид. Но мы можем сделать лучше. Нам
не нужно полноценное категорное произведение для формулировки законов для $\mu$
и $\eta$. Вспомните, что произведение определяется через универсальную конструкцию,
которая использует проекции. Мы не использовали никаких проекций в нашей
формулировке моноидальных законов.

Бифунктор, который ведёт себя как произведение, не являясь произведением,
называется \newterm{тензорным произведением}, часто обозначаемым инфиксным оператором $\otimes$.
Определение тензорного произведения в общем случае немного хитро, но мы не будем
беспокоиться об этом. Мы просто перечислим его свойства --- наиболее важное ---
ассоциативность с точностью до изоморфизма.

Аналогично, нам не нужен объект $t$ как терминальный. Мы никогда не
использовали его терминальное свойство --- а именно, существование уникального
морфизма из любого объекта в него. То, что мы требуем, --- что он хорошо работает в
концерте с тензорным произведением. Что означает, что мы хотим, чтобы он был
единицей тензорного произведения, опять, с точностью до изоморфизма. Давайте соберём всё
вместе:

Моноидальная категория --- это категория $\cat{C}$, оснащённая бифунктором,
называемым тензорным произведением:
\[\otimes \Colon \cat{C}\times{}\cat{C} \to \cat{C}\]
и отдельным объектом $i$, называемым единичным объектом, вместе с
тремя естественными изоморфизмами, называемыми, соответственно, ассоциатором и
левым и правым унитором:
\begin{align*}
  \alpha_{a b c} & \Colon (a \otimes b) \otimes c \to a \otimes (b \otimes c) \\
  \lambda_a      & \Colon i \otimes a \to a                                   \\
  \rho_a         & \Colon a \otimes i \to a
\end{align*}
(Есть также условие когерентности для упрощения четверного тензорного
произведения.)

Что важно, так это то, что тензорное произведение описывает много знакомых
бифункторов. В частности, оно работает для произведения, копроизведения и, как
мы скоро увидим, для композиции эндофункторов (а также для
некоторых более эзотерических произведений типа свёртки Дэя). Моноидальные категории
будут играть существенную роль в формулировке обогащённых категорий.

\section{Моноид в моноидальной категории}

Теперь мы готовы определить моноид в более общей обстановке
моноидальной категории. Мы начинаем с выбора объекта $m$. Используя
тензорное произведение, мы можем формировать степени $m$. Квадрат
$m$ --- это $m \otimes m$. Есть два способа формирования куба
$m$, но они изоморфны через ассоциатор. Аналогично
для более высоких степеней $m$ (вот где нам нужны условия
когерентности). Чтобы сформировать моноид, нам нужно выбрать два морфизма:
\begin{align*}
  \mu  & \Colon m \otimes m \to m \\
  \eta & \Colon i \to m
\end{align*}
где $i$ --- единичный объект для нашего тензорного произведения.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoid-1.jpg}
\end{figure}

\noindent
Эти морфизмы должны удовлетворять законам ассоциативности и единицы, которые могут быть
выражены в терминах следующих коммутирующих диаграмм:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/assoctensor.jpg}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/unitmon.jpg}
\end{figure}

\noindent
Обратите внимание, что существенно, что тензорное произведение --- бифунктор,
потому что нам нужно поднимать пары морфизмов, чтобы формировать произведения типа
$\mu \otimes \id$ или $\eta \otimes \id$. Эти диаграммы --- просто
прямолинейное обобщение наших предыдущих результатов для категорных
произведений.

\section{Монады как моноиды}

Моноидальные структуры появляются в неожиданных местах. Одно такое место ---
категория функторов. Если вы прищуритесь немного, вы можете увидеть
композицию функторов как форму умножения. Проблема в том, что не
любые два функтора могут быть скомпозированы --- целевая категория одного должна
быть исходной категорией другого. Это просто обычное правило
композиции морфизмов --- и, как мы знаем, функторы действительно
морфизмы в категории $\Cat$. Но так же, как эндоморфизмы
(морфизмы, которые замыкаются обратно на тот же объект) всегда композиционны, так же
и эндофункторы. Для любой данной категории $\cat{C}$ эндофункторы из
$\cat{C}$ в $\cat{C}$ образуют категорию функторов ${[}\cat{C}, \cat{C}{]}$. Её
объекты --- эндофункторы, а морфизмы --- естественные преобразования
между ними. Мы можем взять любые два объекта из этой категории, скажем,
эндофункторы $F$ и $G$, и произвести третий объект $F \circ G$ ---
эндофунктор, который является их композицией.

Является ли композиция эндофункторов хорошим кандидатом для тензорного произведения? Сначала
мы должны установить, что это бифунктор. Может ли она быть использована для подъёма
пары морфизмов --- здесь естественных преобразований? Сигнатура
аналога \code{bimap} для тензорного произведения выглядела бы примерно
так:
\[\mathit{bimap} \Colon (a \to b) \to (c \to d) \to (a \otimes c \to b \otimes d)\]
Если вы заменяете объекты эндофункторами, стрелки естественными
преобразованиями, а тензорные произведения композицией, вы получаете:
\[(F \to F') \to (G \to G') \to (F \circ G \to F' \circ G')\]
что вы можете узнать как специальный случай горизонтальной композиции.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/horizcomp.png}
\end{figure}

\noindent
У нас также в распоряжении тождественный эндофунктор $I$, который
может служить тождеством для композиции эндофункторов --- нашего нового тензорного
произведения. Более того, композиция функторов ассоциативна. На самом деле
ассоциативность и законы единицы строги --- нет нужды в
ассоциаторе или двух униторах. Так что эндофункторы образуют строгую моноидальную
категорию с композицией функторов как тензорным произведением.

Что такое моноид в этой категории? Это объект --- то есть
эндофунктор $T$; и два морфизма --- то есть естественные
преобразования:
\begin{gather*}
  \mu \Colon T \circ T \to T \\
  \eta \Colon I \to T
\end{gather*}
Не только это, вот законы моноида:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/assoc.png}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/unitlawcomp.png}
\end{figure}

\noindent
Они в точности законы монады, которые мы видели раньше. Теперь вы понимаете
знаменитую цитату от Сондерса Мак-Лейна:

\begin{quote}
  В целом, монада --- это просто моноид в категории эндофункторов.
\end{quote}
Вы можете видели её на некоторых футболках на конференциях по функциональному
программированию.

\section{Монады из сопряжений}

\hyperref[adjunctions]{Сопряжение}\footnote{См. гл.18 о \hyperref[adjunctions]{сопряжениях}.}
$L \dashv R$ --- это пара функторов, идущих туда и обратно между двумя
категориями $\cat{C}$ и $\cat{D}$. Есть два способа композиции их,
порождающие два эндофунктора, $R \circ L$ и $L \circ R$.
Согласно сопряжению, эти эндофункторы связаны с тождественными
функторами через два естественных преобразования, называемые единицей и коединицей:
\begin{gather*}
  \eta \Colon I_{\cat{D}} \to R \circ L \\
  \varepsilon \Colon L \circ R \to I_{\cat{C}}
\end{gather*}
Немедленно мы видим, что единица сопряжения выглядит точно как
единица монады. Оказывается, что эндофунктор $R \circ L$
действительно монада. Всё, что нам нужно, --- определить подходящее $\mu$, чтобы идти с
$\eta$. Это естественное преобразование между квадратом нашего
эндофунктора и самим эндофунктором или, в терминах сопряжённых
функторов:
\[R \circ L \circ R \circ L \to R \circ L\]
И действительно, мы можем использовать коединицу, чтобы схлопнуть $L \circ R$ в
середине. Точная формула для $\mu$ задаётся горизонтальной
композицией:
\[\mu = R \circ \varepsilon \circ L\]
Монадические законы следуют из тождеств, удовлетворяемых единицей и коединицей
сопряжения, и закона взаимозаменяемости.

Мы не видим много монад, выведенных из сопряжений в Haskell,
потому что сопряжение обычно включает две категории. Однако
определения экспоненциала, или объекта-функции, --- исключение.
Вот два эндофунктора, которые образуют это сопряжение:
\begin{gather*}
  L z = z\times{}s \\
  R b = s \Rightarrow b
\end{gather*}
Вы можете узнать их композицию как знакомую монаду состояния:
\[R (L z) = s \Rightarrow (z\times{}s)\]
Мы видели эту монаду раньше в Haskell:

\src{snippet18}
Давайте также переведём сопряжение в Haskell. Левый функтор --- это
функтор произведения:

\src{snippet19}
а правый функтор --- функтор reader:

\src{snippet20}
Они образуют сопряжение:

\src{snippet21}
Вы можете легко убедить себя, что композиция функтора
reader после функтора произведения действительно эквивалентна функтору
состояния:

\src{snippet22}
Как ожидалось, \code{unit} сопряжения эквивалентен
функции \code{return} монады состояния. \code{counit} действует,
вычисляя функцию, действующую на свой аргумент. Это узнаваемо как
раскаррированная версия функции \code{runState}:

\src{snippet23}
(раскаррирована, потому что в \code{counit} она действует на пару).

Теперь мы можем определить \code{join} для монады состояния как компоненту
естественного преобразования $\mu$. Для этого нам нужна горизонтальная композиция
трёх естественных преобразований:
\[\mu = R \circ \varepsilon \circ L\]
Другими словами, нам нужно протащить коединицу $\varepsilon$ через один уровень
функтора reader. Мы не можем просто вызвать \code{fmap} напрямую, потому что
компилятор выбрал бы тот для функтора \code{State}, а не для
функтора \code{Reader}. Но вспомните, что \code{fmap} для
функтора reader --- это просто левая композиция функций. Так что мы будем использовать композицию функций
напрямую.

Мы должны сначала снять конструктор данных \code{State}, чтобы выставить
функцию внутри функтора \code{State}. Это делается с использованием
\code{runState}:

\src{snippet24}
Затем мы лево-композируем её с коединицей, которая определяется
\code{uncurry runState}. Наконец, мы одеваем её обратно в
конструктор данных \code{State}:

\src{snippet25}
Это действительно реализация \code{join} для
монады \code{State}.

Оказывается, что не только каждое сопряжение порождает монаду, но
обратное также верно: каждая монада может быть факторизована в
композицию двух сопряжённых функторов. Такая факторизация, однако, не уникальна.

Мы поговорим о другом эндофункторе $L \circ R$ в следующей
секции.
