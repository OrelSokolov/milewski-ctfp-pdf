% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{С}{вободные конструкции ---} мощное применение сопряжений.
\newterm{Свободный функтор} определяется как левый сопряжённый к \newterm{забывающему
  функтору}. Забывающий функтор обычно довольно простой функтор, который
забывает некоторую структуру. Например, много интересных категорий
построены поверх множеств. Но категорные объекты, которые абстрагируют эти
множества, не имеют внутренней структуры --- у них нет элементов. Тем не менее, эти
объекты часто несут память о множествах в том смысле, что существует
отображение --- функтор --- из данной категории $\cat{C}$ в
$\Set$. Множество, соответствующее некоторому объекту в $\cat{C}$, называется
его \newterm{лежащим в основе множеством}.

Моноиды --- такие объекты, которые имеют лежащие в основе множества --- множества элементов.
Существует забывающий функтор $U$ из категории моноидов
$\cat{Mon}$ в категорию множеств, который отображает моноиды в их
лежащие в основе множества. Он также отображает морфизмы моноидов (гомоморфизмы) в
функции между множествами.

Мне нравится думать о $\cat{Mon}$ как имеющей раздвоение личности. С одной
стороны, это куча множеств с умножением и единичными элементами. С
другой стороны, это категория с безликими объектами, чья единственная
структура закодирована в морфизмах, которые идут между ними. Каждая
функция множества, которая сохраняет умножение и единицу, порождает
морфизм в $\cat{Mon}$.\\
\newline
Вещи, которые нужно помнить:

\begin{itemize}
  \tightlist
  \item
        Может быть много моноидов, которые отображаются в одно и то же множество, и
  \item
        Морфизмов моноидов меньше (или не больше), чем
        функций между их лежащими в основе множествами.
\end{itemize}

\noindent
Функтор $F$, который является левым сопряжённым к забывающему функтору
$U$, --- это свободный функтор, который строит свободные моноиды из их
множеств-генераторов. Сопряжение следует из универсальной конструкции свободного моноида,
которую мы обсуждали раньше.\footnote{См. гл.13 о
  \hyperref[free-monoids]{свободных моноидах}.}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{images/forgetful.jpg}
  \caption{Моноиды $m_1$ и $m_2$ имеют одно и то же
    лежащее в основе множество. Существует больше функций между лежащими в основе множествами
    $m_2$ и $m_3$, чем существует морфизмов
    между ними.}
\end{figure}

\noindent
В терминах hom-множеств мы можем записать это сопряжение как:
\[\cat{Mon}(F x, m) \cong \Set(x, U m)\]
Этот (естественный в $x$ и $m$) изоморфизм говорит нам, что:

\begin{itemize}
  \tightlist
  \item
        Для каждого гомоморфизма моноидов между свободным моноидом $F x$,
        порождённым $x$, и произвольным моноидом $m$ существует
        уникальная функция, которая встраивает множество генераторов $x$ в
        лежащее в основе множество $m$. Это функция в
        $\Set(x, U m)$.
  \item
        Для каждой функции, которая встраивает $x$ в лежащее в основе множество
        некоторого $m$, существует уникальный морфизм моноидов между свободным
        моноидом, порождённым $x$, и моноидом $m$. (Это
        морфизм, который мы назвали $h$ в нашей универсальной конструкции.)
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/freemonadjunction.jpg}
\end{figure}

\noindent
Интуиция в том, что $F x$ --- ``максимальный'' моноид, который может
быть построен на основе $x$. Если бы мы могли заглянуть внутрь моноидов, мы бы
увидели, что любой морфизм, который принадлежит $\cat{Mon}(F x, m)$,
\emph{встраивает} этот свободный моноид в какой-то другой моноид $m$. Он делает
это, возможно, идентифицируя некоторые элементы. В частности, он встраивает
генераторы $F x$ (т.е., элементы $x$) в
$m$. Сопряжение показывает, что встраивание $x$, которое
задаётся функцией из $\Set(x, U m)$ справа,
уникально определяет встраивание моноидов слева, и наоборот.

В Haskell структура данных списка --- свободный моноид (с некоторыми оговорками:
см. \urlref{http://comonad.com/reader/2015/free-monoids-in-haskell/}{блог-пост Дэна
  Доэла}). Тип списка \code{{[}a{]}} --- свободный моноид с
типом \code{a}, представляющим множество генераторов. Например,
тип \code{{[}Char{]}} содержит единичный элемент --- пустой
список \code{{[}{]}} --- и синглетоны типа
\code{{[}'a'{]}}, \code{{[}'b'{]}} ---
генераторы свободного моноида. Остальное генерируется применением
``произведения.'' Здесь произведение двух списков просто добавляет один к
другому. Добавление ассоциативно и имеет единицу (то есть есть
нейтральный элемент --- здесь пустой список). Свободный моноид, порождённый
\code{Char}, --- не что иное, как множество всех строк символов из
\code{Char}. Он называется \code{String} в Haskell:

\src{snippet01}
(\code{type} определяет синоним типа --- другое имя для существующего
типа).

Другой интересный пример --- свободный моноид, построенный только из одного
генератора. Это тип списка юнитов, \code{{[}(){]}}. Его
элементы --- \code{{[}{]}}, \code{{[}(){]}}, \code{{[}(), (){]}},
и т.д. Каждый такой список может быть описан одним натуральным числом --- его
длиной. Больше информации в списке юнитов не закодировано.
Добавление двух таких списков производит новый список, чья длина --- сумма
длин его составляющих. Легко увидеть, что тип
\code{{[}(){]}} изоморфен аддитивному моноиду натуральных
чисел (с нулём). Вот две функции, которые являются обратными
друг другу, свидетельствующие об этом изоморфизме:

\src{snippet02}
Для простоты я использовал тип \code{Int}, а не
\code{Natural}, но идея та же. Функция
\code{replicate} создаёт список длины \code{n}, предзаполненный данным
значением --- здесь юнитом.

\section{Некоторые интуиции}

То, что следует, --- некоторые размахивающие руками аргументы. Эти виды аргументов
далеки от строгости, но они помогают в формировании интуиций.

Чтобы получить некоторую интуицию о свободных/забывающих сопряжениях, помогает
помнить, что функторы и функции по природе с потерями. Функторы
могут схлопывать несколько объектов и морфизмов, функции могут собирать вместе
несколько элементов множества. Также их образ может покрывать только
часть их кодомена.

``Среднее'' hom-множество в $\Set$ будет содержать целый спектр
функций, начиная с тех, которые наименее с потерями (например, инъекции
или, возможно, изоморфизмы), и заканчивая постоянными функциями, которые
схлопывают весь домен в единственный элемент (если такой есть).

Я склонен думать о морфизмах в произвольной категории как тоже с потерями.
Это просто ментальная модель, но полезная, особенно при
размышлении о сопряжениях --- в частности, тех, в которых одна из
категорий --- $\Set$.

Формально мы можем говорить только о морфизмах, которые обратимы
(изоморфизмы) или необратимы. Именно этот последний вид может рассматриваться
как с потерями. Есть также понятие моно- и эпи- морфизмов,
которые обобщают идею инъективных (не схлопывающих) и сюръективных
(покрывающих весь кодомен) функций, но возможно иметь
морфизм, который одновременно моно и эпи, и который всё ещё необратим.

В сопряжении Свободный ⊣ Забывающий у нас есть более ограниченная
категория $\cat{C}$ слева и менее ограниченная категория $\cat{D}$
справа. Морфизмов в $\cat{C}$ ``меньше'', потому что они должны
сохранять некоторую дополнительную структуру. В случае $\cat{Mon}$ они
должны сохранять умножение и единицу. Морфизмы в $\cat{D}$ не
должны сохранять столько структуры, так что их ``больше''.

Когда мы применяем забывающий функтор $U$ к объекту $c$ в
$\cat{C}$, мы думаем об этом как о раскрытии ``внутренней структуры''
$c$. На самом деле, если $\cat{D}$ --- $\Set$, мы думаем о $U$
как \emph{определяющем} внутреннюю структуру $c$ --- его
лежащее в основе множество. (В произвольной категории мы не можем говорить о
внутренностях объекта иначе, чем через его связи с другими
объектами, но здесь мы просто размахиваем руками.)

Если мы отображаем два объекта $c'$ и $c$, используя $U$,
мы ожидаем, что, в общем случае, отображение hom-множества
$\cat{C}(c', c)$ покроет только подмножество
$\cat{D}(U c', U c)$. Это потому, что морфизмы в
$\cat{C}(c', c)$ должны сохранять дополнительную структуру,
тогда как те в $\cat{D}(U c', U c)$ не должны.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/forgettingmorphisms.jpg}
\end{figure}

\noindent
Но поскольку сопряжение определяется как \newterm{изоморфизм}
конкретных hom-множеств, мы должны быть очень разборчивы с нашим выбором
$c'$. В сопряжении $c'$ выбирается не
просто откуда угодно в $\cat{C}$, а из (предположительно меньшего) образа
свободного функтора $F$:
\[\cat{C}(F d, c) \cong \cat{D}(d, U c)\]
Образ $F$ должен следовательно состоять из объектов, которые имеют много
морфизмов, идущих в произвольный $c$. На самом деле, должно быть
столько же структуро-сохраняющих морфизмов из $F d$ в $c$,
сколько есть не-структуро-сохраняющих морфизмов из $d$ в
$U c$. Это означает, что образ $F$ должен состоять из
по существу бесструктурных объектов (так что нет структуры для
сохранения морфизмами). Такие ``бесструктурные'' объекты называются свободными
объектами.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/freeimage.jpg}
\end{figure}

\noindent
В примере с моноидом свободный моноид не имеет структуры, кроме той, что
порождена законами единицы и ассоциативности. Кроме этого, все
умножения производят совершенно новые элементы.

В свободном моноиде $2 * 3$ --- это не $6$ --- это новый элемент ${[}2, 3{]}$. Поскольку
нет идентификации ${[}2, 3{]}$ и $6$, морфизм из этого
свободного моноида в любой другой моноид $m$ может отобразить их
раздельно. Но также нормально для него отобразить и ${[}2, 3{]}$, и $6$
(их произведение) в один и тот же элемент $m$. Или идентифицировать ${[}2,
  3{]}$ и $5$ (их сумму) в аддитивном моноиде, и так далее. Разные
идентификации дают вам разные моноиды.

Это приводит к другой интересной интуиции: свободные моноиды, вместо
выполнения моноидальной операции, накапливают аргументы, которые были
переданы в них. Вместо умножения $2$ и $3$ они запоминают $2$ и $3$ в
списке. Преимущество этой схемы в том, что нам не нужно специфицировать, какую
моноидальную операцию мы будем использовать. Мы можем продолжать накапливать аргументы и
только в конце применить оператор к результату. И вот тогда мы
можем выбрать, какой оператор применить. Мы можем сложить числа, или умножить
их, или выполнить сложение по модулю 2, и так далее. Свободный моноид разделяет
создание выражения от его вычисления. Мы увидим эту идею
снова, когда будем говорить об алгебрах.

Эта интуиция обобщается на другие, более сложные свободные конструкции.
Например, мы можем накапливать целые деревья выражений перед их вычислением.
Преимущество этого подхода в том, что мы можем преобразовывать такие деревья,
чтобы сделать вычисление быстрее или менее потребляющим память. Это, например,
делается при реализации матричного исчисления, где жадное вычисление
привело бы к множеству аллокаций временных массивов для хранения
промежуточных результатов.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Рассмотрите свободный моноид, построенный из одноэлементного множества как его генератор.
        Покажите, что существует взаимно однозначное соответствие между морфизмами из
        этого свободного моноида в любой моноид $m$ и функциями из
        одноэлементного множества в лежащее в основе множество $m$.
\end{enumerate}
