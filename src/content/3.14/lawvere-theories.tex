% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{С}{егодня невозможно} говорить о функциональном программировании без упоминания
монад. Но существует альтернативная вселенная, в которой случайно
Эудженио Могги обратил своё внимание на теории Ловера, а не на
монады. Давайте исследуем эту вселенную.

\section{Универсальная алгебра}

Существует много способов описания алгебр на различных уровнях
абстракции. Мы пытаемся найти общий язык для описания таких вещей, как
моноиды, группы или кольца. На простейшем уровне все эти
конструкции определяют \emph{операции} над элементами множества, плюс некоторые
\emph{законы}, которые должны удовлетворяться этими операциями. Например,
моноид можно определить в терминах бинарной операции, которая
ассоциативна. У нас также есть единичный элемент и законы единицы. Но с
небольшой долей воображения можем превратить единичный элемент в нульарную
операцию --- операцию, которая не принимает аргументов и возвращает специальный
элемент множества. Если хотим говорить о группах, добавляем унарный
оператор, который берёт элемент и возвращает его обратный. Есть
соответствующие левый и правый законы обратного элемента, идущие с ним. Кольцо определяет
два бинарных оператора плюс ещё несколько законов. И так далее.

Общая картина в том, что алгебра определяется набором $n$-арных
операций для различных значений $n$ и набором уравнительных тождеств.
Эти тождества все универсально квантифицированы. Уравнение ассоциативности
должно удовлетворяться для всех возможных комбинаций трёх
элементов, и так далее.

Кстати, это исключает поля из рассмотрения по простой
причине, что ноль (единица относительно сложения) не имеет обратного относительно
умножения. Закон обратного элемента для поля не может быть
универсально квантифицирован.

Это определение универсальной алгебры можно распространить на категории,
отличные от $\Set$, если заменить операции (функции)
морфизмами. Вместо множества выбираем объект $a$ (называемый
типовым объектом). Унарная операция — это просто эндоморфизм
$a$. А как насчёт других арностей (\newterm{арность} — это количество
аргументов для данной операции)? Бинарная операция (арность 2) может быть
определена как морфизм из произведения $a\times{}a$ обратно в $a$.
Общая $n$-арная операция — это морфизм из $n$-ой степени
$a$ в $a$:
\[\alpha_n \Colon a^n \to a\]
Нульарная операция — это морфизм из терминального объекта (нулевой
степени $a$). Так что всё, что нам нужно для определения любой алгебры, — это
категория, чьи объекты являются степенями одного специального объекта $a$.
Конкретная алгебра закодирована в hom-множествах этой категории. Это
теория Ловера в двух словах.

Выведение теорий Ловера проходит через много шагов, поэтому вот
дорожная карта:

\begin{enumerate}
  \tightlist
  \item
        Категория конечных множеств $\cat{FinSet}$.
  \item
        Её скелет $\cat{F}$.
  \item
        Её противоположная категория $\Fop$.
  \item
        Теория Ловера $\cat{L}$: объект в категории $\cat{Law}$.
  \item
        Модель $M$ категории Ловера: объект в категории\\
        $\cat{Mod}(\cat{L}, \Set)$.
\end{enumerate}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/lawvere1.png}
\end{figure}

\section{Теории Ловера}

Все теории Ловера имеют общий позвоночник. Все объекты в теории
Ловера генерируются из одного объекта, используя произведения (на самом деле, просто
степени). Но как определить эти произведения в общей категории?
Оказывается, можем определить произведения с помощью отображения из более простой
категории. Фактически эта более простая категория может определять копроизведения вместо
произведений, и мы будем использовать \emph{контравариантный} функтор, чтобы вложить их в
нашу целевую категорию. Контравариантный функтор превращает копроизведения в
произведения, а инъекции в проекции.

Естественный выбор для позвоночника категории Ловера — это
категория конечных множеств, $\cat{FinSet}$. Она содержит пустое множество
$\varnothing$, синглтонное множество $1$, двухэлементное множество $2$
и так далее. Все объекты в этой категории могут быть сгенерированы из
синглтонного множества с помощью копроизведений (рассматривая пустое множество как специальный случай
нульарного копроизведения). Например, двухэлементное множество — это сумма двух
синглтонов, $2 = 1 + 1$, как выражено в Haskell:

\src{snippet01}
Однако, хотя естественно думать, что существует только одно пустое
множество, может быть много различных синглтонных множеств. В частности, множество
$1 + \varnothing$ отличается от множества $\varnothing + 1$ и
отличается от $1$ --- даже хотя они все изоморфны.
Копроизведение в категории множеств не ассоциативно. Можем исправить эту
ситуацию, построив категорию, которая отождествляет все изоморфные множества.
Такая категория называется \newterm{скелетом}. Другими словами,
позвоночник любой теории Ловера — это скелет $\cat{F}$
$\cat{FinSet}$. Объекты в этой категории могут быть отождествлены с
натуральными числами (включая ноль), которые соответствуют числу элементов в
$\cat{FinSet}$. Копроизведение играет роль сложения. Морфизмы в
$\cat{F}$ соответствуют функциям между конечными множествами. Например,
существует уникальный морфизм из $\varnothing$ в $n$ (пустое множество
является начальным объектом), нет морфизмов из $n$ в $\varnothing$
(кроме $\varnothing \to \varnothing$), $n$ морфизмов из $1$ в
$n$ (инъекции), один морфизм из $n$ в $1$,
и так далее. Здесь $n$ обозначает объект в $\cat{F}$,
соответствующий всем $n$-элементным множествам в $\cat{FinSet}$, которые были
отождествлены через изоморфизмы.

Используя категорию $\cat{F}$, можем формально определить \newterm{теорию
  Ловера} как категорию $\cat{L}$, оснащённую специальным функтором:
\[I_{\cat{L}} \Colon \Fop \to \cat{L}\]
Этот функтор должен быть биекцией на объектах и должен сохранять конечные
произведения (произведения в $\Fop$ — это то же самое, что
копроизведения в $\cat{F}$):
\[I_{\cat{L}} (m\times{}n) = I_{\cat{L}} m\times{}I_{\cat{L}} n\]
Иногда этот функтор характеризуют как тождественный-на-объектах,
что означает, что объекты в $\cat{F}$ и $\cat{L}$ одинаковы.
Поэтому будем использовать для них одни и те же имена --- обозначим их
натуральными числами. Но имейте в виду, что объекты в $\cat{F}$ — это не
то же самое, что множества (это классы изоморфных множеств).

hom-множества в $\cat{L}$, в общем случае, богаче, чем в
$\Fop$. Они могут содержать морфизмы, отличные от
тех, которые соответствуют функциям в $\cat{FinSet}$ (последние иногда
называются \newterm{базовыми операциями произведения}). Уравнительные законы
теории Ловера закодированы в этих морфизмах.

Ключевое наблюдение в том, что синглтонное множество $1$ в $\cat{F}$
отображается в некоторый объект, который мы также называем $1$ в $\cat{L}$, и
все остальные объекты в $\cat{L}$ автоматически являются степенями этого
объекта. Например, двухэлементное множество $2$ в $\cat{F}$ является
копроизведением $1 + 1$, поэтому оно должно отображаться в произведение
$1 \times 1$ (или $1^2$) в $\cat{L}$. В этом смысле категория
$\cat{F}$ ведёт себя как логарифм $\cat{L}$.

Среди морфизмов в $\cat{L}$ есть те, которые перенесены функтором
$I_{\cat{L}}$ из $\cat{F}$. Они играют структурную роль в $\cat{L}$. В
частности, инъекции копроизведения $i_k$ становятся проекциями произведения
$p_k$. Полезная интуиция — представить проекцию:
\[p_k \Colon 1^n \to 1\]
как прототип функции от $n$ переменных, которая игнорирует все, кроме
$k$-ой переменной. И наоборот, константные морфизмы $n \to 1$
в $\cat{F}$ становятся диагональными морфизмами $1 \to 1^n$ в
$\cat{L}$. Они соответствуют дублированию переменных.

Интересные морфизмы в $\cat{L}$ — это те, которые определяют $n$-арные
операции, отличные от проекций. Именно эти морфизмы отличают
одну теорию Ловера от другой. Это умножения,
сложения, выборы единичных элементов и так далее, которые определяют
алгебру. Но чтобы сделать $\cat{L}$ полной категорией, нам также нужны составные
операции $n \to m$ (или, эквивалентно,
$1^n \to 1^m$). Благодаря простой структуре
категории, они оказываются произведениями более простых морфизмов
типа $n \to 1$. Это обобщение
утверждения, что функция, возвращающая произведение, является произведением
функций (или, как мы видели ранее, что hom-функтор
непрерывен).

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/lawvere1.png}
  \caption{Теория Ловера $\cat{L}$ основана на $\Fop$, из которой
    она наследует ``скучные'' морфизмы, определяющие произведения. Она добавляет
    ``интересные'' морфизмы, описывающие $n$-арные операции (пунктирные
    стрелки).}
\end{figure}

Теории Ловера образуют категорию $\cat{Law}$, в которой морфизмами являются
функторы, сохраняющие конечные произведения и коммутирующие с функторами
$I$. Для двух таких теорий, $(\cat{L}, I_{\cat{L}})$ и
$(\cat{L'}, I'_{\cat{L'}})$, морфизм между ними — это
функтор $F \Colon \cat{L} \to \cat{L'}$ такой, что:
\begin{gather*}
  F (m \times n) = F m \times F n \\
  F \circ I_{\cat{L}} = I'_{\cat{L'}}
\end{gather*}
Морфизмы между теориями Ловера инкапсулируют идею
интерпретации одной теории внутри другой. Например, групповое
умножение может интерпретироваться как моноидное умножение, если игнорировать
обратные элементы.

Простейший тривиальный пример категории Ловера — это
сама $\Fop$ (соответствующая выбору
тождественного функтора для $I_{\cat{L}}$). Эта теория Ловера, не имеющая
операций или законов, случайно оказывается начальным объектом в $\cat{Law}$.

На этом этапе было бы очень полезно представить нетривиальный пример
теории Ловера, но было бы трудно объяснить его, не поняв сначала,
что такое модели.

\section{Модели теорий Ловера}

Ключ к пониманию теорий Ловера — осознать, что одна такая
теория обобщает множество отдельных алгебр, имеющих одинаковую
структуру. Например, теория Ловера моноидов описывает
сущность быть моноидом. Она должна быть валидна для всех моноидов.
Конкретный моноид становится моделью такой теории. Модель определяется
как функтор из теории Ловера $\cat{L}$ в категорию множеств
$\Set$. (Существуют обобщения теорий Ловера, которые используют
другие категории для моделей, но здесь я просто сосредоточусь на
$\Set$.) Поскольку структура $\cat{L}$ сильно зависит от
произведений, мы требуем, чтобы такой функтор сохранял конечные произведения.
Модель $\cat{L}$, также называемая алгеброй над теорией Ловера
$\cat{L}$, поэтому определяется функтором:
\begin{gather*}
  M \Colon \cat{L} \to \Set \\
  M (a \times b) \cong M a \times M b
\end{gather*}
Обратите внимание, что мы требуем сохранения произведений только \emph{с точностью до
  изоморфизма}. Это очень важно, потому что строгое сохранение
произведений исключило бы большинство интересных теорий.

Сохранение произведений моделями означает, что образ
$M$ в $\Set$ — это последовательность множеств, порождённых степенями
множества $M 1$ --- образа объекта $1$ из
$\cat{L}$. Назовём это множество $a$. (Это множество иногда
называется \emph{сортом}, а такая алгебра называется \newterm{односортной}. Существуют
обобщения теорий Ловера на многосортные алгебры.) В
частности, бинарные операции из $\cat{L}$ отображаются в функции:
\[a \times a \to a\]
Как и с любым функтором, возможно, что множество морфизмов в $\cat{L}$
схлопываются в одну и ту же функцию в $\Set$.

Кстати, тот факт, что все законы универсально квантифицированы
равенства, означает, что каждая теория Ловера имеет тривиальную модель:
константный функтор, отображающий все объекты в синглтонное множество, а все морфизмы
в тождественную функцию на нём.

Общий морфизм в $\cat{L}$ вида
$m \to n$ отображается в функцию:
\[a^m \to a^n\]
Если у нас есть две различные модели, $M$ и $N$, естественное
преобразование между ними — это семейство функций, индексированное
$n$:
\[\mu_n \Colon M n \to N n\]
или, эквивалентно:
\[\mu_n \Colon a^n \to b^n\]
где $b = N 1$.

Заметим, что условие естественности гарантирует сохранение
$n$-арных операций:
\[N f \circ \mu_n = \mu_1 \circ M f\]
где $f \Colon n \to 1$ — это $n$-арная операция в
$\cat{L}$.

Функторы, определяющие модели, образуют категорию моделей,
$\cat{Mod}(\cat{L}, \Set)$, с естественными преобразованиями как морфизмами.

Рассмотрим модель для тривиальной категории Ловера
$\Fop$. Такая модель полностью определяется своим
значением в $1$, $M 1$. Поскольку $M 1$ может быть любым
множеством, существует столько же таких моделей, сколько множеств в
$\Set$. Более того, каждый морфизм в $\cat{Mod}(\Fop, \Set)$ (естественное
преобразование между функторами $M$ и $N$)
однозначно определяется своей компонентой в $M 1$. И наоборот, каждая
функция $M 1 \to N 1$ индуцирует естественное
преобразование между двумя моделями $M$ и $N$.
Следовательно, $\cat{Mod}(\Fop, \Set)$ эквивалентна $\Set$.

\section{Теория моноидов}

Простейший нетривиальный пример теории Ловера описывает
структуру моноидов. Это единая теория, которая выделяет структуру
всех возможных моноидов в том смысле, что модели этой теории
охватывают всю категорию $\cat{Mon}$ моноидов. Мы уже видели
\hyperref[free-monoids]{универсальную
  конструкцию}, которая показала, что каждый моноид можно получить из подходящего
свободного моноида путём отождествления подмножества морфизмов. Таким образом,
один свободный моноид уже обобщает множество моноидов. Однако
существует бесконечно много свободных моноидов. Теория Ловера для
моноидов $\cat{L}_{\cat{Mon}}$ объединяет все их в одной
элегантной конструкции.

Каждый моноид должен иметь единицу, поэтому мы должны иметь специальный морфизм
$\eta$ в $\cat{L}_{\cat{Mon}}$, который идёт из $0$ в
$1$. Заметим, что не может быть соответствующего морфизма в
$\cat{F}$. Такой морфизм шёл бы в противоположном направлении, из
$1$ в $0$, что в $\cat{FinSet}$ было бы функцией
из синглтонного множества в пустое множество. Такой функции не существует.

Далее рассмотрим морфизмы $2 \to 1$, члены
$\cat{L}_{\cat{Mon}}(2, 1)$, которые должны содержать прототипы всех бинарных
операций. При построении моделей в $\cat{Mod}(\cat{L}_{\cat{Mon}}, \Set)$ эти
морфизмы будут отображаться в функции из декартова произведения
$M 1 \times M 1$ в $M 1$. Другими словами, функции от
двух аргументов.

Вопрос: сколько функций от двух аргументов можно реализовать,
используя только моноидальный оператор. Назовём два аргумента
$a$ и $b$. Есть одна функция, которая игнорирует оба
аргумента и возвращает моноидальную единицу. Затем есть две проекции,
которые возвращают $a$ и $b$ соответственно. За ними следуют
функции, которые возвращают $ab$, $ba$, $aa$,
$bb$, $aab$ и так далее\ldots{} Фактически существует столько же
таких функций от двух аргументов, сколько элементов в свободном моноиде
с генераторами $a$ и $b$. Заметим, что
$\cat{L}_{\cat{Mon}}(2, 1)$ должен содержать все эти морфизмы, потому что одна из
моделей — это свободный моноид. В свободном моноиде они соответствуют различным
функциям. Другие модели могут схлопывать множество морфизмов в
$\cat{L}_{\cat{Mon}}(2, 1)$ до одной функции, но не свободный моноид.

Если обозначить свободный моноид с $n$ генераторами через $n^*$, можем
отождествить hom-множество $\cat{L}(2, 1)$ с hom-множеством
$\cat{Mon}(1^*, 2^*)$ в $\cat{Mon}$, категории моноидов. В
общем случае выбираем $\cat{L}_{\cat{Mon}}(m, n)$ как $\cat{Mon}(n^*, m^*)$. Другими
словами, категория $\cat{L}_{\cat{Mon}}$ — это противоположная категории
свободных моноидов.

Категория \emph{моделей} теории Ловера для моноидов,\\
$\cat{Mod}(\cat{L}_{\cat{Mon}}, \Set)$, эквивалентна категории всех моноидов,
$\cat{Mon}$.

\section{Теории Ловера и монады}

Как вы, возможно, помните, алгебраические теории можно описать с помощью монад
--- в частности,
\hyperref[algebras-for-monads]{алгебр
  для монад}. Поэтому неудивительно, что существует связь
между теориями Ловера и монадами.

Во-первых, посмотрим, как теория Ловера индуцирует монаду. Она делает это
через
\hyperref[free-forgetful-adjunctions]{сопряжение}
между забывающим функтором и свободным функтором. Забывающий функтор
$U$ приписывает множество каждой модели. Это множество получается путём вычисления
функтора $M$ из $\cat{Mod}(\cat{L}, \Set)$ в объекте $1$ в
$\cat{L}$.

Другой способ выведения $U$ — использовать тот факт, что
$\Fop$ — начальный объект в $\cat{Law}$. Это
означает, что для любой теории Ловера $\cat{L}$ существует уникальный
функтор $\Fop \to \cat{L}$. Этот функтор индуцирует
противоположный функтор на моделях (поскольку модели — это функторы \emph{из}
теорий в множества):
\[\cat{Mod}(\cat{L}, \Set) \to \cat{Mod}(\Fop, \Set)\]
Но, как мы обсуждали, категория моделей
$\Fop$ эквивалентна $\Set$, поэтому получаем
забывающий функтор:
\[U \Colon \cat{Mod}(\cat{L}, \Set) \to \Set\]
Можно показать, что так определённый $U$ всегда имеет левый сопряжённый,
свободный функтор $F$.

Это легко видеть для конечных множеств. Свободный функтор $F$
производит свободные алгебры. Свободная алгебра — это конкретная модель в
$\cat{Mod}(\cat{L}, \Set)$, которая генерируется из конечного множества генераторов
$n$. Можем реализовать $F$ как представимый функтор:
\[\cat{L}(n, -) \Colon \cat{L} \to \Set\]
Чтобы показать, что он действительно свободный, всё, что нам нужно сделать, — это доказать, что он является
левым сопряжённым к забывающему функтору:
\[\cat{Mod}(\cat{L}, \Set)(\cat{L}(n, -), M) \cong \Set(n, U(M))\]
Упростим правую часть:
\[\Set(n, U(M)) \cong \Set(n, M 1) \cong (M 1)^n \cong M n\]
(Я использовал тот факт, что множество морфизмов изоморфно
экспоненте, которая в данном случае — это просто итерированное произведение.) Сопряжение — результат леммы Йонеды:
\[[\cat{L}, \Set](\cat{L}(n, -), M) \cong M n\]
Вместе забывающий и свободный функтор определяют
\hyperref[monads-categorically]{монаду}
$T = U \circ F$ на $\Set$. Таким образом, каждая теория Ловера генерирует
монаду.

Оказывается, что категория
\hyperref[algebras-for-monads]{алгебр
  для этой монады} эквивалентна категории моделей.

Вы можете вспомнить, что алгебры монад определяют способы вычисления выражений,
которые формируются с помощью монад. Теория Ловера определяет n-арные операции,
которые можно использовать для генерации выражений. Модели предоставляют средства для
вычисления этих выражений.

Однако связь между монадами и теориями Ловера не является двусторонней.
Только финитарные монады ведут к теориям Ловера. Финитарная монада
основана на финитарном функторе. Финитарный функтор на $\Set$
полностью определяется своим действием на конечные множества. Его действие на
произвольное множество $a$ можно вычислить, используя следующую коэнду:
\[F a = \int^n a^n \times (F n)\]
Поскольку коэнда обобщает копроизведение, или сумму, эта формула является
обобщением разложения в степенной ряд. Или можем использовать интуицию,
что функтор — это обобщённый контейнер. В этом случае финитарный
контейнер $a$ можно описать как сумму форм и
содержимого. Здесь $F n$ — это множество форм для хранения $n$ элементов,
а содержимое — это $n$-кортеж элементов, сам являющийся элементом
$a^n$. Например, список (как функтор) финитарен, с одной
формой для каждой арности. Дерево имеет больше форм на арность, и так далее.

Во-первых, все монады, генерируемые из теорий Ловера, являются
финитарными, и их можно выразить как коэнды:
\[T_{\cat{L}} a = \int^n a^n \times \cat{L}(n, 1)\]
И наоборот, для любой финитарной монады $T$ на $\Set$ можем
построить теорию Ловера. Начнём с построения категории Клейсли
для $T$. Как вы можете помнить, морфизм в категории Клейсли
из $a$ в $b$ задаётся морфизмом в базовой
категории:
\[a \to T b\]
Ограничившись конечными множествами, это становится:
\[m \to T n\]
Категория, противоположная этой категории Клейсли,
$\cat{Kl}^\mathit{op}_{T}$, ограниченная конечными
множествами, является рассматриваемой теорией Ловера. В частности, hom-множество
$\cat{L}(n, 1)$, которое описывает n-арные операции в $\cat{L}$, задаётся
hom-множеством $\cat{Kl}_{T}(1, n)$.

Оказывается, что большинство монад, с которыми мы сталкиваемся в программировании, являются
финитарными, за notable исключением монады продолжений. Возможно
расширить понятие теории Ловера за пределы финитарных
операций.

\section{Монады как коэнды}

Давайте исследуем формулу коэнды более подробно.
\[T_{\cat{L}} a = \int^n a^n \times \cat{L}(n, 1)\]
Начнём с того, что эта коэнда берётся по профунктору $P$ в
$\cat{F}$, определённому как:
\[P n m = a^n \times \cat{L}(m, 1)\]
Этот профунктор контравариантен в первом аргументе, $n$.
Рассмотрим, как он поднимает морфизмы. Морфизм в $\cat{FinSet}$ — это
отображение конечных множеств $f \Colon m \to n$. Такое
отображение описывает выбор $m$ элементов из $n$-элементного множества
(повторения разрешены). Его можно поднять до отображения степеней
$a$, а именно (заметьте направление):
\[a^n \to a^m\]
Поднятие просто выбирает $m$ элементов из кортежа из $n$ элементов\\
$(a_1, a_2, \ldots{}, a_n)$ (возможно, с повторениями).

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/liftpower.png}
\end{figure}

\noindent
Например, возьмём $f_k \Colon 1 \to n$ ---
выбор $k$-го элемента из $n$-элементного множества. Он поднимается до
функции, которая берёт $n$-кортеж элементов $a$ и возвращает
$k$-ый.

Или возьмём $f \Colon m \to 1$ --- константную
функцию, которая отображает все $m$ элементов в один. Её поднятие — это функция, которая
берёт один элемент $a$ и дублирует его $m$ раз:
\[\lambda{}x \to (\underbrace{x, x, \ldots{}, x}_{m})\]
Вы можете заметить, что не сразу очевидно, что профунктор
в вопросе ковариантен во втором аргументе. hom-функтор
$\cat{L}(m, 1)$ на самом деле контравариантен в $m$. Однако мы
берём коэнду не в категории $\cat{L}$, а в категории
$\cat{F}$. Переменная коэнды $n$ проходит по конечным множествам (или их
скелетам). Категория $\cat{L}$ содержит противоположную
$\cat{F}$, поэтому морфизм $m \to n$ в $\cat{F}$
является членом $\cat{L}(n, m)$ в $\cat{L}$ (вложение задаётся
функтором $I_{\cat{L}}$).

Давайте проверим функториальность $\cat{L}(m, 1)$ как функтора из
$\cat{F}$ в $\Set$. Мы хотим поднять функцию
$f \Colon m \to n$, поэтому наша цель — реализовать
функцию из $\cat{L}(m, 1)$ в $\cat{L}(n, 1)$. Соответствуя
функции $f$, есть морфизм в $\cat{L}$ из
$n$ в $m$ (заметьте направление). Предкомпозиция этого
морфизма с $\cat{L}(m, 1)$ даёт нам подмножество
$\cat{L}(n, 1)$.

\begin{figure}[H]
  \centering
  \begin{tikzcd}[column sep=large]
    \cat{L}(m, 1) \arrow[r] & \cat{L}(n, 1)\\
    {}^m \bullet \arrow[r, "f"'] & \bullet^n
  \end{tikzcd}
\end{figure}

\noindent
Заметим, что поднимая функцию $1 \to n$, можем перейти
из $\cat{L}(1, 1)$ в $\cat{L}(n, 1)$. Мы будем использовать этот факт
позже.

Произведение контравариантного функтора $a^n$ и ковариантного
функтора $\cat{L}(m, 1)$ является профунктором
$\Fop \times \cat{F} \to \Set$. Помните, что коэнда может быть определена
как копроизведение (дизъюнктная сумма) всех диагональных элементов
профунктора, в которой некоторые элементы отождествлены. Отождествления
соответствуют условиям коклина.

Здесь коэнда начинается как дизъюнктная сумма множеств
$a^n \times \cat{L}(n, 1)$ по всем $n$. Отождествления могут
быть сгенерированы путём выражения
\hyperref[ends-and-coends]{коэнды как
  коэквалайзера}. Начнём с недиагонального члена
$a^n \times \cat{L}(m, 1)$. Чтобы добраться до диагонали, можем применить
морфизм $f \Colon m \to n$ либо к первому, либо
ко второму компоненту произведения. Два результата затем
отождествляются.

\begin{figure}[H]
  \centering
  \begin{tikzcd}
    & a^n \times \cat{L}(m, 1)
    \arrow[dl, "\langle f {,} \id \rangle"']
    \arrow[dr, "\langle \id {,} f \rangle"]
    & \\
    a^m \times \cat{L}(m, 1)
    & \scalebox{2.5}[1]{\sim}
    & a^n \times \cat{L}(n, 1) \\
    & f \Colon m \to n &
  \end{tikzcd}
\end{figure}

\noindent
Я показал ранее, что поднятие
$f \Colon 1 \to n$ приводит к этим двум
преобразованиям:
\[a^n \to a\]
и:
\[\cat{L}(1, 1) \to \cat{L}(n, 1)\]
Поэтому, начиная с $a^n \times \cat{L}(1, 1)$, можем достичь и:
\[a \times \cat{L}(1, 1)\]
когда поднимаем $\langle f, \id \rangle$, и:
\[a^n \times \cat{L}(n, 1)\]
когда поднимаем $\langle \id, f \rangle$. Это, однако, не
означает, что все элементы $a^n \times \cat{L}(n, 1)$ могут быть
отождествлены с $a \times \cat{L}(1, 1)$. Это потому, что не все элементы
$\cat{L}(n, 1)$ достижимы из $\cat{L}(1, 1)$. Помните,
что можем поднимать только морфизмы из $\cat{F}$. Нетривиальная $n$-арная
операция в $\cat{L}$ не может быть построена поднятием морфизма
$f \Colon 1 \to n$.

Другими словами, можем отождествить только все слагаемые в формуле коэнды,
для которых $\cat{L}(n, 1)$ достижим из $\cat{L}(1, 1)$
через применение базовых морфизмов. Они все эквивалентны
$a \times \cat{L}(1, 1)$. Базовые морфизмы — это те, которые являются образами
морфизмов в $\cat{F}$.

Посмотрим, как это работает в простейшем случае теории Ловера, самой
$\Fop$. В такой теории каждый
$\cat{L}(n, 1)$ достижим из $\cat{L}(1, 1)$. Это потому, что
$\cat{L}(1, 1)$ — синглтон, содержащий только тождественный морфизм,
а $\cat{L}(n, 1)$ содержит только морфизмы, соответствующие
инъекциям $1 \to n$ в $\cat{F}$, которые \emph{являются}
базовыми морфизмами. Поэтому все слагаемые в копроизведении
эквивалентны, и получаем:
\[T a = a \times \cat{L}(1, 1) = a\]
что является тождественной монадой.

\section{Теория Ловера побочных эффектов}

Поскольку существует такая сильная связь между монадами и теориями
Ловера, естественно задать вопрос, могут ли теории Ловера быть
использованы в программировании как альтернатива монадам. Основная проблема с
монадами в том, что они не композируются хорошо. Нет общего рецепта для
построения трансформеров монад. Теории Ловера имеют преимущество в этой
области: они могут композироваться с использованием копроизведений и тензорных произведений. С
другой стороны, только финитарные монады могут легко конвертироваться в теории
Ловера. Исключение здесь — монада продолжений. Ведутся текущие
исследования в этой области (см. библиографию).

Чтобы дать вам представление о том, как теория Ловера может использоваться для описания побочных
эффектов, я обсужу простой случай исключений, которые
традиционно реализуются с помощью монады \code{Maybe}.

Монада \code{Maybe} генерируется теорией Ловера с
единственной нульарной операцией $0 \to 1$. Модель этой
теории — это функтор, который отображает $1$ в некоторое множество $a$ и
отображает нульарную операцию в функцию:

\src{snippet02}
Можем восстановить монаду \code{Maybe}, используя формулу коэнды. Давайте
рассмотрим, что добавление нульарной операции делает с hom-множествами
$\cat{L}(n, 1)$. Помимо создания нового $\cat{L}(0, 1)$ (которое
отсутствует в $\Fop$), оно также добавляет новые морфизмы
в $\cat{L}(n, 1)$. Это результаты композиции морфизмов
типа $n \to 0$ с нашим $0 \to 1$.
Такие вклады все отождествляются с $a^0 \times \cat{L}(0, 1)$ в
формуле коэнды, потому что их можно получить из:
\[a^n \times \cat{L}(0, 1)\]
поднимая $0 \to n$ двумя разными способами.

\begin{figure}[H]
  \centering
  \begin{tikzcd}
    & a^n \times \cat{L}(0, 1)
    \arrow[dl, "\langle f {,} \id \rangle"']
    \arrow[dr, "\langle \id {,} f \rangle"]
    & \\
    a^0 \times \cat{L}(0, 1)
    & \scalebox{2.5}[1]{\sim}
    & a^n \times \cat{L}(n, 1) \\
    & f \Colon 0 \to n &
  \end{tikzcd}
\end{figure}

\noindent
Коэнда сводится к:
\[T_{\cat{L}} a = a^0 + a^1\]
или, используя обозначения Haskell:

\src{snippet03}
что эквивалентно:

\src{snippet04}
Заметим, что эта теория Ловера поддерживает только выброс исключений,
а не их обработку.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Перечислите все морфизмы между $2$ и $3$ в $\cat{F}$ (скелете
        $\cat{FinSet}$).
  \item
        Покажите, что категория моделей для теории Ловера моноидов
        эквивалентна категории алгебр монад для монады списка.
  \item
        Теория Ловера моноидов генерирует монаду списка. Покажите, что её
        бинарные операции могут быть сгенерированы с использованием соответствующих стрелок
        Клейсли.
  \item
        \textbf{FinSet} — подкатегория $\Set$, и существует
        функтор, вкладывающий её в $\Set$. Любой функтор на $\Set$
        может быть ограничен до $\cat{FinSet}$. Покажите, что финитарный функтор —
        это левое расширение Кана его собственного ограничения.
\end{enumerate}

\section{Дополнительное чтение}
\begin{enumerate}
  \tightlist
  \item
        \urlref{http://www.tac.mta.ca/tac/reprints/articles/5/tr5.pdf}{Functorial Semantics of Algebraic Theories}, F. William Lawvere
  \item
        \urlref{http://homepages.inf.ed.ac.uk/gdp/publications/Comp_Eff_Monads.pdf}{Notions of computation determine monads}, Gordon Plotkin and John Power
\end{enumerate}
