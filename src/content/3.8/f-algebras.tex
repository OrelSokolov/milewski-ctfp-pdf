% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{М}{ы видели несколько формулировок} моноида: как множество, как
одно-объектную категорию, как объект в моноидальной категории. Сколько ещё
сока мы можем выжать из этой простой концепции?

Давайте попробуем. Возьмите это определение моноида как множества $m$ с
парой функций:
\begin{align*}
  \mu  & \Colon m\times{}m \to m \\
  \eta & \Colon 1 \to m
\end{align*}
Здесь 1 --- терминальный объект в $\Set$ --- одноэлементное множество.
Первая функция определяет умножение (она принимает пару элементов
и возвращает их произведение), вторая выбирает единичный элемент из
$m$. Не каждый выбор двух функций с этими сигнатурами
приводит к моноиду. Для этого нам нужно наложить дополнительные условия:
ассоциативность и законы единицы. Но давайте забудем об этом на мгновение
и просто рассмотрим ``потенциальные моноиды.'' Пара функций --- элемент
декартова произведения двух множеств функций. Мы знаем, что
эти множества могут быть представлены как экспоненциальные объекты:
\begin{align*}
  \mu  & \in m^{m\times{}m} \\
  \eta & \in m^1
\end{align*}
Декартово произведение этих двух множеств:
\[m^{m\times{}m}\times{}m^1\]
Используя некоторую школьную алгебру (которая работает в каждой декартово замкнутой
категории), мы можем переписать это как:
\[m^{m\times{}m + 1}\]
Знак $+$ означает копроизведение в $\Set$. Мы только что
заменили пару функций одной функцией --- элементом
множества:
\[m\times{}m + 1 \to m\]
Любой элемент этого множества функций --- потенциальный моноид.

Красота этой формулировки в том, что она приводит к интересным
обобщениям. Например, как бы мы описали группу, используя этот
язык? Группа --- это моноид с одной дополнительной функцией, которая назначает
обратный элемент каждому элементу. Последняя --- функция типа
$m \to m$. Как пример, целые числа образуют группу с
сложением как бинарной операцией, нулём как единицей и отрицанием как
обратным. Чтобы определить группу, мы бы начали с тройки функций:
\begin{align*}
  m\times{}m \to m \\
  m \to m          \\
  1 \to m
\end{align*}
Как раньше, мы можем объединить все эти тройки в одно множество функций:
\[m\times{}m + m + 1 \to m\]
Мы начали с одного бинарного оператора (сложение), одного унарного оператора
(отрицание) и одного нульарного оператора (тождество --- здесь ноль). Мы
объединили их в одну функцию. Все функции с этой сигнатурой
определяют потенциальные группы.

Мы можем продолжать таким образом. Например, чтобы определить кольцо, мы бы добавили ещё один
бинарный оператор и один нульарный оператор, и так далее. Каждый раз мы
заканчиваем с типом функции, чья левая сторона --- сумма степеней
(возможно, включая нулевую степень --- терминальный объект), а
правая сторона --- само множество.

Теперь мы можем сойти с ума с обобщениями. Прежде всего, мы можем заменить
множества объектами, а функции морфизмами. Мы можем определить n-арные
операторы как морфизмы из n-арных произведений. Это означает, что нам нужна
категория, которая поддерживает конечные произведения. Для нульарных операторов мы требуем
существования терминального объекта. Так что нам нужна декартова категория.
Чтобы объединить эти операторы, нам нужны экспоненциалы, так что это
декартово замкнутая категория. Наконец, нам нужны копроизведения, чтобы завершить наши
алгебраические проделки.

Альтернативно, мы можем просто забыть о способе, которым мы вывели наши формулы,
и сконцентрироваться на финальном продукте. Сумма произведений на левой
стороне нашего морфизма определяет эндофунктор. Что, если мы выберем
произвольный эндофунктор $F$ вместо этого? В этом случае нам не нужно
накладывать никаких ограничений на нашу категорию. То, что мы получаем, называется
$F$-алгеброй.

$F$-алгебра --- это тройка, состоящая из эндофунктора $F$,
объекта $a$ и морфизма
\[F a \to a\]
Объект часто называется носителем, лежащим в основе объектом или, в
контексте программирования, \emph{типом}-носителем. Морфизм часто
называется функцией вычисления или структурным отображением. Думайте о
функторе $F$ как формирующем выражения, а о морфизме как вычисляющем
их.

Вот определение Haskell для $F$-алгебры:

\src{snippet01}
Оно идентифицирует алгебру с её функцией вычисления.

В примере с моноидом функтор в вопросе:

\src{snippet02}
Это Haskell для $1 + a\times{}a$ (помните
\hyperref[simple-algebraic-data-types]{алгебраические
  структуры данных}).

Кольцо было бы определено, используя следующий функтор:

\src{snippet03}
что является Haskell для $1 + 1 + a\times{}a + a\times{}a + a$.

Пример кольца --- множество целых чисел. Мы можем выбрать
\code{Integer} как тип-носитель и определить функцию вычисления
как:

\src{snippet04}
Есть больше $F$-алгебр, основанных на том же функторе \code{RingF}. Например,
полиномы образуют кольцо, так же как и квадратные матрицы.

Как вы можете видеть, роль функтора --- генерировать выражения, которые
могут быть вычислены с использованием вычислителя алгебры. До сих пор мы только
видели очень простые выражения. Мы часто интересуемся более сложными
выражениями, которые могут быть определены с использованием рекурсии.

\section{Рекурсия}

Один способ генерировать произвольные деревья выражений --- заменить
переменную \code{a} внутри определения функтора рекурсией. Например,
произвольное выражение в кольце генерируется этой
древовидной структурой данных:

\src{snippet05}
Мы можем заменить исходный вычислитель кольца его рекурсивной версией:

\src{snippet06}
Это всё ещё не очень практично, поскольку мы вынуждены представлять все
целые числа как суммы единиц, но сойдёт в крайнем случае.

Но как мы можем описать деревья выражений, используя язык
$F$-алгебр? Мы должны как-то формализовать процесс замены свободной
типовой переменной в определении нашего функтора, рекурсивно, на
результат замены. Представьте это делающимся шагами. Сначала
определите дерево глубины один как:

\src{snippet07}
Мы заполняем дыры в определении \code{RingF}
деревьями глубины ноль, порождёнными \code{RingF a}. Деревья глубины 2
аналогично получаются как:

\src{snippet08}
что мы также можем написать как:

\src{snippet09}
Продолжая этот процесс, мы можем написать символическое уравнение:

\begin{snipv}
type RingF\textsubscript{n+1} a = RingF (RingF\textsubscript{n} a)
\end{snipv}
Концептуально, после повторения этого процесса бесконечно много раз, мы заканчиваем
с нашим \code{Expr}. Обратите внимание, что \code{Expr} не зависит от
\code{a}. Начальная точка нашего путешествия не важна, мы всегда
заканчиваем в том же месте. Это не всегда верно для произвольного
эндофунктора в произвольной категории, но в категории $\Set$
вещи хороши.

Конечно, это размахивающий руками аргумент, и я сделаю его более
строгим позже.

Применение эндофунктора бесконечно много раз производит \newterm{неподвижную
  точку}, объект, определённый как:
\[\mathit{Fix}\ f = f\ (\mathit{Fix}\ f)\]
Интуиция за этим определением в том, что, поскольку мы применили
$f$ бесконечно много раз, чтобы получить $\mathit{Fix}\ f$, применение его ещё один
раз ничего не меняет. В Haskell определение неподвижной
точки:

\src{snippet10}
Возможно, это было бы более читаемо, если бы имя конструктора было
отличным от имени определяемого типа, как в:

\src{snippet11}
но я буду придерживаться принятой нотации. Конструктор \code{Fix}
(или \code{In}, если предпочитаете) может рассматриваться как функция:

\src{snippet12}
Есть также функция, которая снимает один уровень применения функтора:

\src{snippet13}
Две функции --- обратные друг другу. Мы будем использовать эти
функции позже.

\section{Категория $F$-алгебр}

Вот самый старый трюк в книге: всякий раз, когда вы придумываете способ
конструирования каких-то новых объектов, посмотрите, образуют ли они категорию. Неудивительно,
что алгебры над данным эндофунктором $F$ образуют
категорию. Объекты в этой категории --- алгебры --- пары, состоящие из
объекта-носителя $a$ и морфизма
$F a \to a$, оба из исходной категории
$\cat{C}$.

Чтобы завершить картину, мы должны определить морфизмы в категории
$F$-алгебр. Морфизм должен отображать одну алгебру $(a, f)$ в другую
алгебру $(b, g)$. Мы определим его как морфизм $m$, который
отображает носители --- он идёт из $a$ в $b$ в
исходной категории. Не любой морфизм подойдёт: мы хотим, чтобы он был совместим
с двумя вычислителями. (Мы называем такой структуро-сохраняющий морфизм
\newterm{гомоморфизмом}.) Вот как вы определяете гомоморфизм
$F$-алгебр. Сначала заметьте, что мы можем поднять $m$ к отображению:
\[F m \Colon F a \to F b\]
затем мы можем последовать за ним с $g$, чтобы попасть в $b$.
Эквивалентно, мы можем использовать $f$, чтобы пойти из $F a$ в
$a$, а затем последовать за этим с $m$. Мы хотим, чтобы два пути
были равны:
\[g \circ F m = m \circ f\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/alg.png}
\end{figure}

\noindent
Легко убедить себя, что это действительно категория (подсказка:
тождественные морфизмы из $\cat{C}$ работают прекрасно, а композиция
гомоморфизмов --- это гомоморфизм).

Начальный объект в категории $F$-алгебр, если он существует, называется
\newterm{начальной алгеброй}. Давайте назовём носитель этой начальной
алгебры $i$, а её вычислитель $j \Colon F i \to i$. Оказывается, что $j$,
вычислитель начальной алгебры, --- изоморфизм. Этот результат
известен как теорема Ламбека. Доказательство полагается на определение
начального объекта, которое требует, чтобы существовал уникальный гомоморфизм
$m$ из него в любую другую $F$-алгебру. Поскольку $m$ ---
гомоморфизм, следующая диаграмма должна коммутировать:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/alg2.png}
\end{figure}

\noindent
Теперь давайте сконструируем алгебру, чей носитель --- $F i$.
Вычислитель такой алгебры должен быть морфизмом из $F (F i)$
в $F i$. Мы можем легко сконструировать такой вычислитель, просто
подняв $j$:
\[F j \Colon F (F i) \to F i\]
Поскольку $(i, j)$ --- начальная алгебра, должен существовать уникальный
гомоморфизм $m$ из неё в $(F i, F j)$. Следующая
диаграмма должна коммутировать:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/alg3a.png}
\end{figure}

\noindent
Но у нас также есть эта тривиально коммутирующая диаграмма (оба пути
одинаковы!):

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/alg3.png}
\end{figure}

\noindent
которая может быть интерпретирована как показывающая, что $j$ --- гомоморфизм
алгебр, отображающий $(F i, F j)$ в $(i, j)$. Мы можем
склеить эти две диаграммы вместе, чтобы получить:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{images/alg4.png}
\end{figure}

\noindent
Эта диаграмма может, в свою очередь, быть интерпретирована как показывающая, что
$j \circ m$ --- гомоморфизм алгебр. Только в этом случае
две алгебры одинаковы. Более того, поскольку $(i, j)$
начальная, может быть только один гомоморфизм из неё в себя, и
это тождественный морфизм $\id_i$ --- который мы знаем, является
гомоморфизмом алгебр. Следовательно, $j \circ m = \id_i$. Используя этот
факт и коммутирующее свойство левой диаграммы, мы можем доказать, что
$m \circ j = \id_{Fi}$. Это показывает, что $m$ --- обратный
$j$, и следовательно, $j$ --- изоморфизм между
$F i$ и $i$:
\[F i \cong i\]
Но это просто говорит, что $i$ --- неподвижная точка $F$.
Это формальное доказательство за исходным размахивающим руками аргументом.

Обратно к Haskell: мы узнаём $i$ как наш \code{Fix f},
$j$ как наш конструктор \code{Fix}, а его обратный как
\code{unFix}. Изоморфизм в теореме Ламбека говорит нам, что
чтобы получить начальную алгебру, мы берём функтор $f$ и
заменяем его аргумент $a$ на \code{Fix f}. Мы также видим, почему
неподвижная точка не зависит от $a$.

\section{Натуральные числа}

Натуральные числа также могут быть определены как $F$-алгебра. Отправная точка
--- пара морфизмов:
\begin{align*}
  zero & \Colon 1 \to N \\
  succ & \Colon N \to N
\end{align*}
Первый выбирает ноль, а второй отображает все числа в их
последователей. Как раньше, мы можем объединить два в один:
\[1 + N \to N\]
Левая сторона определяет функтор, который в Haskell может быть записан
так:

\src{snippet14}
Неподвижная точка этого функтора (начальная алгебра, которую он генерирует)
может быть закодирована в Haskell как:

\src{snippet15}
Натуральное число --- либо ноль, либо последователь другого числа. Это
известно как представление Пеано для натуральных чисел.

\section{Катаморфизмы}

Давайте перепишем условие инициальности, используя нотацию Haskell. Мы называем
начальную алгебру \code{Fix f}. Её вычислитель --- конструктор
\code{Fix}. Существует уникальный морфизм \code{m} из начальной
алгебры в любую другую алгебру над тем же функтором. Давайте выберем
алгебру, чей носитель --- \code{a}, а вычислитель --- \code{alg}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/alg5.png}
\end{figure}

\noindent
Кстати, заметьте, что такое \code{m}: это вычислитель для неподвижной
точки, вычислитель для всего рекурсивного дерева выражений. Давайте найдём
общий способ реализации его.

Теорема Ламбека говорит нам, что конструктор \code{Fix} ---
изоморфизм. Мы назвали его обратный \code{unFix}. Мы можем следовательно перевернуть
одну стрелку в этой диаграмме, чтобы получить:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/alg6.png}
\end{figure}

\noindent
Давайте запишем условие коммутации для этой диаграммы:

\begin{snip}{haskell}
m = alg . fmap m . unFix
\end{snip}
Мы можем интерпретировать это уравнение как рекурсивное определение \code{m}.
Рекурсия обязательно завершится для любого конечного дерева, созданного с использованием
функтора \code{f}. Мы можем увидеть это, заметив, что
\code{fmap m} действует под верхним слоем функтора
\code{f}. Другими словами, он работает на детях исходного
дерева. Дети всегда на один уровень мельче, чем исходное
дерево.

Вот что происходит, когда мы применяем \code{m} к дереву, сконструированному с использованием
\code{Fix\ f}. Действие \code{unFix} снимает конструктор,
выставляя верхний уровень дерева. Затем мы применяем \code{m} ко всем
детям верхнего узла. Это производит результаты типа \code{a}.
Наконец, мы комбинируем эти результаты, применяя нерекурсивный
вычислитель \code{alg}. Ключевой момент в том, что наш вычислитель \code{alg}
--- простая нерекурсивная функция.

Поскольку мы можем делать это для любой алгебры \code{alg}, имеет смысл
определить функцию высшего порядка, которая принимает алгебру как параметр и
даёт нам функцию, которую мы назвали \code{m}. Эта функция высшего порядка
называется катаморфизмом:

\src{snippet16}
Давайте посмотрим на пример этого. Возьмите функтор, который определяет натуральные
числа:

\src{snippet17}
Давайте выберем \code{(Int, Int)} как тип-носитель и определим нашу
алгебру как:

\src{snippet18}
Вы можете легко убедить себя, что катаморфизм для этой алгебры,
\code{cata fib}, вычисляет числа Фибоначчи.

В общем случае алгебра для \code{NatF} определяет рекуррентное отношение:
значение текущего элемента в терминах предыдущего элемента.
Катаморфизм затем вычисляет n-й элемент этой последовательности.

\section{Свёртки}

Список \code{e} --- начальная алгебра следующего функтора:

\src{snippet19}
Действительно, заменяя переменную \code{a} результатом рекурсии,
который мы назовём \code{List e}, мы получаем:

\src{snippet20}
Алгебра для функтора списка выбирает конкретный тип-носитель и
определяет функцию, которая делает сопоставление с образцом на двух конструкторах.
Её значение для \code{NilF} говорит нам, как вычислять пустой список, а
её значение для \code{ConsF} говорит нам, как комбинировать текущий элемент
с ранее накопленным значением.

Например, вот алгебра, которая может быть использована для вычисления длины
списка (тип-носитель --- \code{Int}):

\src{snippet21}
Действительно, результирующий катаморфизм \code{cata lenAlg} вычисляет
длину списка. Обратите внимание, что вычислитель --- комбинация (1)
функции, которая принимает элемент списка и аккумулятор и возвращает новый
аккумулятор, и (2) начального значения, здесь ноль. Тип значения
и тип аккумулятора задаются типом-носителем.

Сравните это с традиционным определением Haskell:

\src{snippet22}
Два аргумента \code{foldr} --- в точности две компоненты
алгебры.

Давайте попробуем другой пример:

\src{snippet23}
Опять, сравните это с:

\src{snippet24}
Как вы можете видеть, \code{foldr} --- это просто удобная специализация
катаморфизма для списков.

\section{Коалгебры}

Как обычно, у нас есть двойственная конструкция F-коалгебры, где
направление морфизма обращено:
\[a \to F a\]
Коалгебры для данного функтора также образуют категорию, с гомоморфизмами,
сохраняющими коалгебраическую структуру. Терминальный объект
$(t, u)$ в этой категории называется терминальной (или финальной)
коалгеброй. Для каждой другой алгебры $(a, f)$ существует уникальный
гомоморфизм $m$, который заставляет следующую диаграмму коммутировать:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/alg7.png}
\end{figure}

\noindent
Терминальная коалгебра --- неподвижная точка функтора в том смысле, что
морфизм $u \Colon t \to F t$ --- изоморфизм
(теорема Ламбека для коалгебр):
\[F t \cong t\]
Терминальная коалгебра обычно интерпретируется в программировании как рецепт
для генерации (возможно, бесконечных) структур данных или систем
переходов.

Так же, как катаморфизм может быть использован для вычисления начальной алгебры,
анаморфизм может быть использован для ковычисления терминальной коалгебры:

\src{snippet25}
Канонический пример коалгебры основан на функторе, чья неподвижная
точка --- бесконечный поток элементов типа \code{e}. Это
функтор:

\src{snippet26}
и это его неподвижная точка:

\src{snippet27}
Коалгебра для \code{StreamF e} --- функция, которая принимает зерно
типа \code{a} и производит пару (\code{StreamF} --- фантазийное имя
для пары), состоящую из элемента и следующего зерна.

Вы можете легко сгенерировать простые примеры коалгебр, которые производят
бесконечные последовательности, как список квадратов или обратных величин.

Более интересный пример --- коалгебра, которая производит список
простых чисел. Трюк в том, чтобы использовать бесконечный список как носитель. Нашим начальным
зерном будет список \code{{[}2..{]}}. Следующее зерно будет хвостом
этого списка со всеми кратными 2, удалёнными. Это список нечётных чисел,
начинающийся с 3. На следующем шаге мы возьмём хвост этого списка и
удалим все кратные 3, и так далее. Вы можете узнать признаки
решета Эратосфена. Эта коалгебра реализуется следующей
функцией:

\src{snippet28}
Анаморфизм для этой коалгебры генерирует список простых чисел:

\src{snippet29}
Поток --- бесконечный список, так что должно быть возможно конвертировать его в
список Haskell. Чтобы сделать это, мы можем использовать тот же функтор \code{StreamF}
для формирования алгебры, и мы можем запустить катаморфизм над ней. Например,
это катаморфизм, который конвертирует поток в список:

\src{snippet30}
Здесь та же неподвижная точка одновременно начальная алгебра и
терминальная коалгебра для одного и того же эндофунктора. Не всегда так
в произвольной категории. В общем случае эндофунктор может иметь много (или
никаких) неподвижных точек. Начальная алгебра --- так называемая наименьшая неподвижная
точка, а терминальная коалгебра --- наибольшая неподвижная точка. В
Haskell, однако, обе определяются одной и той же формулой, и они
совпадают.

Анаморфизм для списков называется unfold. Чтобы создать конечные списки,
функтор модифицируется, чтобы произвести пару \code{Maybe}:

\src{snippet31}
Значение \code{Nothing} завершит генерацию списка.

Интересный случай коалгебры связан с линзами. Линза может быть
представлена как пара геттера и сеттера:

\src{snippet32}
Здесь \code{a} обычно некоторый тип данных произведения с полем типа
\code{s}. Геттер извлекает значение этого поля, а сеттер
заменяет это поле новым значением. Эти две функции могут быть
объединены в одну:

\src{snippet33}
Мы можем переписать эту функцию далее как:

\src{snippet34}
где мы определили функтор:

\src{snippet35}
Обратите внимание, что это не простой алгебраический функтор, сконструированный из сумм
произведений. Он включает экспоненциал $a^s$.

Линза --- коалгебра для этого функтора с типом-носителем \code{a}.
Мы видели раньше, что \code{Store s} также комонада. Оказывается,
что очень хорошо ведущая себя линза соответствует коалгебре, которая совместима
со структурой комонады. Мы поговорим об этом в следующей секции.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Реализуйте функцию вычисления для кольца полиномов одной
        переменной. Вы можете представить полином как список коэффициентов перед
        степенями $x$. Например, $4x^2-1$ был бы
        представлен как (начиная с нулевой степени)
        \code{{[}-1, 0, 4{]}}.
  \item
        Обобщите предыдущую конструкцию на полиномы многих
        независимых переменных, как $x^2y-3y^3z$.
  \item
        Реализуйте алгебру для кольца $2\times{}2$ матриц.
  \item
        Определите коалгебру, чей анаморфизм производит список квадратов
        натуральных чисел.
  \item
        Используйте \code{unfoldr} для генерации списка первых $n$ простых чисел.
\end{enumerate}
