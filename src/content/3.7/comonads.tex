% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{Т}{еперь, когда мы покрыли} монады, мы можем пожать плоды двойственности и
получить комонады бесплатно, просто обратив стрелки и работая в
противоположной категории.

Вспомните, что на самом базовом уровне монады о композиции стрелок
Клейсли:

\src{snippet01}
где \code{m} --- функтор, который является монадой. Если мы используем букву
\code{w} (перевёрнутая \code{m}) для комонады, мы можем определить
ко-стрелки Клейсли как морфизмы типа:

\src{snippet02}
Аналог оператора рыбы для ко-стрелок Клейсли определяется как:

\src{snippet03}
Чтобы ко-стрелки Клейсли образовали категорию, мы также должны иметь
тождественную ко-стрелку Клейсли, которая называется \code{extract}:

\src{snippet04}
Это двойственное \code{return}. Мы также должны наложить законы
ассоциативности, а также левого и правого тождества. Собирая всё
вместе, мы могли бы определить комонаду в Haskell как:

\src{snippet05}
На практике мы используем немного другие примитивы, как мы скоро увидим.

Вопрос в том, какое применение комонад в программировании?

\section{Программирование с комонадами}

Давайте сравним монаду с комонадой. Монада предоставляет способ
помещения значения в контейнер, используя \code{return}. Она не даёт
вам доступа к значению или значениям, хранящимся внутри. Конечно, структуры
данных, которые реализуют монады, могут предоставить доступ к своему содержимому,
но это считается бонусом. Нет общего интерфейса для
извлечения значений из монады. И мы видели пример
монады \code{IO}, которая гордится тем, что никогда не выставляет своё содержимое.

Комонада, с другой стороны, предоставляет средства извлечения единственного
значения из неё. Она не даёт средств для вставки значений. Так что если вы
хотите думать о комонаде как о контейнере, она всегда идёт предзаполненной
содержимым, и она позволяет вам заглянуть в неё.

Так же, как стрелка Клейсли принимает значение и производит некоторый приукрашенный
результат --- она приукрашивает его контекстом --- ко-стрелка Клейсли принимает
значение вместе с целым контекстом и производит результат. Это
воплощение \newterm{контекстного вычисления}.

\section{Комонада произведения}

Помните монаду reader? Мы ввели её для решения проблемы
реализации вычислений, которые нуждаются в доступе к некоторому окружению только для чтения
\code{e}. Такие вычисления могут быть представлены как чистые функции
формы:

\src{snippet06}
Мы использовали каррирование, чтобы превратить их в стрелки Клейсли:

\src{snippet07}
Но заметьте, что эти функции уже имеют форму ко-стрелок
Клейсли. Давайте помассируем их аргументы в более удобную форму функтора:

\src{snippet08}
Мы можем легко определить оператор композиции, делая то же
окружение доступным для стрелок, которые мы композируем:

\src{snippet09}
Реализация \code{extract} просто игнорирует окружение:

\src{snippet10}
Неудивительно, что комонада произведения может быть использована для выполнения точно тех же
вычислений, что и монада reader. В каком-то смысле комонадическая
реализация окружения более естественна --- она следует
духу ``вычисления в контексте.'' С другой стороны, монады идут
с удобным синтаксическим сахаром нотации \code{do}.

Связь между монадой reader и комонадой произведения идёт
глубже, имея дело с фактом, что функтор reader --- правый
сопряжённый функтора произведения. В общем случае, однако, комонады покрывают
разные понятия вычислений, чем монады. Мы увидим больше примеров
позже.

Легко обобщить комонаду \code{Product} на произвольные
типы произведения, включая кортежи и записи.

\section{Препарирование композиции}

Продолжая процесс дуализации, мы могли бы пойти вперёд и дуализовать
монадический bind и join. Альтернативно, мы можем повторить процесс, который мы использовали
с монадами, где мы изучали анатомию оператора рыбы. Этот
подход кажется более просветляющим.

Отправная точка --- осознание, что оператор композиции должен
произвести ко-стрелку Клейсли, которая принимает \code{w a} и производит
\code{c}. Единственный способ произвести \code{c} --- применить вторую
функцию к аргументу типа \code{w b}:

\src{snippet11}
Но как мы можем произвести значение типа \code{w b}, которое могло бы быть скормлено
\code{g}? У нас в распоряжении аргумент типа
\code{w a} и функция \code{f :: w a -> b}.
Решение --- определить двойственное bind, которое называется extend:

\src{snippet12}
Используя \code{extend}, мы можем реализовать композицию:

\src{snippet13}
Можем ли мы далее препарировать \code{extend}? Вы можете быть соблазнены сказать, почему
бы не просто применить функцию \code{w a -> b} к
аргументу \code{w a}, но затем вы быстро осознаёте, что у вас не было бы
способа конвертировать результирующий \code{b} в \code{w b}. Помните,
комонада не предоставляет средств подъёма значений. На этом этапе в
аналогичной конструкции для монад мы использовали \code{fmap}. Единственный способ,
которым мы могли бы использовать \code{fmap} здесь, --- если бы у нас было что-то типа
\code{w (w a)} в нашем распоряжении. Если бы мы могли только превратить \code{w a}
в\\ \code{w (w a)}. И, удобно, это было бы в точности
двойственное \code{join}. Мы называем это \code{duplicate}:

\src{snippet14}
Так что, как и с определениями монады, у нас есть три
эквивалентных определения комонады: используя ко-стрелки Клейсли,
\code{extend} или \code{duplicate}. Вот определение Haskell,
взятое прямо из\\ библиотеки \code{Control.Comonad}:

\src{snippet15}
Предоставлены реализации по умолчанию \code{extend} в терминах
\code{duplicate} и наоборот, так что вам нужно только переопределить одну из
них.

Интуиция за этими функциями основана на идее, что в
общем случае комонада может рассматриваться как контейнер, заполненный значениями
типа \code{a} (комонада произведения была специальным случаем только одного
значения). Есть понятие ``текущего'' значения, того, которое легко
доступно через \code{extract}. Ко-стрелка Клейсли выполняет некоторое
вычисление, которое сфокусировано на текущем значении, но она имеет доступ ко
всем окружающим значениям. Думайте об игре жизнь Конуэя. Каждая
клетка содержит значение (обычно просто \code{True} или \code{False}).
Комонада, соответствующая игре жизнь, была бы сеткой клеток,
сфокусированной на ``текущей'' клетке.

Так что делает \code{duplicate}? Она принимает комонадический контейнер
\code{w a} и производит контейнер контейнеров \code{w (w a)}.
Идея в том, что каждый из этих контейнеров сфокусирован на разном
\code{a} внутри \code{w a}. В игре жизнь вы бы получили
сетку сеток, каждая клетка внешней сетки, содержащая внутреннюю сетку,
которая сфокусирована на разной клетке.

Теперь посмотрите на \code{extend}. Она принимает ко-стрелку Клейсли и комонадический
контейнер \code{w a}, заполненный \code{a}. Она применяет
вычисление ко всем этим \code{a}, заменяя их
\code{b}. Результат --- комонадический контейнер, заполненный
\code{b}. \code{extend} делает это, сдвигая фокус с одного
\code{a} на другое и применяя ко-стрелку Клейсли к каждому из них
по очереди. В игре жизнь ко-стрелка Клейсли вычислила бы
новое состояние текущей клетки. Чтобы сделать это, она посмотрела бы на её контекст
--- предположительно её ближайших соседей. Реализация по умолчанию
\code{extend} иллюстрирует этот процесс. Сначала мы вызываем
\code{duplicate}, чтобы произвести все возможные фокусы, а затем применяем
\code{f} к каждому из них.

\section{Комонада потока}

Этот процесс сдвига фокуса с одного элемента контейнера на
другой лучше всего иллюстрируется примером бесконечного потока. Такой
поток --- как список, за исключением того, что он не имеет пустого
конструктора:

\src{snippet16}
Он тривиально \code{Functor}:

\src{snippet17}
Фокус потока --- его первый элемент, так что вот реализация
\code{extract}:

\src{snippet18}
\code{duplicate} производит поток потоков, каждый сфокусирован на
разном элементе.

\src{snippet19}
Первый элемент --- исходный поток, второй элемент --- хвост
исходного потока, третий элемент --- его хвост, и так далее, до
бесконечности.

Вот полный экземпляр:

\src{snippet20}
Это очень функциональный способ взгляда на потоки. В императивном
языке мы, вероятно, начали бы с метода \code{advance}, который
сдвигает поток на одну позицию. Здесь \code{duplicate} производит все
сдвинутые потоки одним махом. Ленивость Haskell делает это
возможным и даже желательным. Конечно, чтобы сделать \code{Stream}
практичным, мы также реализовали бы аналог \code{advance}:

\src{snippet21}
но это никогда не часть комонадического интерфейса.

Если у вас был какой-либо опыт с цифровой обработкой сигналов, вы увидите
немедленно, что ко-стрелка Клейсли для потока --- это просто цифровой
фильтр, а \code{extend} производит отфильтрованный поток.

Как простой пример, давайте реализуем фильтр скользящего среднего. Вот
функция, которая суммирует \code{n} элементов потока:

\src{snippet22}
Вот функция, которая вычисляет среднее первых \code{n}
элементов потока:

\src{snippet23}
Частично применённая \code{average n} --- ко-стрелка Клейсли, так что мы можем
\code{extend}ить её над всем потоком:

\src{snippet24}
Результат --- поток текущих средних.

Поток --- пример однонаправленной, одномерной комонады. Она
может быть легко сделана двунаправленной или расширена на два или более измерения.

\section{Комонада категорно}

Определение комонады в теории категорий --- прямолинейное упражнение в
двойственности. Как и с монадой, мы начинаем с эндофунктора $T$.
Два естественных преобразования, $\eta$ и $\mu$, которые определяют монаду, просто
обращены для комонады:
\begin{align*}
  \varepsilon & \Colon T \to I   \\
  \delta      & \Colon T \to T^2
\end{align*}
Компоненты этих преобразований соответствуют \code{extract}
и \code{duplicate}. Законы комонады --- зеркальное изображение законов монады.
Никакого большого сюрприза здесь.

Затем есть вывод монады из сопряжения. Двойственность
обращает сопряжение: левый сопряжённый становится правым сопряжённым и
наоборот. И, поскольку композиция $R \circ L$ определяет монаду,
$L \circ R$ должна определять комонаду. Коединица сопряжения:
\[\varepsilon \Colon L \circ R \to I\]
действительно та же $\varepsilon$, которую мы видим в определении комонады ---
или, в компонентах, как \code{extract} Haskell. Мы также можем использовать
единицу сопряжения:
\[\eta \Colon I \to R \circ L\]
чтобы вставить $R \circ L$ в середину $L \circ R$ и
произвести $L \circ R \circ L \circ R$. Создание $T^2$ из $T$
определяет $\delta$, и это завершает определение комонады.

Мы также видели, что монада --- моноид. Двойственное этого утверждения
потребовало бы использования комоноида, так что такое комоноид? Исходное
определение моноида как одно-объектной категории не дуализуется в
что-либо интересное. Когда вы обращаете направление всех
эндоморфизмов, вы получаете другой моноид. Однако вспомните, что в нашем
подходе к монаде мы использовали более общее определение моноида как
объекта в моноидальной категории. Конструкция была основана на двух
морфизмах:
\begin{align*}
  \mu  & \Colon m \otimes m \to m \\
  \eta & \Colon i \to m
\end{align*}
Обращение этих морфизмов производит комоноид в моноидальной
категории:
\begin{align*}
  \delta      & \Colon m \to m \otimes m \\
  \varepsilon & \Colon m \to i
\end{align*}
Можно написать определение комоноида в Haskell:

\src{snippet25}
но оно довольно тривиально. Очевидно, \code{destroy} игнорирует свой
аргумент.

\src{snippet26}
\code{split} --- это просто пара функций:

\src{snippet27}
Теперь рассмотрите законы комоноида, которые двойственны законам единицы моноида.

\src{snippet28}
Здесь \code{lambda} и \code{rho} --- левый и правый унитор,
соответственно (см. определение
\hyperref[monads-categorically]{моноидальных
  категорий}). Подставляя определения, мы получаем:

\src{snippet29}
что доказывает, что \code{g = id}. Аналогично, второй закон расширяется
до \code{f = id}. В заключение:

\src{snippet30}
что показывает, что в Haskell (и, в общем случае, в категории
$\Set$) каждый объект --- тривиальный комоноид.

К счастью, есть другие более интересные моноидальные категории, в
которых можно определять комоноиды. Одна из них --- категория эндофункторов.
И оказывается, что так же, как монада --- моноид в категории
эндофункторов,

\begin{quote}
  Комонада --- это комоноид в категории эндофункторов.
\end{quote}

\section{Комонада Store}

Другой важный пример комонады --- двойственное монады состояния.
Она называется комонадой costate или, альтернативно, комонадой store.

Мы видели раньше, что монада состояния порождается сопряжением,
которое определяет экспоненциалы:
\begin{align*}
  L z & = z\times{}s      \\
  R a & = s \Rightarrow a
\end{align*}
Мы будем использовать то же сопряжение для определения комонады costate. Комонада
определяется композицией $L \circ R$:
\[L (R a) = (s \Rightarrow a)\times{}s\]
Переводя это в Haskell, мы начинаем с сопряжения между
функтором \code{Product} слева и функтором \code{Reader}
справа. Композиция \code{Product} после \code{Reader} эквивалентна
следующему определению:

\src{snippet31}
Коединица сопряжения, взятая в объекте $a$, --- это
морфизм:
\[\varepsilon_a \Colon ((s \Rightarrow a)\times{}s) \to a\]
или в нотации Haskell:

\src{snippet32}
Это становится нашим \code{extract}:

\src{snippet33}
Единица сопряжения:

\src{snippet34}
может быть переписана как частично применённый конструктор данных:

\src{snippet35}
Мы конструируем $\delta$, или \code{duplicate}, как горизонтальную композицию:
\begin{align*}
  \delta & \Colon L \circ R \to L \circ R \circ L \circ R \\
  \delta & = L \circ \eta \circ R
\end{align*}
Мы должны протащить $\eta$ через крайний левый $L$, который является
функтором \code{Product}. Это означает действие $\eta$, или \code{Store f}, на
левом компоненте пары (это то, что \code{fmap} для
\code{Product} сделал бы). Мы получаем:

\src{snippet36}
(Помните, что в формуле для $\delta$ $L$ и $R$ означают
тождественные естественные преобразования, чьи компоненты ---
тождественные морфизмы.)

Вот полное определение комонады \code{Store}:

\src{snippet37}
Вы можете думать о части \code{Reader} из \code{Store} как о
обобщённом контейнере \code{a}, которые проиндексированы, используя элементы
типа \code{s}. Например, если \code{s} --- \code{Int},
\code{Reader Int a} --- бесконечный двунаправленный поток
\code{a}. \code{Store} парит этот контейнер со значением типа ключа.
Например, \code{Reader Int a} парится с
\code{Int}. В этом случае \code{extract} использует это целое число для индексации
в бесконечный поток. Вы можете думать о втором компоненте
\code{Store} как о текущей позиции.

Продолжая с этим примером, \code{duplicate} создаёт новый бесконечный
поток, проиндексированный \code{Int}. Этот поток содержит потоки как свои
элементы. В частности, в текущей позиции он содержит
исходный поток. Но если вы используете какой-то другой \code{Int} (положительный или
отрицательный) как ключ, вы получили бы сдвинутый поток, позиционированный в этом
новом индексе.

В общем случае вы можете убедить себя, что когда \code{extract} действует на
\code{duplicate}нный \code{Store}, он производит исходный
\code{Store} (на самом деле, закон тождества для комонады утверждает, что
\code{extract . duplicate = id}).

Комонада \code{Store} играет важную роль как теоретическая
основа для библиотеки \code{lens}. Концептуально,
комонада \code{Store s a} инкапсулирует идею ``фокусировки'' (как
линза) на конкретной подструктуре типа данных \code{a}, используя
тип \code{s} как индекс. В частности, функция типа:

\src{snippet38}
эквивалентна паре функций:

\src{snippet39}
Если \code{a} --- тип произведения, \code{set} может быть реализована как
установка поля типа \code{s} внутри \code{a} при
возврате модифицированной версии \code{a}. Аналогично, \code{get}
может быть реализована для чтения значения поля \code{s} из
\code{a}. Мы исследуем эти идеи больше в следующей секции.

\section{Задачи}

\begin{enumerate}
  \tightlist
  \item
        Реализуйте игру жизнь Конуэя, используя комонаду \code{Store}.
        Подсказка: какой тип вы выбираете для \code{s}?
\end{enumerate}
